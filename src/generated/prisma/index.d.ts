
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Owner
 * 
 */
export type Owner = $Result.DefaultSelection<Prisma.$OwnerPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Bar
 * 
 */
export type Bar = $Result.DefaultSelection<Prisma.$BarPayload>
/**
 * Model Offering
 * 
 */
export type Offering = $Result.DefaultSelection<Prisma.$OfferingPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model ActivityCategory
 * 
 */
export type ActivityCategory = $Result.DefaultSelection<Prisma.$ActivityCategoryPayload>
/**
 * Model CategoryRequest
 * 
 */
export type CategoryRequest = $Result.DefaultSelection<Prisma.$CategoryRequestPayload>
/**
 * Model OwnerPasswordReset
 * 
 */
export type OwnerPasswordReset = $Result.DefaultSelection<Prisma.$OwnerPasswordResetPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model PromoRedemption
 * 
 */
export type PromoRedemption = $Result.DefaultSelection<Prisma.$PromoRedemptionPayload>
/**
 * Model BarAnalytics
 * 
 */
export type BarAnalytics = $Result.DefaultSelection<Prisma.$BarAnalyticsPayload>
/**
 * Model SearchQuery
 * 
 */
export type SearchQuery = $Result.DefaultSelection<Prisma.$SearchQueryPayload>
/**
 * Model BarClick
 * 
 */
export type BarClick = $Result.DefaultSelection<Prisma.$BarClickPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model BarBadge
 * 
 */
export type BarBadge = $Result.DefaultSelection<Prisma.$BarBadgePayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryImport
 * 
 */
export type InventoryImport = $Result.DefaultSelection<Prisma.$InventoryImportPayload>
/**
 * Model ShiftUsage
 * 
 */
export type ShiftUsage = $Result.DefaultSelection<Prisma.$ShiftUsagePayload>
/**
 * Model ShiftUsageItem
 * 
 */
export type ShiftUsageItem = $Result.DefaultSelection<Prisma.$ShiftUsageItemPayload>
/**
 * Model InventorySnapshot
 * 
 */
export type InventorySnapshot = $Result.DefaultSelection<Prisma.$InventorySnapshotPayload>
/**
 * Model InventorySnapshotItem
 * 
 */
export type InventorySnapshotItem = $Result.DefaultSelection<Prisma.$InventorySnapshotItemPayload>
/**
 * Model BottlePhoto
 * 
 */
export type BottlePhoto = $Result.DefaultSelection<Prisma.$BottlePhotoPayload>
/**
 * Model CostingProfile
 * 
 */
export type CostingProfile = $Result.DefaultSelection<Prisma.$CostingProfilePayload>
/**
 * Model VarianceAlert
 * 
 */
export type VarianceAlert = $Result.DefaultSelection<Prisma.$VarianceAlertPayload>
/**
 * Model BarLicense
 * 
 */
export type BarLicense = $Result.DefaultSelection<Prisma.$BarLicensePayload>
/**
 * Model BarVisit
 * 
 */
export type BarVisit = $Result.DefaultSelection<Prisma.$BarVisitPayload>
/**
 * Model BarMembership
 * 
 */
export type BarMembership = $Result.DefaultSelection<Prisma.$BarMembershipPayload>
/**
 * Model PatronSearchEvent
 * 
 */
export type PatronSearchEvent = $Result.DefaultSelection<Prisma.$PatronSearchEventPayload>
/**
 * Model BarAction
 * 
 */
export type BarAction = $Result.DefaultSelection<Prisma.$BarActionPayload>
/**
 * Model BarFollower
 * 
 */
export type BarFollower = $Result.DefaultSelection<Prisma.$BarFollowerPayload>
/**
 * Model Boost
 * 
 */
export type Boost = $Result.DefaultSelection<Prisma.$BoostPayload>
/**
 * Model BoostMetric
 * 
 */
export type BoostMetric = $Result.DefaultSelection<Prisma.$BoostMetricPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model BarProduct
 * 
 */
export type BarProduct = $Result.DefaultSelection<Prisma.$BarProductPayload>
/**
 * Model InventoryScanSession
 * 
 */
export type InventoryScanSession = $Result.DefaultSelection<Prisma.$InventoryScanSessionPayload>
/**
 * Model InventoryScanDetection
 * 
 */
export type InventoryScanDetection = $Result.DefaultSelection<Prisma.$InventoryScanDetectionPayload>
/**
 * Model InventoryCount
 * 
 */
export type InventoryCount = $Result.DefaultSelection<Prisma.$InventoryCountPayload>
/**
 * Model AdminAudit
 * 
 */
export type AdminAudit = $Result.DefaultSelection<Prisma.$AdminAuditPayload>
/**
 * Model AdminNote
 * 
 */
export type AdminNote = $Result.DefaultSelection<Prisma.$AdminNotePayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model StaticOffering
 * 
 */
export type StaticOffering = $Result.DefaultSelection<Prisma.$StaticOfferingPayload>
/**
 * Model DrinkSpecial
 * 
 */
export type DrinkSpecial = $Result.DefaultSelection<Prisma.$DrinkSpecialPayload>
/**
 * Model FoodOffering
 * 
 */
export type FoodOffering = $Result.DefaultSelection<Prisma.$FoodOfferingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  PATRON: 'PATRON',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OwnerRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN'
};

export type OwnerRole = (typeof OwnerRole)[keyof typeof OwnerRole]


export const SubscriptionPlan: {
  MONTHLY: 'MONTHLY',
  SIX_MONTH: 'SIX_MONTH',
  YEARLY: 'YEARLY'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  INCOMPLETE: 'INCOMPLETE',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  PAUSED: 'PAUSED',
  TRIALING: 'TRIALING'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const Recurrence: {
  ONE_TIME: 'ONE_TIME',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type Recurrence = (typeof Recurrence)[keyof typeof Recurrence]


export const CategoryRequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type CategoryRequestStatus = (typeof CategoryRequestStatus)[keyof typeof CategoryRequestStatus]


export const BadgeTier: {
  BRONZE: 'BRONZE',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type BadgeTier = (typeof BadgeTier)[keyof typeof BadgeTier]


export const BadgeCategory: {
  FOUNDING: 'FOUNDING',
  ENGAGEMENT: 'ENGAGEMENT',
  CONTENT: 'CONTENT',
  PATRON_LOVE: 'PATRON_LOVE',
  ACHIEVEMENT: 'ACHIEVEMENT',
  COMMUNITY: 'COMMUNITY',
  SEASONAL: 'SEASONAL'
};

export type BadgeCategory = (typeof BadgeCategory)[keyof typeof BadgeCategory]


export const SubscriptionTier: {
  FREE: 'FREE',
  PRO: 'PRO',
  PREMIUM: 'PREMIUM'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const BarMemberRole: {
  OWNER: 'OWNER',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF'
};

export type BarMemberRole = (typeof BarMemberRole)[keyof typeof BarMemberRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OwnerRole = $Enums.OwnerRole

export const OwnerRole: typeof $Enums.OwnerRole

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type Recurrence = $Enums.Recurrence

export const Recurrence: typeof $Enums.Recurrence

export type CategoryRequestStatus = $Enums.CategoryRequestStatus

export const CategoryRequestStatus: typeof $Enums.CategoryRequestStatus

export type BadgeTier = $Enums.BadgeTier

export const BadgeTier: typeof $Enums.BadgeTier

export type BadgeCategory = $Enums.BadgeCategory

export const BadgeCategory: typeof $Enums.BadgeCategory

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type BarMemberRole = $Enums.BarMemberRole

export const BarMemberRole: typeof $Enums.BarMemberRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): Prisma.OwnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bar`: Exposes CRUD operations for the **Bar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bars
    * const bars = await prisma.bar.findMany()
    * ```
    */
  get bar(): Prisma.BarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offering`: Exposes CRUD operations for the **Offering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offerings
    * const offerings = await prisma.offering.findMany()
    * ```
    */
  get offering(): Prisma.OfferingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityCategory`: Exposes CRUD operations for the **ActivityCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityCategories
    * const activityCategories = await prisma.activityCategory.findMany()
    * ```
    */
  get activityCategory(): Prisma.ActivityCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoryRequest`: Exposes CRUD operations for the **CategoryRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryRequests
    * const categoryRequests = await prisma.categoryRequest.findMany()
    * ```
    */
  get categoryRequest(): Prisma.CategoryRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownerPasswordReset`: Exposes CRUD operations for the **OwnerPasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerPasswordResets
    * const ownerPasswordResets = await prisma.ownerPasswordReset.findMany()
    * ```
    */
  get ownerPasswordReset(): Prisma.OwnerPasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoRedemption`: Exposes CRUD operations for the **PromoRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoRedemptions
    * const promoRedemptions = await prisma.promoRedemption.findMany()
    * ```
    */
  get promoRedemption(): Prisma.PromoRedemptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barAnalytics`: Exposes CRUD operations for the **BarAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarAnalytics
    * const barAnalytics = await prisma.barAnalytics.findMany()
    * ```
    */
  get barAnalytics(): Prisma.BarAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchQuery`: Exposes CRUD operations for the **SearchQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchQueries
    * const searchQueries = await prisma.searchQuery.findMany()
    * ```
    */
  get searchQuery(): Prisma.SearchQueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barClick`: Exposes CRUD operations for the **BarClick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarClicks
    * const barClicks = await prisma.barClick.findMany()
    * ```
    */
  get barClick(): Prisma.BarClickDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barBadge`: Exposes CRUD operations for the **BarBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarBadges
    * const barBadges = await prisma.barBadge.findMany()
    * ```
    */
  get barBadge(): Prisma.BarBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryImport`: Exposes CRUD operations for the **InventoryImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryImports
    * const inventoryImports = await prisma.inventoryImport.findMany()
    * ```
    */
  get inventoryImport(): Prisma.InventoryImportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftUsage`: Exposes CRUD operations for the **ShiftUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftUsages
    * const shiftUsages = await prisma.shiftUsage.findMany()
    * ```
    */
  get shiftUsage(): Prisma.ShiftUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftUsageItem`: Exposes CRUD operations for the **ShiftUsageItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftUsageItems
    * const shiftUsageItems = await prisma.shiftUsageItem.findMany()
    * ```
    */
  get shiftUsageItem(): Prisma.ShiftUsageItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventorySnapshot`: Exposes CRUD operations for the **InventorySnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventorySnapshots
    * const inventorySnapshots = await prisma.inventorySnapshot.findMany()
    * ```
    */
  get inventorySnapshot(): Prisma.InventorySnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventorySnapshotItem`: Exposes CRUD operations for the **InventorySnapshotItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventorySnapshotItems
    * const inventorySnapshotItems = await prisma.inventorySnapshotItem.findMany()
    * ```
    */
  get inventorySnapshotItem(): Prisma.InventorySnapshotItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bottlePhoto`: Exposes CRUD operations for the **BottlePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BottlePhotos
    * const bottlePhotos = await prisma.bottlePhoto.findMany()
    * ```
    */
  get bottlePhoto(): Prisma.BottlePhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costingProfile`: Exposes CRUD operations for the **CostingProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostingProfiles
    * const costingProfiles = await prisma.costingProfile.findMany()
    * ```
    */
  get costingProfile(): Prisma.CostingProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.varianceAlert`: Exposes CRUD operations for the **VarianceAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VarianceAlerts
    * const varianceAlerts = await prisma.varianceAlert.findMany()
    * ```
    */
  get varianceAlert(): Prisma.VarianceAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barLicense`: Exposes CRUD operations for the **BarLicense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarLicenses
    * const barLicenses = await prisma.barLicense.findMany()
    * ```
    */
  get barLicense(): Prisma.BarLicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barVisit`: Exposes CRUD operations for the **BarVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarVisits
    * const barVisits = await prisma.barVisit.findMany()
    * ```
    */
  get barVisit(): Prisma.BarVisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barMembership`: Exposes CRUD operations for the **BarMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarMemberships
    * const barMemberships = await prisma.barMembership.findMany()
    * ```
    */
  get barMembership(): Prisma.BarMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patronSearchEvent`: Exposes CRUD operations for the **PatronSearchEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatronSearchEvents
    * const patronSearchEvents = await prisma.patronSearchEvent.findMany()
    * ```
    */
  get patronSearchEvent(): Prisma.PatronSearchEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barAction`: Exposes CRUD operations for the **BarAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarActions
    * const barActions = await prisma.barAction.findMany()
    * ```
    */
  get barAction(): Prisma.BarActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barFollower`: Exposes CRUD operations for the **BarFollower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarFollowers
    * const barFollowers = await prisma.barFollower.findMany()
    * ```
    */
  get barFollower(): Prisma.BarFollowerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boost`: Exposes CRUD operations for the **Boost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boosts
    * const boosts = await prisma.boost.findMany()
    * ```
    */
  get boost(): Prisma.BoostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boostMetric`: Exposes CRUD operations for the **BoostMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoostMetrics
    * const boostMetrics = await prisma.boostMetric.findMany()
    * ```
    */
  get boostMetric(): Prisma.BoostMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barProduct`: Exposes CRUD operations for the **BarProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarProducts
    * const barProducts = await prisma.barProduct.findMany()
    * ```
    */
  get barProduct(): Prisma.BarProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryScanSession`: Exposes CRUD operations for the **InventoryScanSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryScanSessions
    * const inventoryScanSessions = await prisma.inventoryScanSession.findMany()
    * ```
    */
  get inventoryScanSession(): Prisma.InventoryScanSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryScanDetection`: Exposes CRUD operations for the **InventoryScanDetection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryScanDetections
    * const inventoryScanDetections = await prisma.inventoryScanDetection.findMany()
    * ```
    */
  get inventoryScanDetection(): Prisma.InventoryScanDetectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryCount`: Exposes CRUD operations for the **InventoryCount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryCounts
    * const inventoryCounts = await prisma.inventoryCount.findMany()
    * ```
    */
  get inventoryCount(): Prisma.InventoryCountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAudit`: Exposes CRUD operations for the **AdminAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAudits
    * const adminAudits = await prisma.adminAudit.findMany()
    * ```
    */
  get adminAudit(): Prisma.AdminAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminNote`: Exposes CRUD operations for the **AdminNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminNotes
    * const adminNotes = await prisma.adminNote.findMany()
    * ```
    */
  get adminNote(): Prisma.AdminNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staticOffering`: Exposes CRUD operations for the **StaticOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaticOfferings
    * const staticOfferings = await prisma.staticOffering.findMany()
    * ```
    */
  get staticOffering(): Prisma.StaticOfferingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drinkSpecial`: Exposes CRUD operations for the **DrinkSpecial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DrinkSpecials
    * const drinkSpecials = await prisma.drinkSpecial.findMany()
    * ```
    */
  get drinkSpecial(): Prisma.DrinkSpecialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodOffering`: Exposes CRUD operations for the **FoodOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodOfferings
    * const foodOfferings = await prisma.foodOffering.findMany()
    * ```
    */
  get foodOffering(): Prisma.FoodOfferingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Owner: 'Owner',
    Subscription: 'Subscription',
    Bar: 'Bar',
    Offering: 'Offering',
    Event: 'Event',
    Favorite: 'Favorite',
    ActivityCategory: 'ActivityCategory',
    CategoryRequest: 'CategoryRequest',
    OwnerPasswordReset: 'OwnerPasswordReset',
    PromoCode: 'PromoCode',
    PromoRedemption: 'PromoRedemption',
    BarAnalytics: 'BarAnalytics',
    SearchQuery: 'SearchQuery',
    BarClick: 'BarClick',
    Badge: 'Badge',
    BarBadge: 'BarBadge',
    InventoryItem: 'InventoryItem',
    InventoryImport: 'InventoryImport',
    ShiftUsage: 'ShiftUsage',
    ShiftUsageItem: 'ShiftUsageItem',
    InventorySnapshot: 'InventorySnapshot',
    InventorySnapshotItem: 'InventorySnapshotItem',
    BottlePhoto: 'BottlePhoto',
    CostingProfile: 'CostingProfile',
    VarianceAlert: 'VarianceAlert',
    BarLicense: 'BarLicense',
    BarVisit: 'BarVisit',
    BarMembership: 'BarMembership',
    PatronSearchEvent: 'PatronSearchEvent',
    BarAction: 'BarAction',
    BarFollower: 'BarFollower',
    Boost: 'Boost',
    BoostMetric: 'BoostMetric',
    Product: 'Product',
    BarProduct: 'BarProduct',
    InventoryScanSession: 'InventoryScanSession',
    InventoryScanDetection: 'InventoryScanDetection',
    InventoryCount: 'InventoryCount',
    AdminAudit: 'AdminAudit',
    AdminNote: 'AdminNote',
    SupportTicket: 'SupportTicket',
    StaticOffering: 'StaticOffering',
    DrinkSpecial: 'DrinkSpecial',
    FoodOffering: 'FoodOffering'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "owner" | "subscription" | "bar" | "offering" | "event" | "favorite" | "activityCategory" | "categoryRequest" | "ownerPasswordReset" | "promoCode" | "promoRedemption" | "barAnalytics" | "searchQuery" | "barClick" | "badge" | "barBadge" | "inventoryItem" | "inventoryImport" | "shiftUsage" | "shiftUsageItem" | "inventorySnapshot" | "inventorySnapshotItem" | "bottlePhoto" | "costingProfile" | "varianceAlert" | "barLicense" | "barVisit" | "barMembership" | "patronSearchEvent" | "barAction" | "barFollower" | "boost" | "boostMetric" | "product" | "barProduct" | "inventoryScanSession" | "inventoryScanDetection" | "inventoryCount" | "adminAudit" | "adminNote" | "supportTicket" | "staticOffering" | "drinkSpecial" | "foodOffering"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Owner: {
        payload: Prisma.$OwnerPayload<ExtArgs>
        fields: Prisma.OwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findFirst: {
            args: Prisma.OwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findMany: {
            args: Prisma.OwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          create: {
            args: Prisma.OwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          createMany: {
            args: Prisma.OwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          delete: {
            args: Prisma.OwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          update: {
            args: Prisma.OwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          upsert: {
            args: Prisma.OwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          aggregate: {
            args: Prisma.OwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwner>
          }
          groupBy: {
            args: Prisma.OwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Bar: {
        payload: Prisma.$BarPayload<ExtArgs>
        fields: Prisma.BarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>
          }
          findFirst: {
            args: Prisma.BarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>
          }
          findMany: {
            args: Prisma.BarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>[]
          }
          create: {
            args: Prisma.BarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>
          }
          createMany: {
            args: Prisma.BarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>[]
          }
          delete: {
            args: Prisma.BarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>
          }
          update: {
            args: Prisma.BarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>
          }
          deleteMany: {
            args: Prisma.BarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>[]
          }
          upsert: {
            args: Prisma.BarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarPayload>
          }
          aggregate: {
            args: Prisma.BarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBar>
          }
          groupBy: {
            args: Prisma.BarGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarCountArgs<ExtArgs>
            result: $Utils.Optional<BarCountAggregateOutputType> | number
          }
        }
      }
      Offering: {
        payload: Prisma.$OfferingPayload<ExtArgs>
        fields: Prisma.OfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>
          }
          findFirst: {
            args: Prisma.OfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>
          }
          findMany: {
            args: Prisma.OfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>[]
          }
          create: {
            args: Prisma.OfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>
          }
          createMany: {
            args: Prisma.OfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>[]
          }
          delete: {
            args: Prisma.OfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>
          }
          update: {
            args: Prisma.OfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>
          }
          deleteMany: {
            args: Prisma.OfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>[]
          }
          upsert: {
            args: Prisma.OfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferingPayload>
          }
          aggregate: {
            args: Prisma.OfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffering>
          }
          groupBy: {
            args: Prisma.OfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferingCountArgs<ExtArgs>
            result: $Utils.Optional<OfferingCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      ActivityCategory: {
        payload: Prisma.$ActivityCategoryPayload<ExtArgs>
        fields: Prisma.ActivityCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          findFirst: {
            args: Prisma.ActivityCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          findMany: {
            args: Prisma.ActivityCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>[]
          }
          create: {
            args: Prisma.ActivityCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          createMany: {
            args: Prisma.ActivityCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>[]
          }
          delete: {
            args: Prisma.ActivityCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          update: {
            args: Prisma.ActivityCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ActivityCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ActivityCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityCategoryPayload>
          }
          aggregate: {
            args: Prisma.ActivityCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityCategory>
          }
          groupBy: {
            args: Prisma.ActivityCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCategoryCountAggregateOutputType> | number
          }
        }
      }
      CategoryRequest: {
        payload: Prisma.$CategoryRequestPayload<ExtArgs>
        fields: Prisma.CategoryRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>
          }
          findFirst: {
            args: Prisma.CategoryRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>
          }
          findMany: {
            args: Prisma.CategoryRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>[]
          }
          create: {
            args: Prisma.CategoryRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>
          }
          createMany: {
            args: Prisma.CategoryRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>[]
          }
          delete: {
            args: Prisma.CategoryRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>
          }
          update: {
            args: Prisma.CategoryRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>
          }
          deleteMany: {
            args: Prisma.CategoryRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>[]
          }
          upsert: {
            args: Prisma.CategoryRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryRequestPayload>
          }
          aggregate: {
            args: Prisma.CategoryRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryRequest>
          }
          groupBy: {
            args: Prisma.CategoryRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryRequestCountAggregateOutputType> | number
          }
        }
      }
      OwnerPasswordReset: {
        payload: Prisma.$OwnerPasswordResetPayload<ExtArgs>
        fields: Prisma.OwnerPasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerPasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerPasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>
          }
          findFirst: {
            args: Prisma.OwnerPasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerPasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>
          }
          findMany: {
            args: Prisma.OwnerPasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>[]
          }
          create: {
            args: Prisma.OwnerPasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>
          }
          createMany: {
            args: Prisma.OwnerPasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerPasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>[]
          }
          delete: {
            args: Prisma.OwnerPasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>
          }
          update: {
            args: Prisma.OwnerPasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.OwnerPasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerPasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerPasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.OwnerPasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPasswordResetPayload>
          }
          aggregate: {
            args: Prisma.OwnerPasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerPasswordReset>
          }
          groupBy: {
            args: Prisma.OwnerPasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerPasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerPasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerPasswordResetCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      PromoRedemption: {
        payload: Prisma.$PromoRedemptionPayload<ExtArgs>
        fields: Prisma.PromoRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>
          }
          findFirst: {
            args: Prisma.PromoRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>
          }
          findMany: {
            args: Prisma.PromoRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>[]
          }
          create: {
            args: Prisma.PromoRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>
          }
          createMany: {
            args: Prisma.PromoRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>[]
          }
          delete: {
            args: Prisma.PromoRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>
          }
          update: {
            args: Prisma.PromoRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.PromoRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoRedemptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>[]
          }
          upsert: {
            args: Prisma.PromoRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoRedemptionPayload>
          }
          aggregate: {
            args: Prisma.PromoRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoRedemption>
          }
          groupBy: {
            args: Prisma.PromoRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<PromoRedemptionCountAggregateOutputType> | number
          }
        }
      }
      BarAnalytics: {
        payload: Prisma.$BarAnalyticsPayload<ExtArgs>
        fields: Prisma.BarAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.BarAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>
          }
          findMany: {
            args: Prisma.BarAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>[]
          }
          create: {
            args: Prisma.BarAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>
          }
          createMany: {
            args: Prisma.BarAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.BarAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>
          }
          update: {
            args: Prisma.BarAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.BarAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.BarAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.BarAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarAnalytics>
          }
          groupBy: {
            args: Prisma.BarAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<BarAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      SearchQuery: {
        payload: Prisma.$SearchQueryPayload<ExtArgs>
        fields: Prisma.SearchQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findFirst: {
            args: Prisma.SearchQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findMany: {
            args: Prisma.SearchQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          create: {
            args: Prisma.SearchQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          createMany: {
            args: Prisma.SearchQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          delete: {
            args: Prisma.SearchQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          update: {
            args: Prisma.SearchQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          deleteMany: {
            args: Prisma.SearchQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchQueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          upsert: {
            args: Prisma.SearchQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          aggregate: {
            args: Prisma.SearchQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchQuery>
          }
          groupBy: {
            args: Prisma.SearchQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryCountAggregateOutputType> | number
          }
        }
      }
      BarClick: {
        payload: Prisma.$BarClickPayload<ExtArgs>
        fields: Prisma.BarClickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarClickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarClickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>
          }
          findFirst: {
            args: Prisma.BarClickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarClickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>
          }
          findMany: {
            args: Prisma.BarClickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>[]
          }
          create: {
            args: Prisma.BarClickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>
          }
          createMany: {
            args: Prisma.BarClickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarClickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>[]
          }
          delete: {
            args: Prisma.BarClickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>
          }
          update: {
            args: Prisma.BarClickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>
          }
          deleteMany: {
            args: Prisma.BarClickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarClickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarClickUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>[]
          }
          upsert: {
            args: Prisma.BarClickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarClickPayload>
          }
          aggregate: {
            args: Prisma.BarClickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarClick>
          }
          groupBy: {
            args: Prisma.BarClickGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarClickGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarClickCountArgs<ExtArgs>
            result: $Utils.Optional<BarClickCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      BarBadge: {
        payload: Prisma.$BarBadgePayload<ExtArgs>
        fields: Prisma.BarBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>
          }
          findFirst: {
            args: Prisma.BarBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>
          }
          findMany: {
            args: Prisma.BarBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>[]
          }
          create: {
            args: Prisma.BarBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>
          }
          createMany: {
            args: Prisma.BarBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>[]
          }
          delete: {
            args: Prisma.BarBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>
          }
          update: {
            args: Prisma.BarBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>
          }
          deleteMany: {
            args: Prisma.BarBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>[]
          }
          upsert: {
            args: Prisma.BarBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarBadgePayload>
          }
          aggregate: {
            args: Prisma.BarBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarBadge>
          }
          groupBy: {
            args: Prisma.BarBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BarBadgeCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryImport: {
        payload: Prisma.$InventoryImportPayload<ExtArgs>
        fields: Prisma.InventoryImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>
          }
          findFirst: {
            args: Prisma.InventoryImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>
          }
          findMany: {
            args: Prisma.InventoryImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>[]
          }
          create: {
            args: Prisma.InventoryImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>
          }
          createMany: {
            args: Prisma.InventoryImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryImportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>[]
          }
          delete: {
            args: Prisma.InventoryImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>
          }
          update: {
            args: Prisma.InventoryImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>
          }
          deleteMany: {
            args: Prisma.InventoryImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryImportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>[]
          }
          upsert: {
            args: Prisma.InventoryImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryImportPayload>
          }
          aggregate: {
            args: Prisma.InventoryImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryImport>
          }
          groupBy: {
            args: Prisma.InventoryImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryImportCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryImportCountAggregateOutputType> | number
          }
        }
      }
      ShiftUsage: {
        payload: Prisma.$ShiftUsagePayload<ExtArgs>
        fields: Prisma.ShiftUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>
          }
          findFirst: {
            args: Prisma.ShiftUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>
          }
          findMany: {
            args: Prisma.ShiftUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>[]
          }
          create: {
            args: Prisma.ShiftUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>
          }
          createMany: {
            args: Prisma.ShiftUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>[]
          }
          delete: {
            args: Prisma.ShiftUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>
          }
          update: {
            args: Prisma.ShiftUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>
          }
          deleteMany: {
            args: Prisma.ShiftUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>[]
          }
          upsert: {
            args: Prisma.ShiftUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsagePayload>
          }
          aggregate: {
            args: Prisma.ShiftUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftUsage>
          }
          groupBy: {
            args: Prisma.ShiftUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftUsageCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftUsageCountAggregateOutputType> | number
          }
        }
      }
      ShiftUsageItem: {
        payload: Prisma.$ShiftUsageItemPayload<ExtArgs>
        fields: Prisma.ShiftUsageItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftUsageItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftUsageItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>
          }
          findFirst: {
            args: Prisma.ShiftUsageItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftUsageItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>
          }
          findMany: {
            args: Prisma.ShiftUsageItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>[]
          }
          create: {
            args: Prisma.ShiftUsageItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>
          }
          createMany: {
            args: Prisma.ShiftUsageItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftUsageItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>[]
          }
          delete: {
            args: Prisma.ShiftUsageItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>
          }
          update: {
            args: Prisma.ShiftUsageItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>
          }
          deleteMany: {
            args: Prisma.ShiftUsageItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUsageItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUsageItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUsageItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftUsageItemPayload>
          }
          aggregate: {
            args: Prisma.ShiftUsageItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftUsageItem>
          }
          groupBy: {
            args: Prisma.ShiftUsageItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftUsageItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftUsageItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftUsageItemCountAggregateOutputType> | number
          }
        }
      }
      InventorySnapshot: {
        payload: Prisma.$InventorySnapshotPayload<ExtArgs>
        fields: Prisma.InventorySnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventorySnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventorySnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>
          }
          findFirst: {
            args: Prisma.InventorySnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventorySnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>
          }
          findMany: {
            args: Prisma.InventorySnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>[]
          }
          create: {
            args: Prisma.InventorySnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>
          }
          createMany: {
            args: Prisma.InventorySnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventorySnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>[]
          }
          delete: {
            args: Prisma.InventorySnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>
          }
          update: {
            args: Prisma.InventorySnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>
          }
          deleteMany: {
            args: Prisma.InventorySnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventorySnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventorySnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>[]
          }
          upsert: {
            args: Prisma.InventorySnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotPayload>
          }
          aggregate: {
            args: Prisma.InventorySnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventorySnapshot>
          }
          groupBy: {
            args: Prisma.InventorySnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventorySnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventorySnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<InventorySnapshotCountAggregateOutputType> | number
          }
        }
      }
      InventorySnapshotItem: {
        payload: Prisma.$InventorySnapshotItemPayload<ExtArgs>
        fields: Prisma.InventorySnapshotItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventorySnapshotItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventorySnapshotItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>
          }
          findFirst: {
            args: Prisma.InventorySnapshotItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventorySnapshotItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>
          }
          findMany: {
            args: Prisma.InventorySnapshotItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>[]
          }
          create: {
            args: Prisma.InventorySnapshotItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>
          }
          createMany: {
            args: Prisma.InventorySnapshotItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventorySnapshotItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>[]
          }
          delete: {
            args: Prisma.InventorySnapshotItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>
          }
          update: {
            args: Prisma.InventorySnapshotItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>
          }
          deleteMany: {
            args: Prisma.InventorySnapshotItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventorySnapshotItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventorySnapshotItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>[]
          }
          upsert: {
            args: Prisma.InventorySnapshotItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySnapshotItemPayload>
          }
          aggregate: {
            args: Prisma.InventorySnapshotItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventorySnapshotItem>
          }
          groupBy: {
            args: Prisma.InventorySnapshotItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventorySnapshotItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventorySnapshotItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventorySnapshotItemCountAggregateOutputType> | number
          }
        }
      }
      BottlePhoto: {
        payload: Prisma.$BottlePhotoPayload<ExtArgs>
        fields: Prisma.BottlePhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BottlePhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BottlePhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>
          }
          findFirst: {
            args: Prisma.BottlePhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BottlePhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>
          }
          findMany: {
            args: Prisma.BottlePhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>[]
          }
          create: {
            args: Prisma.BottlePhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>
          }
          createMany: {
            args: Prisma.BottlePhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BottlePhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>[]
          }
          delete: {
            args: Prisma.BottlePhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>
          }
          update: {
            args: Prisma.BottlePhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>
          }
          deleteMany: {
            args: Prisma.BottlePhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BottlePhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BottlePhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>[]
          }
          upsert: {
            args: Prisma.BottlePhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BottlePhotoPayload>
          }
          aggregate: {
            args: Prisma.BottlePhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBottlePhoto>
          }
          groupBy: {
            args: Prisma.BottlePhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BottlePhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BottlePhotoCountArgs<ExtArgs>
            result: $Utils.Optional<BottlePhotoCountAggregateOutputType> | number
          }
        }
      }
      CostingProfile: {
        payload: Prisma.$CostingProfilePayload<ExtArgs>
        fields: Prisma.CostingProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostingProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostingProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>
          }
          findFirst: {
            args: Prisma.CostingProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostingProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>
          }
          findMany: {
            args: Prisma.CostingProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>[]
          }
          create: {
            args: Prisma.CostingProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>
          }
          createMany: {
            args: Prisma.CostingProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostingProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>[]
          }
          delete: {
            args: Prisma.CostingProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>
          }
          update: {
            args: Prisma.CostingProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>
          }
          deleteMany: {
            args: Prisma.CostingProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostingProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostingProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>[]
          }
          upsert: {
            args: Prisma.CostingProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostingProfilePayload>
          }
          aggregate: {
            args: Prisma.CostingProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostingProfile>
          }
          groupBy: {
            args: Prisma.CostingProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostingProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostingProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CostingProfileCountAggregateOutputType> | number
          }
        }
      }
      VarianceAlert: {
        payload: Prisma.$VarianceAlertPayload<ExtArgs>
        fields: Prisma.VarianceAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VarianceAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VarianceAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>
          }
          findFirst: {
            args: Prisma.VarianceAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VarianceAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>
          }
          findMany: {
            args: Prisma.VarianceAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>[]
          }
          create: {
            args: Prisma.VarianceAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>
          }
          createMany: {
            args: Prisma.VarianceAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VarianceAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>[]
          }
          delete: {
            args: Prisma.VarianceAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>
          }
          update: {
            args: Prisma.VarianceAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>
          }
          deleteMany: {
            args: Prisma.VarianceAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VarianceAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VarianceAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>[]
          }
          upsert: {
            args: Prisma.VarianceAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianceAlertPayload>
          }
          aggregate: {
            args: Prisma.VarianceAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVarianceAlert>
          }
          groupBy: {
            args: Prisma.VarianceAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<VarianceAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.VarianceAlertCountArgs<ExtArgs>
            result: $Utils.Optional<VarianceAlertCountAggregateOutputType> | number
          }
        }
      }
      BarLicense: {
        payload: Prisma.$BarLicensePayload<ExtArgs>
        fields: Prisma.BarLicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarLicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarLicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>
          }
          findFirst: {
            args: Prisma.BarLicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarLicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>
          }
          findMany: {
            args: Prisma.BarLicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>[]
          }
          create: {
            args: Prisma.BarLicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>
          }
          createMany: {
            args: Prisma.BarLicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarLicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>[]
          }
          delete: {
            args: Prisma.BarLicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>
          }
          update: {
            args: Prisma.BarLicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>
          }
          deleteMany: {
            args: Prisma.BarLicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarLicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarLicenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>[]
          }
          upsert: {
            args: Prisma.BarLicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarLicensePayload>
          }
          aggregate: {
            args: Prisma.BarLicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarLicense>
          }
          groupBy: {
            args: Prisma.BarLicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarLicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarLicenseCountArgs<ExtArgs>
            result: $Utils.Optional<BarLicenseCountAggregateOutputType> | number
          }
        }
      }
      BarVisit: {
        payload: Prisma.$BarVisitPayload<ExtArgs>
        fields: Prisma.BarVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>
          }
          findFirst: {
            args: Prisma.BarVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>
          }
          findMany: {
            args: Prisma.BarVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>[]
          }
          create: {
            args: Prisma.BarVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>
          }
          createMany: {
            args: Prisma.BarVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarVisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>[]
          }
          delete: {
            args: Prisma.BarVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>
          }
          update: {
            args: Prisma.BarVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>
          }
          deleteMany: {
            args: Prisma.BarVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarVisitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>[]
          }
          upsert: {
            args: Prisma.BarVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarVisitPayload>
          }
          aggregate: {
            args: Prisma.BarVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarVisit>
          }
          groupBy: {
            args: Prisma.BarVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarVisitCountArgs<ExtArgs>
            result: $Utils.Optional<BarVisitCountAggregateOutputType> | number
          }
        }
      }
      BarMembership: {
        payload: Prisma.$BarMembershipPayload<ExtArgs>
        fields: Prisma.BarMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>
          }
          findFirst: {
            args: Prisma.BarMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>
          }
          findMany: {
            args: Prisma.BarMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>[]
          }
          create: {
            args: Prisma.BarMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>
          }
          createMany: {
            args: Prisma.BarMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>[]
          }
          delete: {
            args: Prisma.BarMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>
          }
          update: {
            args: Prisma.BarMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>
          }
          deleteMany: {
            args: Prisma.BarMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>[]
          }
          upsert: {
            args: Prisma.BarMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarMembershipPayload>
          }
          aggregate: {
            args: Prisma.BarMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarMembership>
          }
          groupBy: {
            args: Prisma.BarMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<BarMembershipCountAggregateOutputType> | number
          }
        }
      }
      PatronSearchEvent: {
        payload: Prisma.$PatronSearchEventPayload<ExtArgs>
        fields: Prisma.PatronSearchEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatronSearchEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatronSearchEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>
          }
          findFirst: {
            args: Prisma.PatronSearchEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatronSearchEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>
          }
          findMany: {
            args: Prisma.PatronSearchEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>[]
          }
          create: {
            args: Prisma.PatronSearchEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>
          }
          createMany: {
            args: Prisma.PatronSearchEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatronSearchEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>[]
          }
          delete: {
            args: Prisma.PatronSearchEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>
          }
          update: {
            args: Prisma.PatronSearchEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>
          }
          deleteMany: {
            args: Prisma.PatronSearchEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatronSearchEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatronSearchEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>[]
          }
          upsert: {
            args: Prisma.PatronSearchEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatronSearchEventPayload>
          }
          aggregate: {
            args: Prisma.PatronSearchEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatronSearchEvent>
          }
          groupBy: {
            args: Prisma.PatronSearchEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatronSearchEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatronSearchEventCountArgs<ExtArgs>
            result: $Utils.Optional<PatronSearchEventCountAggregateOutputType> | number
          }
        }
      }
      BarAction: {
        payload: Prisma.$BarActionPayload<ExtArgs>
        fields: Prisma.BarActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>
          }
          findFirst: {
            args: Prisma.BarActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>
          }
          findMany: {
            args: Prisma.BarActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>[]
          }
          create: {
            args: Prisma.BarActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>
          }
          createMany: {
            args: Prisma.BarActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>[]
          }
          delete: {
            args: Prisma.BarActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>
          }
          update: {
            args: Prisma.BarActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>
          }
          deleteMany: {
            args: Prisma.BarActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>[]
          }
          upsert: {
            args: Prisma.BarActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarActionPayload>
          }
          aggregate: {
            args: Prisma.BarActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarAction>
          }
          groupBy: {
            args: Prisma.BarActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarActionCountArgs<ExtArgs>
            result: $Utils.Optional<BarActionCountAggregateOutputType> | number
          }
        }
      }
      BarFollower: {
        payload: Prisma.$BarFollowerPayload<ExtArgs>
        fields: Prisma.BarFollowerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarFollowerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarFollowerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>
          }
          findFirst: {
            args: Prisma.BarFollowerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarFollowerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>
          }
          findMany: {
            args: Prisma.BarFollowerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>[]
          }
          create: {
            args: Prisma.BarFollowerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>
          }
          createMany: {
            args: Prisma.BarFollowerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarFollowerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>[]
          }
          delete: {
            args: Prisma.BarFollowerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>
          }
          update: {
            args: Prisma.BarFollowerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>
          }
          deleteMany: {
            args: Prisma.BarFollowerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarFollowerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarFollowerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>[]
          }
          upsert: {
            args: Prisma.BarFollowerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarFollowerPayload>
          }
          aggregate: {
            args: Prisma.BarFollowerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarFollower>
          }
          groupBy: {
            args: Prisma.BarFollowerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarFollowerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarFollowerCountArgs<ExtArgs>
            result: $Utils.Optional<BarFollowerCountAggregateOutputType> | number
          }
        }
      }
      Boost: {
        payload: Prisma.$BoostPayload<ExtArgs>
        fields: Prisma.BoostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>
          }
          findFirst: {
            args: Prisma.BoostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>
          }
          findMany: {
            args: Prisma.BoostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>[]
          }
          create: {
            args: Prisma.BoostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>
          }
          createMany: {
            args: Prisma.BoostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>[]
          }
          delete: {
            args: Prisma.BoostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>
          }
          update: {
            args: Prisma.BoostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>
          }
          deleteMany: {
            args: Prisma.BoostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>[]
          }
          upsert: {
            args: Prisma.BoostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostPayload>
          }
          aggregate: {
            args: Prisma.BoostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoost>
          }
          groupBy: {
            args: Prisma.BoostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoostCountArgs<ExtArgs>
            result: $Utils.Optional<BoostCountAggregateOutputType> | number
          }
        }
      }
      BoostMetric: {
        payload: Prisma.$BoostMetricPayload<ExtArgs>
        fields: Prisma.BoostMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoostMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoostMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>
          }
          findFirst: {
            args: Prisma.BoostMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoostMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>
          }
          findMany: {
            args: Prisma.BoostMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>[]
          }
          create: {
            args: Prisma.BoostMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>
          }
          createMany: {
            args: Prisma.BoostMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoostMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>[]
          }
          delete: {
            args: Prisma.BoostMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>
          }
          update: {
            args: Prisma.BoostMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>
          }
          deleteMany: {
            args: Prisma.BoostMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoostMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoostMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>[]
          }
          upsert: {
            args: Prisma.BoostMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoostMetricPayload>
          }
          aggregate: {
            args: Prisma.BoostMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoostMetric>
          }
          groupBy: {
            args: Prisma.BoostMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoostMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoostMetricCountArgs<ExtArgs>
            result: $Utils.Optional<BoostMetricCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      BarProduct: {
        payload: Prisma.$BarProductPayload<ExtArgs>
        fields: Prisma.BarProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>
          }
          findFirst: {
            args: Prisma.BarProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>
          }
          findMany: {
            args: Prisma.BarProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>[]
          }
          create: {
            args: Prisma.BarProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>
          }
          createMany: {
            args: Prisma.BarProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>[]
          }
          delete: {
            args: Prisma.BarProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>
          }
          update: {
            args: Prisma.BarProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>
          }
          deleteMany: {
            args: Prisma.BarProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>[]
          }
          upsert: {
            args: Prisma.BarProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarProductPayload>
          }
          aggregate: {
            args: Prisma.BarProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarProduct>
          }
          groupBy: {
            args: Prisma.BarProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarProductCountArgs<ExtArgs>
            result: $Utils.Optional<BarProductCountAggregateOutputType> | number
          }
        }
      }
      InventoryScanSession: {
        payload: Prisma.$InventoryScanSessionPayload<ExtArgs>
        fields: Prisma.InventoryScanSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryScanSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryScanSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>
          }
          findFirst: {
            args: Prisma.InventoryScanSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryScanSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>
          }
          findMany: {
            args: Prisma.InventoryScanSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>[]
          }
          create: {
            args: Prisma.InventoryScanSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>
          }
          createMany: {
            args: Prisma.InventoryScanSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryScanSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>[]
          }
          delete: {
            args: Prisma.InventoryScanSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>
          }
          update: {
            args: Prisma.InventoryScanSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryScanSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryScanSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryScanSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>[]
          }
          upsert: {
            args: Prisma.InventoryScanSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanSessionPayload>
          }
          aggregate: {
            args: Prisma.InventoryScanSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryScanSession>
          }
          groupBy: {
            args: Prisma.InventoryScanSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryScanSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryScanSessionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryScanSessionCountAggregateOutputType> | number
          }
        }
      }
      InventoryScanDetection: {
        payload: Prisma.$InventoryScanDetectionPayload<ExtArgs>
        fields: Prisma.InventoryScanDetectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryScanDetectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryScanDetectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>
          }
          findFirst: {
            args: Prisma.InventoryScanDetectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryScanDetectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>
          }
          findMany: {
            args: Prisma.InventoryScanDetectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>[]
          }
          create: {
            args: Prisma.InventoryScanDetectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>
          }
          createMany: {
            args: Prisma.InventoryScanDetectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryScanDetectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>[]
          }
          delete: {
            args: Prisma.InventoryScanDetectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>
          }
          update: {
            args: Prisma.InventoryScanDetectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryScanDetectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryScanDetectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryScanDetectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>[]
          }
          upsert: {
            args: Prisma.InventoryScanDetectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryScanDetectionPayload>
          }
          aggregate: {
            args: Prisma.InventoryScanDetectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryScanDetection>
          }
          groupBy: {
            args: Prisma.InventoryScanDetectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryScanDetectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryScanDetectionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryScanDetectionCountAggregateOutputType> | number
          }
        }
      }
      InventoryCount: {
        payload: Prisma.$InventoryCountPayload<ExtArgs>
        fields: Prisma.InventoryCountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryCountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryCountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>
          }
          findFirst: {
            args: Prisma.InventoryCountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryCountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>
          }
          findMany: {
            args: Prisma.InventoryCountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>[]
          }
          create: {
            args: Prisma.InventoryCountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>
          }
          createMany: {
            args: Prisma.InventoryCountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>[]
          }
          delete: {
            args: Prisma.InventoryCountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>
          }
          update: {
            args: Prisma.InventoryCountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>
          }
          deleteMany: {
            args: Prisma.InventoryCountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryCountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryCountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>[]
          }
          upsert: {
            args: Prisma.InventoryCountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryCountPayload>
          }
          aggregate: {
            args: Prisma.InventoryCountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryCount>
          }
          groupBy: {
            args: Prisma.InventoryCountGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountCountAggregateOutputType> | number
          }
        }
      }
      AdminAudit: {
        payload: Prisma.$AdminAuditPayload<ExtArgs>
        fields: Prisma.AdminAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          findMany: {
            args: Prisma.AdminAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>[]
          }
          create: {
            args: Prisma.AdminAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          createMany: {
            args: Prisma.AdminAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          update: {
            args: Prisma.AdminAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAudit>
          }
          groupBy: {
            args: Prisma.AdminAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditCountAggregateOutputType> | number
          }
        }
      }
      AdminNote: {
        payload: Prisma.$AdminNotePayload<ExtArgs>
        fields: Prisma.AdminNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          findFirst: {
            args: Prisma.AdminNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          findMany: {
            args: Prisma.AdminNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>[]
          }
          create: {
            args: Prisma.AdminNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          createMany: {
            args: Prisma.AdminNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>[]
          }
          delete: {
            args: Prisma.AdminNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          update: {
            args: Prisma.AdminNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          deleteMany: {
            args: Prisma.AdminNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>[]
          }
          upsert: {
            args: Prisma.AdminNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          aggregate: {
            args: Prisma.AdminNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminNote>
          }
          groupBy: {
            args: Prisma.AdminNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminNoteCountArgs<ExtArgs>
            result: $Utils.Optional<AdminNoteCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      StaticOffering: {
        payload: Prisma.$StaticOfferingPayload<ExtArgs>
        fields: Prisma.StaticOfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaticOfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaticOfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>
          }
          findFirst: {
            args: Prisma.StaticOfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaticOfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>
          }
          findMany: {
            args: Prisma.StaticOfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>[]
          }
          create: {
            args: Prisma.StaticOfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>
          }
          createMany: {
            args: Prisma.StaticOfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaticOfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>[]
          }
          delete: {
            args: Prisma.StaticOfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>
          }
          update: {
            args: Prisma.StaticOfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>
          }
          deleteMany: {
            args: Prisma.StaticOfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaticOfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaticOfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>[]
          }
          upsert: {
            args: Prisma.StaticOfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticOfferingPayload>
          }
          aggregate: {
            args: Prisma.StaticOfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaticOffering>
          }
          groupBy: {
            args: Prisma.StaticOfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaticOfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaticOfferingCountArgs<ExtArgs>
            result: $Utils.Optional<StaticOfferingCountAggregateOutputType> | number
          }
        }
      }
      DrinkSpecial: {
        payload: Prisma.$DrinkSpecialPayload<ExtArgs>
        fields: Prisma.DrinkSpecialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrinkSpecialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrinkSpecialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>
          }
          findFirst: {
            args: Prisma.DrinkSpecialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrinkSpecialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>
          }
          findMany: {
            args: Prisma.DrinkSpecialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>[]
          }
          create: {
            args: Prisma.DrinkSpecialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>
          }
          createMany: {
            args: Prisma.DrinkSpecialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DrinkSpecialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>[]
          }
          delete: {
            args: Prisma.DrinkSpecialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>
          }
          update: {
            args: Prisma.DrinkSpecialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>
          }
          deleteMany: {
            args: Prisma.DrinkSpecialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrinkSpecialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DrinkSpecialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>[]
          }
          upsert: {
            args: Prisma.DrinkSpecialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrinkSpecialPayload>
          }
          aggregate: {
            args: Prisma.DrinkSpecialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrinkSpecial>
          }
          groupBy: {
            args: Prisma.DrinkSpecialGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrinkSpecialGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrinkSpecialCountArgs<ExtArgs>
            result: $Utils.Optional<DrinkSpecialCountAggregateOutputType> | number
          }
        }
      }
      FoodOffering: {
        payload: Prisma.$FoodOfferingPayload<ExtArgs>
        fields: Prisma.FoodOfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodOfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodOfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>
          }
          findFirst: {
            args: Prisma.FoodOfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodOfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>
          }
          findMany: {
            args: Prisma.FoodOfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>[]
          }
          create: {
            args: Prisma.FoodOfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>
          }
          createMany: {
            args: Prisma.FoodOfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodOfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>[]
          }
          delete: {
            args: Prisma.FoodOfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>
          }
          update: {
            args: Prisma.FoodOfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>
          }
          deleteMany: {
            args: Prisma.FoodOfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodOfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodOfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>[]
          }
          upsert: {
            args: Prisma.FoodOfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodOfferingPayload>
          }
          aggregate: {
            args: Prisma.FoodOfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodOffering>
          }
          groupBy: {
            args: Prisma.FoodOfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodOfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodOfferingCountArgs<ExtArgs>
            result: $Utils.Optional<FoodOfferingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    owner?: OwnerOmit
    subscription?: SubscriptionOmit
    bar?: BarOmit
    offering?: OfferingOmit
    event?: EventOmit
    favorite?: FavoriteOmit
    activityCategory?: ActivityCategoryOmit
    categoryRequest?: CategoryRequestOmit
    ownerPasswordReset?: OwnerPasswordResetOmit
    promoCode?: PromoCodeOmit
    promoRedemption?: PromoRedemptionOmit
    barAnalytics?: BarAnalyticsOmit
    searchQuery?: SearchQueryOmit
    barClick?: BarClickOmit
    badge?: BadgeOmit
    barBadge?: BarBadgeOmit
    inventoryItem?: InventoryItemOmit
    inventoryImport?: InventoryImportOmit
    shiftUsage?: ShiftUsageOmit
    shiftUsageItem?: ShiftUsageItemOmit
    inventorySnapshot?: InventorySnapshotOmit
    inventorySnapshotItem?: InventorySnapshotItemOmit
    bottlePhoto?: BottlePhotoOmit
    costingProfile?: CostingProfileOmit
    varianceAlert?: VarianceAlertOmit
    barLicense?: BarLicenseOmit
    barVisit?: BarVisitOmit
    barMembership?: BarMembershipOmit
    patronSearchEvent?: PatronSearchEventOmit
    barAction?: BarActionOmit
    barFollower?: BarFollowerOmit
    boost?: BoostOmit
    boostMetric?: BoostMetricOmit
    product?: ProductOmit
    barProduct?: BarProductOmit
    inventoryScanSession?: InventoryScanSessionOmit
    inventoryScanDetection?: InventoryScanDetectionOmit
    inventoryCount?: InventoryCountOmit
    adminAudit?: AdminAuditOmit
    adminNote?: AdminNoteOmit
    supportTicket?: SupportTicketOmit
    staticOffering?: StaticOfferingOmit
    drinkSpecial?: DrinkSpecialOmit
    foodOffering?: FoodOfferingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    favorites: number
    visits: number
    inventoryImports: number
    shiftUsages: number
    inventorySnapshots: number
    adminNotes: number
    supportTickets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    visits?: boolean | UserCountOutputTypeCountVisitsArgs
    inventoryImports?: boolean | UserCountOutputTypeCountInventoryImportsArgs
    shiftUsages?: boolean | UserCountOutputTypeCountShiftUsagesArgs
    inventorySnapshots?: boolean | UserCountOutputTypeCountInventorySnapshotsArgs
    adminNotes?: boolean | UserCountOutputTypeCountAdminNotesArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarVisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryImportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventorySnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type OwnerCountOutputType
   */

  export type OwnerCountOutputType = {
    bars: number
    barLicenses: number
    promoRedemptions: number
    categoryRequests: number
    passwordResets: number
  }

  export type OwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bars?: boolean | OwnerCountOutputTypeCountBarsArgs
    barLicenses?: boolean | OwnerCountOutputTypeCountBarLicensesArgs
    promoRedemptions?: boolean | OwnerCountOutputTypeCountPromoRedemptionsArgs
    categoryRequests?: boolean | OwnerCountOutputTypeCountCategoryRequestsArgs
    passwordResets?: boolean | OwnerCountOutputTypeCountPasswordResetsArgs
  }

  // Custom InputTypes
  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCountOutputType
     */
    select?: OwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountBarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountBarLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarLicenseWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountPromoRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoRedemptionWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountCategoryRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryRequestWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerPasswordResetWhereInput
  }


  /**
   * Count Type BarCountOutputType
   */

  export type BarCountOutputType = {
    offerings: number
    events: number
    favorites: number
    analytics: number
    clicks: number
    badges: number
    barLicenses: number
    shiftUsages: number
    inventoryItems: number
    inventoryImports: number
    inventorySnapshots: number
    visits: number
    varianceAlerts: number
    staticOfferings: number
    drinkSpecials: number
    foodOfferings: number
    categoryRequests: number
    memberships: number
    followers: number
    boosts: number
    barProducts: number
    inventoryScanSessions: number
    inventoryCounts: number
    patronSearchEvents: number
    barActions: number
    adminNotes: number
    supportTickets: number
  }

  export type BarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | BarCountOutputTypeCountOfferingsArgs
    events?: boolean | BarCountOutputTypeCountEventsArgs
    favorites?: boolean | BarCountOutputTypeCountFavoritesArgs
    analytics?: boolean | BarCountOutputTypeCountAnalyticsArgs
    clicks?: boolean | BarCountOutputTypeCountClicksArgs
    badges?: boolean | BarCountOutputTypeCountBadgesArgs
    barLicenses?: boolean | BarCountOutputTypeCountBarLicensesArgs
    shiftUsages?: boolean | BarCountOutputTypeCountShiftUsagesArgs
    inventoryItems?: boolean | BarCountOutputTypeCountInventoryItemsArgs
    inventoryImports?: boolean | BarCountOutputTypeCountInventoryImportsArgs
    inventorySnapshots?: boolean | BarCountOutputTypeCountInventorySnapshotsArgs
    visits?: boolean | BarCountOutputTypeCountVisitsArgs
    varianceAlerts?: boolean | BarCountOutputTypeCountVarianceAlertsArgs
    staticOfferings?: boolean | BarCountOutputTypeCountStaticOfferingsArgs
    drinkSpecials?: boolean | BarCountOutputTypeCountDrinkSpecialsArgs
    foodOfferings?: boolean | BarCountOutputTypeCountFoodOfferingsArgs
    categoryRequests?: boolean | BarCountOutputTypeCountCategoryRequestsArgs
    memberships?: boolean | BarCountOutputTypeCountMembershipsArgs
    followers?: boolean | BarCountOutputTypeCountFollowersArgs
    boosts?: boolean | BarCountOutputTypeCountBoostsArgs
    barProducts?: boolean | BarCountOutputTypeCountBarProductsArgs
    inventoryScanSessions?: boolean | BarCountOutputTypeCountInventoryScanSessionsArgs
    inventoryCounts?: boolean | BarCountOutputTypeCountInventoryCountsArgs
    patronSearchEvents?: boolean | BarCountOutputTypeCountPatronSearchEventsArgs
    barActions?: boolean | BarCountOutputTypeCountBarActionsArgs
    adminNotes?: boolean | BarCountOutputTypeCountAdminNotesArgs
    supportTickets?: boolean | BarCountOutputTypeCountSupportTicketsArgs
  }

  // Custom InputTypes
  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarCountOutputType
     */
    select?: BarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferingWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarAnalyticsWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountClicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarClickWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarBadgeWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountBarLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarLicenseWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountShiftUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftUsageWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountInventoryImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryImportWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountInventorySnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySnapshotWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarVisitWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountVarianceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianceAlertWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountStaticOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaticOfferingWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountDrinkSpecialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrinkSpecialWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountFoodOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodOfferingWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountCategoryRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryRequestWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarMembershipWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarFollowerWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountBoostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoostWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountBarProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarProductWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountInventoryScanSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryScanSessionWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountInventoryCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryCountWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountPatronSearchEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatronSearchEventWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountBarActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarActionWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }

  /**
   * BarCountOutputType without action
   */
  export type BarCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    redemptions: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | PromoCodeCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoRedemptionWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    barBadges: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barBadges?: boolean | BadgeCountOutputTypeCountBarBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountBarBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarBadgeWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    snapshotItems: number
    shiftUsageItems: number
    costingProfiles: number
    varianceAlerts: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshotItems?: boolean | InventoryItemCountOutputTypeCountSnapshotItemsArgs
    shiftUsageItems?: boolean | InventoryItemCountOutputTypeCountShiftUsageItemsArgs
    costingProfiles?: boolean | InventoryItemCountOutputTypeCountCostingProfilesArgs
    varianceAlerts?: boolean | InventoryItemCountOutputTypeCountVarianceAlertsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountSnapshotItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySnapshotItemWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountShiftUsageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftUsageItemWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountCostingProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostingProfileWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountVarianceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianceAlertWhereInput
  }


  /**
   * Count Type ShiftUsageCountOutputType
   */

  export type ShiftUsageCountOutputType = {
    items: number
  }

  export type ShiftUsageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ShiftUsageCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ShiftUsageCountOutputType without action
   */
  export type ShiftUsageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageCountOutputType
     */
    select?: ShiftUsageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftUsageCountOutputType without action
   */
  export type ShiftUsageCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftUsageItemWhereInput
  }


  /**
   * Count Type InventorySnapshotCountOutputType
   */

  export type InventorySnapshotCountOutputType = {
    items: number
  }

  export type InventorySnapshotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InventorySnapshotCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InventorySnapshotCountOutputType without action
   */
  export type InventorySnapshotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotCountOutputType
     */
    select?: InventorySnapshotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventorySnapshotCountOutputType without action
   */
  export type InventorySnapshotCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySnapshotItemWhereInput
  }


  /**
   * Count Type BoostCountOutputType
   */

  export type BoostCountOutputType = {
    metrics: number
  }

  export type BoostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metrics?: boolean | BoostCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * BoostCountOutputType without action
   */
  export type BoostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostCountOutputType
     */
    select?: BoostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoostCountOutputType without action
   */
  export type BoostCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoostMetricWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    barProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barProducts?: boolean | ProductCountOutputTypeCountBarProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBarProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarProductWhereInput
  }


  /**
   * Count Type BarProductCountOutputType
   */

  export type BarProductCountOutputType = {
    counts: number
    detections: number
  }

  export type BarProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counts?: boolean | BarProductCountOutputTypeCountCountsArgs
    detections?: boolean | BarProductCountOutputTypeCountDetectionsArgs
  }

  // Custom InputTypes
  /**
   * BarProductCountOutputType without action
   */
  export type BarProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProductCountOutputType
     */
    select?: BarProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BarProductCountOutputType without action
   */
  export type BarProductCountOutputTypeCountCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryCountWhereInput
  }

  /**
   * BarProductCountOutputType without action
   */
  export type BarProductCountOutputTypeCountDetectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryScanDetectionWhereInput
  }


  /**
   * Count Type InventoryScanSessionCountOutputType
   */

  export type InventoryScanSessionCountOutputType = {
    detections: number
  }

  export type InventoryScanSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detections?: boolean | InventoryScanSessionCountOutputTypeCountDetectionsArgs
  }

  // Custom InputTypes
  /**
   * InventoryScanSessionCountOutputType without action
   */
  export type InventoryScanSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSessionCountOutputType
     */
    select?: InventoryScanSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryScanSessionCountOutputType without action
   */
  export type InventoryScanSessionCountOutputTypeCountDetectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryScanDetectionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    disabled: boolean | null
    role: $Enums.UserRole | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    disabled: boolean | null
    role: $Enums.UserRole | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    image: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    disabled: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    disabled?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    disabled?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    disabled?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    disabled: boolean
    role: $Enums.UserRole
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disabled?: boolean
    role?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    visits?: boolean | User$visitsArgs<ExtArgs>
    inventoryImports?: boolean | User$inventoryImportsArgs<ExtArgs>
    shiftUsages?: boolean | User$shiftUsagesArgs<ExtArgs>
    inventorySnapshots?: boolean | User$inventorySnapshotsArgs<ExtArgs>
    adminNotes?: boolean | User$adminNotesArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disabled?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disabled?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disabled?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "image" | "emailVerified" | "createdAt" | "updatedAt" | "disabled" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    visits?: boolean | User$visitsArgs<ExtArgs>
    inventoryImports?: boolean | User$inventoryImportsArgs<ExtArgs>
    shiftUsages?: boolean | User$shiftUsagesArgs<ExtArgs>
    inventorySnapshots?: boolean | User$inventorySnapshotsArgs<ExtArgs>
    adminNotes?: boolean | User$adminNotesArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      visits: Prisma.$BarVisitPayload<ExtArgs>[]
      inventoryImports: Prisma.$InventoryImportPayload<ExtArgs>[]
      shiftUsages: Prisma.$ShiftUsagePayload<ExtArgs>[]
      inventorySnapshots: Prisma.$InventorySnapshotPayload<ExtArgs>[]
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      image: string | null
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
      disabled: boolean
      role: $Enums.UserRole
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visits<T extends User$visitsArgs<ExtArgs> = {}>(args?: Subset<T, User$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryImports<T extends User$inventoryImportsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryImportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shiftUsages<T extends User$shiftUsagesArgs<ExtArgs> = {}>(args?: Subset<T, User$shiftUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventorySnapshots<T extends User$inventorySnapshotsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventorySnapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminNotes<T extends User$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly disabled: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.visits
   */
  export type User$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    where?: BarVisitWhereInput
    orderBy?: BarVisitOrderByWithRelationInput | BarVisitOrderByWithRelationInput[]
    cursor?: BarVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarVisitScalarFieldEnum | BarVisitScalarFieldEnum[]
  }

  /**
   * User.inventoryImports
   */
  export type User$inventoryImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    where?: InventoryImportWhereInput
    orderBy?: InventoryImportOrderByWithRelationInput | InventoryImportOrderByWithRelationInput[]
    cursor?: InventoryImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryImportScalarFieldEnum | InventoryImportScalarFieldEnum[]
  }

  /**
   * User.shiftUsages
   */
  export type User$shiftUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    where?: ShiftUsageWhereInput
    orderBy?: ShiftUsageOrderByWithRelationInput | ShiftUsageOrderByWithRelationInput[]
    cursor?: ShiftUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftUsageScalarFieldEnum | ShiftUsageScalarFieldEnum[]
  }

  /**
   * User.inventorySnapshots
   */
  export type User$inventorySnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    where?: InventorySnapshotWhereInput
    orderBy?: InventorySnapshotOrderByWithRelationInput | InventorySnapshotOrderByWithRelationInput[]
    cursor?: InventorySnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySnapshotScalarFieldEnum | InventorySnapshotScalarFieldEnum[]
  }

  /**
   * User.adminNotes
   */
  export type User$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Owner
   */

  export type AggregateOwner = {
    _count: OwnerCountAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  export type OwnerMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    phone: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    allowFreeListings: boolean | null
    role: $Enums.OwnerRole | null
  }

  export type OwnerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    phone: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    allowFreeListings: boolean | null
    role: $Enums.OwnerRole | null
  }

  export type OwnerCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    phone: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    allowFreeListings: number
    role: number
    _all: number
  }


  export type OwnerMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    phone?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    allowFreeListings?: true
    role?: true
  }

  export type OwnerMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    phone?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    allowFreeListings?: true
    role?: true
  }

  export type OwnerCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    phone?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    allowFreeListings?: true
    role?: true
    _all?: true
  }

  export type OwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owner to aggregate.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners
    **/
    _count?: true | OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerMaxAggregateInputType
  }

  export type GetOwnerAggregateType<T extends OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwner[P]>
      : GetScalarType<T[P], AggregateOwner[P]>
  }




  export type OwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithAggregationInput | OwnerOrderByWithAggregationInput[]
    by: OwnerScalarFieldEnum[] | OwnerScalarFieldEnum
    having?: OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCountAggregateInputType | true
    _min?: OwnerMinAggregateInputType
    _max?: OwnerMaxAggregateInputType
  }

  export type OwnerGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    phone: string | null
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    allowFreeListings: boolean
    role: $Enums.OwnerRole
    _count: OwnerCountAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  type GetOwnerGroupByPayload<T extends OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerGroupByOutputType[P]>
        }
      >
    >


  export type OwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    allowFreeListings?: boolean
    role?: boolean
    bars?: boolean | Owner$barsArgs<ExtArgs>
    subscription?: boolean | Owner$subscriptionArgs<ExtArgs>
    barLicenses?: boolean | Owner$barLicensesArgs<ExtArgs>
    promoRedemptions?: boolean | Owner$promoRedemptionsArgs<ExtArgs>
    categoryRequests?: boolean | Owner$categoryRequestsArgs<ExtArgs>
    passwordResets?: boolean | Owner$passwordResetsArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    allowFreeListings?: boolean
    role?: boolean
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    allowFreeListings?: boolean
    role?: boolean
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    phone?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    allowFreeListings?: boolean
    role?: boolean
  }

  export type OwnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "phone" | "emailVerified" | "createdAt" | "updatedAt" | "allowFreeListings" | "role", ExtArgs["result"]["owner"]>
  export type OwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bars?: boolean | Owner$barsArgs<ExtArgs>
    subscription?: boolean | Owner$subscriptionArgs<ExtArgs>
    barLicenses?: boolean | Owner$barLicensesArgs<ExtArgs>
    promoRedemptions?: boolean | Owner$promoRedemptionsArgs<ExtArgs>
    categoryRequests?: boolean | Owner$categoryRequestsArgs<ExtArgs>
    passwordResets?: boolean | Owner$passwordResetsArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OwnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owner"
    objects: {
      bars: Prisma.$BarPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      barLicenses: Prisma.$BarLicensePayload<ExtArgs>[]
      promoRedemptions: Prisma.$PromoRedemptionPayload<ExtArgs>[]
      categoryRequests: Prisma.$CategoryRequestPayload<ExtArgs>[]
      passwordResets: Prisma.$OwnerPasswordResetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      phone: string | null
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
      allowFreeListings: boolean
      role: $Enums.OwnerRole
    }, ExtArgs["result"]["owner"]>
    composites: {}
  }

  type OwnerGetPayload<S extends boolean | null | undefined | OwnerDefaultArgs> = $Result.GetResult<Prisma.$OwnerPayload, S>

  type OwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerCountAggregateInputType | true
    }

  export interface OwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owner'], meta: { name: 'Owner' } }
    /**
     * Find zero or one Owner that matches the filter.
     * @param {OwnerFindUniqueArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerFindUniqueArgs>(args: SelectSubset<T, OwnerFindUniqueArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Owner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerFindUniqueOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerFindFirstArgs>(args?: SelectSubset<T, OwnerFindFirstArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owner.findMany()
     * 
     * // Get first 10 Owners
     * const owners = await prisma.owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerFindManyArgs>(args?: SelectSubset<T, OwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Owner.
     * @param {OwnerCreateArgs} args - Arguments to create a Owner.
     * @example
     * // Create one Owner
     * const Owner = await prisma.owner.create({
     *   data: {
     *     // ... data to create a Owner
     *   }
     * })
     * 
     */
    create<T extends OwnerCreateArgs>(args: SelectSubset<T, OwnerCreateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Owners.
     * @param {OwnerCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerCreateManyArgs>(args?: SelectSubset<T, OwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Owners and returns the data saved in the database.
     * @param {OwnerCreateManyAndReturnArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Owners and only return the `id`
     * const ownerWithIdOnly = await prisma.owner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Owner.
     * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
     * @example
     * // Delete one Owner
     * const Owner = await prisma.owner.delete({
     *   where: {
     *     // ... filter to delete one Owner
     *   }
     * })
     * 
     */
    delete<T extends OwnerDeleteArgs>(args: SelectSubset<T, OwnerDeleteArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Owner.
     * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
     * @example
     * // Update one Owner
     * const owner = await prisma.owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerUpdateArgs>(args: SelectSubset<T, OwnerUpdateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Owners.
     * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDeleteManyArgs>(args?: SelectSubset<T, OwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerUpdateManyArgs>(args: SelectSubset<T, OwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners and returns the data updated in the database.
     * @param {OwnerUpdateManyAndReturnArgs} args - Arguments to update many Owners.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Owners and only return the `id`
     * const ownerWithIdOnly = await prisma.owner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Owner.
     * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
     * @example
     * // Update or create a Owner
     * const owner = await prisma.owner.upsert({
     *   create: {
     *     // ... data to create a Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owner we want to update
     *   }
     * })
     */
    upsert<T extends OwnerUpsertArgs>(args: SelectSubset<T, OwnerUpsertArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owner.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
    **/
    count<T extends OwnerCountArgs>(
      args?: Subset<T, OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerAggregateArgs>(args: Subset<T, OwnerAggregateArgs>): Prisma.PrismaPromise<GetOwnerAggregateType<T>>

    /**
     * Group by Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerGroupByArgs['orderBy'] }
        : { orderBy?: OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owner model
   */
  readonly fields: OwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bars<T extends Owner$barsArgs<ExtArgs> = {}>(args?: Subset<T, Owner$barsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Owner$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Owner$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    barLicenses<T extends Owner$barLicensesArgs<ExtArgs> = {}>(args?: Subset<T, Owner$barLicensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoRedemptions<T extends Owner$promoRedemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Owner$promoRedemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categoryRequests<T extends Owner$categoryRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Owner$categoryRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResets<T extends Owner$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, Owner$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owner model
   */
  interface OwnerFieldRefs {
    readonly id: FieldRef<"Owner", 'String'>
    readonly email: FieldRef<"Owner", 'String'>
    readonly name: FieldRef<"Owner", 'String'>
    readonly password: FieldRef<"Owner", 'String'>
    readonly phone: FieldRef<"Owner", 'String'>
    readonly emailVerified: FieldRef<"Owner", 'DateTime'>
    readonly createdAt: FieldRef<"Owner", 'DateTime'>
    readonly updatedAt: FieldRef<"Owner", 'DateTime'>
    readonly allowFreeListings: FieldRef<"Owner", 'Boolean'>
    readonly role: FieldRef<"Owner", 'OwnerRole'>
  }
    

  // Custom InputTypes
  /**
   * Owner findUnique
   */
  export type OwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findUniqueOrThrow
   */
  export type OwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findFirst
   */
  export type OwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findFirstOrThrow
   */
  export type OwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findMany
   */
  export type OwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owners to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner create
   */
  export type OwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Owner.
     */
    data: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
  }

  /**
   * Owner createMany
   */
  export type OwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner createManyAndReturn
   */
  export type OwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner update
   */
  export type OwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Owner.
     */
    data: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
    /**
     * Choose, which Owner to update.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner updateMany
   */
  export type OwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
    /**
     * Limit how many Owners to update.
     */
    limit?: number
  }

  /**
   * Owner updateManyAndReturn
   */
  export type OwnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
    /**
     * Limit how many Owners to update.
     */
    limit?: number
  }

  /**
   * Owner upsert
   */
  export type OwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Owner to update in case it exists.
     */
    where: OwnerWhereUniqueInput
    /**
     * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
     */
    create: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
    /**
     * In case the Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
  }

  /**
   * Owner delete
   */
  export type OwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter which Owner to delete.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner deleteMany
   */
  export type OwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners to delete
     */
    where?: OwnerWhereInput
    /**
     * Limit how many Owners to delete.
     */
    limit?: number
  }

  /**
   * Owner.bars
   */
  export type Owner$barsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    where?: BarWhereInput
    orderBy?: BarOrderByWithRelationInput | BarOrderByWithRelationInput[]
    cursor?: BarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarScalarFieldEnum | BarScalarFieldEnum[]
  }

  /**
   * Owner.subscription
   */
  export type Owner$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Owner.barLicenses
   */
  export type Owner$barLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    where?: BarLicenseWhereInput
    orderBy?: BarLicenseOrderByWithRelationInput | BarLicenseOrderByWithRelationInput[]
    cursor?: BarLicenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarLicenseScalarFieldEnum | BarLicenseScalarFieldEnum[]
  }

  /**
   * Owner.promoRedemptions
   */
  export type Owner$promoRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    where?: PromoRedemptionWhereInput
    orderBy?: PromoRedemptionOrderByWithRelationInput | PromoRedemptionOrderByWithRelationInput[]
    cursor?: PromoRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoRedemptionScalarFieldEnum | PromoRedemptionScalarFieldEnum[]
  }

  /**
   * Owner.categoryRequests
   */
  export type Owner$categoryRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    where?: CategoryRequestWhereInput
    orderBy?: CategoryRequestOrderByWithRelationInput | CategoryRequestOrderByWithRelationInput[]
    cursor?: CategoryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryRequestScalarFieldEnum | CategoryRequestScalarFieldEnum[]
  }

  /**
   * Owner.passwordResets
   */
  export type Owner$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    where?: OwnerPasswordResetWhereInput
    orderBy?: OwnerPasswordResetOrderByWithRelationInput | OwnerPasswordResetOrderByWithRelationInput[]
    cursor?: OwnerPasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerPasswordResetScalarFieldEnum | OwnerPasswordResetScalarFieldEnum[]
  }

  /**
   * Owner without action
   */
  export type OwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    paypalCustomerId: string | null
    paypalSubscriptionId: string | null
    priceId: string | null
    currentPeriodEnd: Date | null
    trialEndsAt: Date | null
    trialReminderSentAt: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.SubscriptionStatus | null
    paypalCustomerId: string | null
    paypalSubscriptionId: string | null
    priceId: string | null
    currentPeriodEnd: Date | null
    trialEndsAt: Date | null
    trialReminderSentAt: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    ownerId: number
    plan: number
    status: number
    paypalCustomerId: number
    paypalSubscriptionId: number
    priceId: number
    currentPeriodEnd: number
    trialEndsAt: number
    trialReminderSentAt: number
    cancelAtPeriodEnd: number
    canceledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    ownerId?: true
    plan?: true
    status?: true
    paypalCustomerId?: true
    paypalSubscriptionId?: true
    priceId?: true
    currentPeriodEnd?: true
    trialEndsAt?: true
    trialReminderSentAt?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    ownerId?: true
    plan?: true
    status?: true
    paypalCustomerId?: true
    paypalSubscriptionId?: true
    priceId?: true
    currentPeriodEnd?: true
    trialEndsAt?: true
    trialReminderSentAt?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    ownerId?: true
    plan?: true
    status?: true
    paypalCustomerId?: true
    paypalSubscriptionId?: true
    priceId?: true
    currentPeriodEnd?: true
    trialEndsAt?: true
    trialReminderSentAt?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    ownerId: string
    plan: $Enums.SubscriptionPlan
    status: $Enums.SubscriptionStatus
    paypalCustomerId: string | null
    paypalSubscriptionId: string | null
    priceId: string | null
    currentPeriodEnd: Date | null
    trialEndsAt: Date | null
    trialReminderSentAt: Date | null
    cancelAtPeriodEnd: boolean
    canceledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    plan?: boolean
    status?: boolean
    paypalCustomerId?: boolean
    paypalSubscriptionId?: boolean
    priceId?: boolean
    currentPeriodEnd?: boolean
    trialEndsAt?: boolean
    trialReminderSentAt?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    plan?: boolean
    status?: boolean
    paypalCustomerId?: boolean
    paypalSubscriptionId?: boolean
    priceId?: boolean
    currentPeriodEnd?: boolean
    trialEndsAt?: boolean
    trialReminderSentAt?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    plan?: boolean
    status?: boolean
    paypalCustomerId?: boolean
    paypalSubscriptionId?: boolean
    priceId?: boolean
    currentPeriodEnd?: boolean
    trialEndsAt?: boolean
    trialReminderSentAt?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    ownerId?: boolean
    plan?: boolean
    status?: boolean
    paypalCustomerId?: boolean
    paypalSubscriptionId?: boolean
    priceId?: boolean
    currentPeriodEnd?: boolean
    trialEndsAt?: boolean
    trialReminderSentAt?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "plan" | "status" | "paypalCustomerId" | "paypalSubscriptionId" | "priceId" | "currentPeriodEnd" | "trialEndsAt" | "trialReminderSentAt" | "cancelAtPeriodEnd" | "canceledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      plan: $Enums.SubscriptionPlan
      status: $Enums.SubscriptionStatus
      paypalCustomerId: string | null
      paypalSubscriptionId: string | null
      priceId: string | null
      currentPeriodEnd: Date | null
      trialEndsAt: Date | null
      trialReminderSentAt: Date | null
      cancelAtPeriodEnd: boolean
      canceledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly ownerId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'SubscriptionPlan'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly paypalCustomerId: FieldRef<"Subscription", 'String'>
    readonly paypalSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly priceId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly trialEndsAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialReminderSentAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Bar
   */

  export type AggregateBar = {
    _count: BarCountAggregateOutputType | null
    _avg: BarAvgAggregateOutputType | null
    _sum: BarSumAggregateOutputType | null
    _min: BarMinAggregateOutputType | null
    _max: BarMaxAggregateOutputType | null
  }

  export type BarAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    profileViews: number | null
    searchAppearances: number | null
  }

  export type BarSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    profileViews: number | null
    searchAppearances: number | null
  }

  export type BarMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    slug: string | null
    description: string | null
    address: string | null
    city: string | null
    cityNormalized: string | null
    state: string | null
    zipCode: string | null
    barType: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    inventoryAddOnEnabled: boolean | null
    checkInReward: string | null
    neighborhood: string | null
    neighborhoodNormalized: string | null
    latitude: number | null
    longitude: number | null
    phone: string | null
    website: string | null
    logo: string | null
    isActive: boolean | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileViews: number | null
    searchAppearances: number | null
  }

  export type BarMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    slug: string | null
    description: string | null
    address: string | null
    city: string | null
    cityNormalized: string | null
    state: string | null
    zipCode: string | null
    barType: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    inventoryAddOnEnabled: boolean | null
    checkInReward: string | null
    neighborhood: string | null
    neighborhoodNormalized: string | null
    latitude: number | null
    longitude: number | null
    phone: string | null
    website: string | null
    logo: string | null
    isActive: boolean | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileViews: number | null
    searchAppearances: number | null
  }

  export type BarCountAggregateOutputType = {
    id: number
    ownerId: number
    name: number
    slug: number
    description: number
    address: number
    city: number
    cityNormalized: number
    state: number
    zipCode: number
    barType: number
    subscriptionTier: number
    inventoryAddOnEnabled: number
    checkInReward: number
    neighborhood: number
    neighborhoodNormalized: number
    latitude: number
    longitude: number
    phone: number
    website: number
    logo: number
    photos: number
    hours: number
    isActive: number
    isPublished: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    profileViews: number
    searchAppearances: number
    _all: number
  }


  export type BarAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    profileViews?: true
    searchAppearances?: true
  }

  export type BarSumAggregateInputType = {
    latitude?: true
    longitude?: true
    profileViews?: true
    searchAppearances?: true
  }

  export type BarMinAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    slug?: true
    description?: true
    address?: true
    city?: true
    cityNormalized?: true
    state?: true
    zipCode?: true
    barType?: true
    subscriptionTier?: true
    inventoryAddOnEnabled?: true
    checkInReward?: true
    neighborhood?: true
    neighborhoodNormalized?: true
    latitude?: true
    longitude?: true
    phone?: true
    website?: true
    logo?: true
    isActive?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    profileViews?: true
    searchAppearances?: true
  }

  export type BarMaxAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    slug?: true
    description?: true
    address?: true
    city?: true
    cityNormalized?: true
    state?: true
    zipCode?: true
    barType?: true
    subscriptionTier?: true
    inventoryAddOnEnabled?: true
    checkInReward?: true
    neighborhood?: true
    neighborhoodNormalized?: true
    latitude?: true
    longitude?: true
    phone?: true
    website?: true
    logo?: true
    isActive?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    profileViews?: true
    searchAppearances?: true
  }

  export type BarCountAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    slug?: true
    description?: true
    address?: true
    city?: true
    cityNormalized?: true
    state?: true
    zipCode?: true
    barType?: true
    subscriptionTier?: true
    inventoryAddOnEnabled?: true
    checkInReward?: true
    neighborhood?: true
    neighborhoodNormalized?: true
    latitude?: true
    longitude?: true
    phone?: true
    website?: true
    logo?: true
    photos?: true
    hours?: true
    isActive?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    profileViews?: true
    searchAppearances?: true
    _all?: true
  }

  export type BarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bar to aggregate.
     */
    where?: BarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bars to fetch.
     */
    orderBy?: BarOrderByWithRelationInput | BarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bars
    **/
    _count?: true | BarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarMaxAggregateInputType
  }

  export type GetBarAggregateType<T extends BarAggregateArgs> = {
        [P in keyof T & keyof AggregateBar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBar[P]>
      : GetScalarType<T[P], AggregateBar[P]>
  }




  export type BarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarWhereInput
    orderBy?: BarOrderByWithAggregationInput | BarOrderByWithAggregationInput[]
    by: BarScalarFieldEnum[] | BarScalarFieldEnum
    having?: BarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarCountAggregateInputType | true
    _avg?: BarAvgAggregateInputType
    _sum?: BarSumAggregateInputType
    _min?: BarMinAggregateInputType
    _max?: BarMaxAggregateInputType
  }

  export type BarGroupByOutputType = {
    id: string
    ownerId: string
    name: string
    slug: string
    description: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType: string | null
    subscriptionTier: $Enums.SubscriptionTier
    inventoryAddOnEnabled: boolean
    checkInReward: string | null
    neighborhood: string | null
    neighborhoodNormalized: string | null
    latitude: number
    longitude: number
    phone: string | null
    website: string | null
    logo: string | null
    photos: string[]
    hours: JsonValue | null
    isActive: boolean
    isPublished: boolean
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    profileViews: number
    searchAppearances: number
    _count: BarCountAggregateOutputType | null
    _avg: BarAvgAggregateOutputType | null
    _sum: BarSumAggregateOutputType | null
    _min: BarMinAggregateOutputType | null
    _max: BarMaxAggregateOutputType | null
  }

  type GetBarGroupByPayload<T extends BarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarGroupByOutputType[P]>
            : GetScalarType<T[P], BarGroupByOutputType[P]>
        }
      >
    >


  export type BarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    cityNormalized?: boolean
    state?: boolean
    zipCode?: boolean
    barType?: boolean
    subscriptionTier?: boolean
    inventoryAddOnEnabled?: boolean
    checkInReward?: boolean
    neighborhood?: boolean
    neighborhoodNormalized?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    photos?: boolean
    hours?: boolean
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileViews?: boolean
    searchAppearances?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    offerings?: boolean | Bar$offeringsArgs<ExtArgs>
    events?: boolean | Bar$eventsArgs<ExtArgs>
    favorites?: boolean | Bar$favoritesArgs<ExtArgs>
    analytics?: boolean | Bar$analyticsArgs<ExtArgs>
    clicks?: boolean | Bar$clicksArgs<ExtArgs>
    badges?: boolean | Bar$badgesArgs<ExtArgs>
    barLicenses?: boolean | Bar$barLicensesArgs<ExtArgs>
    shiftUsages?: boolean | Bar$shiftUsagesArgs<ExtArgs>
    inventoryItems?: boolean | Bar$inventoryItemsArgs<ExtArgs>
    inventoryImports?: boolean | Bar$inventoryImportsArgs<ExtArgs>
    inventorySnapshots?: boolean | Bar$inventorySnapshotsArgs<ExtArgs>
    visits?: boolean | Bar$visitsArgs<ExtArgs>
    varianceAlerts?: boolean | Bar$varianceAlertsArgs<ExtArgs>
    staticOfferings?: boolean | Bar$staticOfferingsArgs<ExtArgs>
    drinkSpecials?: boolean | Bar$drinkSpecialsArgs<ExtArgs>
    foodOfferings?: boolean | Bar$foodOfferingsArgs<ExtArgs>
    categoryRequests?: boolean | Bar$categoryRequestsArgs<ExtArgs>
    memberships?: boolean | Bar$membershipsArgs<ExtArgs>
    followers?: boolean | Bar$followersArgs<ExtArgs>
    boosts?: boolean | Bar$boostsArgs<ExtArgs>
    barProducts?: boolean | Bar$barProductsArgs<ExtArgs>
    inventoryScanSessions?: boolean | Bar$inventoryScanSessionsArgs<ExtArgs>
    inventoryCounts?: boolean | Bar$inventoryCountsArgs<ExtArgs>
    patronSearchEvents?: boolean | Bar$patronSearchEventsArgs<ExtArgs>
    barActions?: boolean | Bar$barActionsArgs<ExtArgs>
    adminNotes?: boolean | Bar$adminNotesArgs<ExtArgs>
    supportTickets?: boolean | Bar$supportTicketsArgs<ExtArgs>
    _count?: boolean | BarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bar"]>

  export type BarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    cityNormalized?: boolean
    state?: boolean
    zipCode?: boolean
    barType?: boolean
    subscriptionTier?: boolean
    inventoryAddOnEnabled?: boolean
    checkInReward?: boolean
    neighborhood?: boolean
    neighborhoodNormalized?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    photos?: boolean
    hours?: boolean
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileViews?: boolean
    searchAppearances?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bar"]>

  export type BarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    cityNormalized?: boolean
    state?: boolean
    zipCode?: boolean
    barType?: boolean
    subscriptionTier?: boolean
    inventoryAddOnEnabled?: boolean
    checkInReward?: boolean
    neighborhood?: boolean
    neighborhoodNormalized?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    photos?: boolean
    hours?: boolean
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileViews?: boolean
    searchAppearances?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bar"]>

  export type BarSelectScalar = {
    id?: boolean
    ownerId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    cityNormalized?: boolean
    state?: boolean
    zipCode?: boolean
    barType?: boolean
    subscriptionTier?: boolean
    inventoryAddOnEnabled?: boolean
    checkInReward?: boolean
    neighborhood?: boolean
    neighborhoodNormalized?: boolean
    latitude?: boolean
    longitude?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    photos?: boolean
    hours?: boolean
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileViews?: boolean
    searchAppearances?: boolean
  }

  export type BarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "name" | "slug" | "description" | "address" | "city" | "cityNormalized" | "state" | "zipCode" | "barType" | "subscriptionTier" | "inventoryAddOnEnabled" | "checkInReward" | "neighborhood" | "neighborhoodNormalized" | "latitude" | "longitude" | "phone" | "website" | "logo" | "photos" | "hours" | "isActive" | "isPublished" | "publishedAt" | "createdAt" | "updatedAt" | "profileViews" | "searchAppearances", ExtArgs["result"]["bar"]>
  export type BarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    offerings?: boolean | Bar$offeringsArgs<ExtArgs>
    events?: boolean | Bar$eventsArgs<ExtArgs>
    favorites?: boolean | Bar$favoritesArgs<ExtArgs>
    analytics?: boolean | Bar$analyticsArgs<ExtArgs>
    clicks?: boolean | Bar$clicksArgs<ExtArgs>
    badges?: boolean | Bar$badgesArgs<ExtArgs>
    barLicenses?: boolean | Bar$barLicensesArgs<ExtArgs>
    shiftUsages?: boolean | Bar$shiftUsagesArgs<ExtArgs>
    inventoryItems?: boolean | Bar$inventoryItemsArgs<ExtArgs>
    inventoryImports?: boolean | Bar$inventoryImportsArgs<ExtArgs>
    inventorySnapshots?: boolean | Bar$inventorySnapshotsArgs<ExtArgs>
    visits?: boolean | Bar$visitsArgs<ExtArgs>
    varianceAlerts?: boolean | Bar$varianceAlertsArgs<ExtArgs>
    staticOfferings?: boolean | Bar$staticOfferingsArgs<ExtArgs>
    drinkSpecials?: boolean | Bar$drinkSpecialsArgs<ExtArgs>
    foodOfferings?: boolean | Bar$foodOfferingsArgs<ExtArgs>
    categoryRequests?: boolean | Bar$categoryRequestsArgs<ExtArgs>
    memberships?: boolean | Bar$membershipsArgs<ExtArgs>
    followers?: boolean | Bar$followersArgs<ExtArgs>
    boosts?: boolean | Bar$boostsArgs<ExtArgs>
    barProducts?: boolean | Bar$barProductsArgs<ExtArgs>
    inventoryScanSessions?: boolean | Bar$inventoryScanSessionsArgs<ExtArgs>
    inventoryCounts?: boolean | Bar$inventoryCountsArgs<ExtArgs>
    patronSearchEvents?: boolean | Bar$patronSearchEventsArgs<ExtArgs>
    barActions?: boolean | Bar$barActionsArgs<ExtArgs>
    adminNotes?: boolean | Bar$adminNotesArgs<ExtArgs>
    supportTickets?: boolean | Bar$supportTicketsArgs<ExtArgs>
    _count?: boolean | BarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type BarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $BarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bar"
    objects: {
      owner: Prisma.$OwnerPayload<ExtArgs>
      offerings: Prisma.$OfferingPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      analytics: Prisma.$BarAnalyticsPayload<ExtArgs>[]
      clicks: Prisma.$BarClickPayload<ExtArgs>[]
      badges: Prisma.$BarBadgePayload<ExtArgs>[]
      barLicenses: Prisma.$BarLicensePayload<ExtArgs>[]
      shiftUsages: Prisma.$ShiftUsagePayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      inventoryImports: Prisma.$InventoryImportPayload<ExtArgs>[]
      inventorySnapshots: Prisma.$InventorySnapshotPayload<ExtArgs>[]
      visits: Prisma.$BarVisitPayload<ExtArgs>[]
      varianceAlerts: Prisma.$VarianceAlertPayload<ExtArgs>[]
      staticOfferings: Prisma.$StaticOfferingPayload<ExtArgs>[]
      drinkSpecials: Prisma.$DrinkSpecialPayload<ExtArgs>[]
      foodOfferings: Prisma.$FoodOfferingPayload<ExtArgs>[]
      categoryRequests: Prisma.$CategoryRequestPayload<ExtArgs>[]
      memberships: Prisma.$BarMembershipPayload<ExtArgs>[]
      followers: Prisma.$BarFollowerPayload<ExtArgs>[]
      boosts: Prisma.$BoostPayload<ExtArgs>[]
      barProducts: Prisma.$BarProductPayload<ExtArgs>[]
      inventoryScanSessions: Prisma.$InventoryScanSessionPayload<ExtArgs>[]
      inventoryCounts: Prisma.$InventoryCountPayload<ExtArgs>[]
      patronSearchEvents: Prisma.$PatronSearchEventPayload<ExtArgs>[]
      barActions: Prisma.$BarActionPayload<ExtArgs>[]
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      name: string
      slug: string
      description: string | null
      address: string
      city: string
      cityNormalized: string
      state: string
      zipCode: string
      barType: string | null
      subscriptionTier: $Enums.SubscriptionTier
      inventoryAddOnEnabled: boolean
      checkInReward: string | null
      neighborhood: string | null
      neighborhoodNormalized: string | null
      latitude: number
      longitude: number
      phone: string | null
      website: string | null
      logo: string | null
      photos: string[]
      hours: Prisma.JsonValue | null
      isActive: boolean
      isPublished: boolean
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      profileViews: number
      searchAppearances: number
    }, ExtArgs["result"]["bar"]>
    composites: {}
  }

  type BarGetPayload<S extends boolean | null | undefined | BarDefaultArgs> = $Result.GetResult<Prisma.$BarPayload, S>

  type BarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarCountAggregateInputType | true
    }

  export interface BarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bar'], meta: { name: 'Bar' } }
    /**
     * Find zero or one Bar that matches the filter.
     * @param {BarFindUniqueArgs} args - Arguments to find a Bar
     * @example
     * // Get one Bar
     * const bar = await prisma.bar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarFindUniqueArgs>(args: SelectSubset<T, BarFindUniqueArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarFindUniqueOrThrowArgs} args - Arguments to find a Bar
     * @example
     * // Get one Bar
     * const bar = await prisma.bar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarFindUniqueOrThrowArgs>(args: SelectSubset<T, BarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFindFirstArgs} args - Arguments to find a Bar
     * @example
     * // Get one Bar
     * const bar = await prisma.bar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarFindFirstArgs>(args?: SelectSubset<T, BarFindFirstArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFindFirstOrThrowArgs} args - Arguments to find a Bar
     * @example
     * // Get one Bar
     * const bar = await prisma.bar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarFindFirstOrThrowArgs>(args?: SelectSubset<T, BarFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bars
     * const bars = await prisma.bar.findMany()
     * 
     * // Get first 10 Bars
     * const bars = await prisma.bar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barWithIdOnly = await prisma.bar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarFindManyArgs>(args?: SelectSubset<T, BarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bar.
     * @param {BarCreateArgs} args - Arguments to create a Bar.
     * @example
     * // Create one Bar
     * const Bar = await prisma.bar.create({
     *   data: {
     *     // ... data to create a Bar
     *   }
     * })
     * 
     */
    create<T extends BarCreateArgs>(args: SelectSubset<T, BarCreateArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bars.
     * @param {BarCreateManyArgs} args - Arguments to create many Bars.
     * @example
     * // Create many Bars
     * const bar = await prisma.bar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarCreateManyArgs>(args?: SelectSubset<T, BarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bars and returns the data saved in the database.
     * @param {BarCreateManyAndReturnArgs} args - Arguments to create many Bars.
     * @example
     * // Create many Bars
     * const bar = await prisma.bar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bars and only return the `id`
     * const barWithIdOnly = await prisma.bar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarCreateManyAndReturnArgs>(args?: SelectSubset<T, BarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bar.
     * @param {BarDeleteArgs} args - Arguments to delete one Bar.
     * @example
     * // Delete one Bar
     * const Bar = await prisma.bar.delete({
     *   where: {
     *     // ... filter to delete one Bar
     *   }
     * })
     * 
     */
    delete<T extends BarDeleteArgs>(args: SelectSubset<T, BarDeleteArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bar.
     * @param {BarUpdateArgs} args - Arguments to update one Bar.
     * @example
     * // Update one Bar
     * const bar = await prisma.bar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarUpdateArgs>(args: SelectSubset<T, BarUpdateArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bars.
     * @param {BarDeleteManyArgs} args - Arguments to filter Bars to delete.
     * @example
     * // Delete a few Bars
     * const { count } = await prisma.bar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarDeleteManyArgs>(args?: SelectSubset<T, BarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bars
     * const bar = await prisma.bar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarUpdateManyArgs>(args: SelectSubset<T, BarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bars and returns the data updated in the database.
     * @param {BarUpdateManyAndReturnArgs} args - Arguments to update many Bars.
     * @example
     * // Update many Bars
     * const bar = await prisma.bar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bars and only return the `id`
     * const barWithIdOnly = await prisma.bar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarUpdateManyAndReturnArgs>(args: SelectSubset<T, BarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bar.
     * @param {BarUpsertArgs} args - Arguments to update or create a Bar.
     * @example
     * // Update or create a Bar
     * const bar = await prisma.bar.upsert({
     *   create: {
     *     // ... data to create a Bar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bar we want to update
     *   }
     * })
     */
    upsert<T extends BarUpsertArgs>(args: SelectSubset<T, BarUpsertArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarCountArgs} args - Arguments to filter Bars to count.
     * @example
     * // Count the number of Bars
     * const count = await prisma.bar.count({
     *   where: {
     *     // ... the filter for the Bars we want to count
     *   }
     * })
    **/
    count<T extends BarCountArgs>(
      args?: Subset<T, BarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarAggregateArgs>(args: Subset<T, BarAggregateArgs>): Prisma.PrismaPromise<GetBarAggregateType<T>>

    /**
     * Group by Bar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarGroupByArgs['orderBy'] }
        : { orderBy?: BarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bar model
   */
  readonly fields: BarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offerings<T extends Bar$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Bar$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Bar$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Bar$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analytics<T extends Bar$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clicks<T extends Bar$clicksArgs<ExtArgs> = {}>(args?: Subset<T, Bar$clicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends Bar$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Bar$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    barLicenses<T extends Bar$barLicensesArgs<ExtArgs> = {}>(args?: Subset<T, Bar$barLicensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shiftUsages<T extends Bar$shiftUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Bar$shiftUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Bar$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryImports<T extends Bar$inventoryImportsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$inventoryImportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventorySnapshots<T extends Bar$inventorySnapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$inventorySnapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visits<T extends Bar$visitsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$visitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    varianceAlerts<T extends Bar$varianceAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$varianceAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staticOfferings<T extends Bar$staticOfferingsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$staticOfferingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    drinkSpecials<T extends Bar$drinkSpecialsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$drinkSpecialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    foodOfferings<T extends Bar$foodOfferingsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$foodOfferingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categoryRequests<T extends Bar$categoryRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$categoryRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends Bar$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends Bar$followersArgs<ExtArgs> = {}>(args?: Subset<T, Bar$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    boosts<T extends Bar$boostsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$boostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    barProducts<T extends Bar$barProductsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$barProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryScanSessions<T extends Bar$inventoryScanSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$inventoryScanSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryCounts<T extends Bar$inventoryCountsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$inventoryCountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patronSearchEvents<T extends Bar$patronSearchEventsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$patronSearchEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    barActions<T extends Bar$barActionsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$barActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminNotes<T extends Bar$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, Bar$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends Bar$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Bar$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bar model
   */
  interface BarFieldRefs {
    readonly id: FieldRef<"Bar", 'String'>
    readonly ownerId: FieldRef<"Bar", 'String'>
    readonly name: FieldRef<"Bar", 'String'>
    readonly slug: FieldRef<"Bar", 'String'>
    readonly description: FieldRef<"Bar", 'String'>
    readonly address: FieldRef<"Bar", 'String'>
    readonly city: FieldRef<"Bar", 'String'>
    readonly cityNormalized: FieldRef<"Bar", 'String'>
    readonly state: FieldRef<"Bar", 'String'>
    readonly zipCode: FieldRef<"Bar", 'String'>
    readonly barType: FieldRef<"Bar", 'String'>
    readonly subscriptionTier: FieldRef<"Bar", 'SubscriptionTier'>
    readonly inventoryAddOnEnabled: FieldRef<"Bar", 'Boolean'>
    readonly checkInReward: FieldRef<"Bar", 'String'>
    readonly neighborhood: FieldRef<"Bar", 'String'>
    readonly neighborhoodNormalized: FieldRef<"Bar", 'String'>
    readonly latitude: FieldRef<"Bar", 'Float'>
    readonly longitude: FieldRef<"Bar", 'Float'>
    readonly phone: FieldRef<"Bar", 'String'>
    readonly website: FieldRef<"Bar", 'String'>
    readonly logo: FieldRef<"Bar", 'String'>
    readonly photos: FieldRef<"Bar", 'String[]'>
    readonly hours: FieldRef<"Bar", 'Json'>
    readonly isActive: FieldRef<"Bar", 'Boolean'>
    readonly isPublished: FieldRef<"Bar", 'Boolean'>
    readonly publishedAt: FieldRef<"Bar", 'DateTime'>
    readonly createdAt: FieldRef<"Bar", 'DateTime'>
    readonly updatedAt: FieldRef<"Bar", 'DateTime'>
    readonly profileViews: FieldRef<"Bar", 'Int'>
    readonly searchAppearances: FieldRef<"Bar", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Bar findUnique
   */
  export type BarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * Filter, which Bar to fetch.
     */
    where: BarWhereUniqueInput
  }

  /**
   * Bar findUniqueOrThrow
   */
  export type BarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * Filter, which Bar to fetch.
     */
    where: BarWhereUniqueInput
  }

  /**
   * Bar findFirst
   */
  export type BarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * Filter, which Bar to fetch.
     */
    where?: BarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bars to fetch.
     */
    orderBy?: BarOrderByWithRelationInput | BarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bars.
     */
    cursor?: BarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bars.
     */
    distinct?: BarScalarFieldEnum | BarScalarFieldEnum[]
  }

  /**
   * Bar findFirstOrThrow
   */
  export type BarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * Filter, which Bar to fetch.
     */
    where?: BarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bars to fetch.
     */
    orderBy?: BarOrderByWithRelationInput | BarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bars.
     */
    cursor?: BarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bars.
     */
    distinct?: BarScalarFieldEnum | BarScalarFieldEnum[]
  }

  /**
   * Bar findMany
   */
  export type BarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * Filter, which Bars to fetch.
     */
    where?: BarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bars to fetch.
     */
    orderBy?: BarOrderByWithRelationInput | BarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bars.
     */
    cursor?: BarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bars.
     */
    skip?: number
    distinct?: BarScalarFieldEnum | BarScalarFieldEnum[]
  }

  /**
   * Bar create
   */
  export type BarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * The data needed to create a Bar.
     */
    data: XOR<BarCreateInput, BarUncheckedCreateInput>
  }

  /**
   * Bar createMany
   */
  export type BarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bars.
     */
    data: BarCreateManyInput | BarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bar createManyAndReturn
   */
  export type BarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * The data used to create many Bars.
     */
    data: BarCreateManyInput | BarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bar update
   */
  export type BarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * The data needed to update a Bar.
     */
    data: XOR<BarUpdateInput, BarUncheckedUpdateInput>
    /**
     * Choose, which Bar to update.
     */
    where: BarWhereUniqueInput
  }

  /**
   * Bar updateMany
   */
  export type BarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bars.
     */
    data: XOR<BarUpdateManyMutationInput, BarUncheckedUpdateManyInput>
    /**
     * Filter which Bars to update
     */
    where?: BarWhereInput
    /**
     * Limit how many Bars to update.
     */
    limit?: number
  }

  /**
   * Bar updateManyAndReturn
   */
  export type BarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * The data used to update Bars.
     */
    data: XOR<BarUpdateManyMutationInput, BarUncheckedUpdateManyInput>
    /**
     * Filter which Bars to update
     */
    where?: BarWhereInput
    /**
     * Limit how many Bars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bar upsert
   */
  export type BarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * The filter to search for the Bar to update in case it exists.
     */
    where: BarWhereUniqueInput
    /**
     * In case the Bar found by the `where` argument doesn't exist, create a new Bar with this data.
     */
    create: XOR<BarCreateInput, BarUncheckedCreateInput>
    /**
     * In case the Bar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarUpdateInput, BarUncheckedUpdateInput>
  }

  /**
   * Bar delete
   */
  export type BarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    /**
     * Filter which Bar to delete.
     */
    where: BarWhereUniqueInput
  }

  /**
   * Bar deleteMany
   */
  export type BarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bars to delete
     */
    where?: BarWhereInput
    /**
     * Limit how many Bars to delete.
     */
    limit?: number
  }

  /**
   * Bar.offerings
   */
  export type Bar$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    where?: OfferingWhereInput
    orderBy?: OfferingOrderByWithRelationInput | OfferingOrderByWithRelationInput[]
    cursor?: OfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * Bar.events
   */
  export type Bar$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Bar.favorites
   */
  export type Bar$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Bar.analytics
   */
  export type Bar$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    where?: BarAnalyticsWhereInput
    orderBy?: BarAnalyticsOrderByWithRelationInput | BarAnalyticsOrderByWithRelationInput[]
    cursor?: BarAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarAnalyticsScalarFieldEnum | BarAnalyticsScalarFieldEnum[]
  }

  /**
   * Bar.clicks
   */
  export type Bar$clicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    where?: BarClickWhereInput
    orderBy?: BarClickOrderByWithRelationInput | BarClickOrderByWithRelationInput[]
    cursor?: BarClickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarClickScalarFieldEnum | BarClickScalarFieldEnum[]
  }

  /**
   * Bar.badges
   */
  export type Bar$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    where?: BarBadgeWhereInput
    orderBy?: BarBadgeOrderByWithRelationInput | BarBadgeOrderByWithRelationInput[]
    cursor?: BarBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarBadgeScalarFieldEnum | BarBadgeScalarFieldEnum[]
  }

  /**
   * Bar.barLicenses
   */
  export type Bar$barLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    where?: BarLicenseWhereInput
    orderBy?: BarLicenseOrderByWithRelationInput | BarLicenseOrderByWithRelationInput[]
    cursor?: BarLicenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarLicenseScalarFieldEnum | BarLicenseScalarFieldEnum[]
  }

  /**
   * Bar.shiftUsages
   */
  export type Bar$shiftUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    where?: ShiftUsageWhereInput
    orderBy?: ShiftUsageOrderByWithRelationInput | ShiftUsageOrderByWithRelationInput[]
    cursor?: ShiftUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftUsageScalarFieldEnum | ShiftUsageScalarFieldEnum[]
  }

  /**
   * Bar.inventoryItems
   */
  export type Bar$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Bar.inventoryImports
   */
  export type Bar$inventoryImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    where?: InventoryImportWhereInput
    orderBy?: InventoryImportOrderByWithRelationInput | InventoryImportOrderByWithRelationInput[]
    cursor?: InventoryImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryImportScalarFieldEnum | InventoryImportScalarFieldEnum[]
  }

  /**
   * Bar.inventorySnapshots
   */
  export type Bar$inventorySnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    where?: InventorySnapshotWhereInput
    orderBy?: InventorySnapshotOrderByWithRelationInput | InventorySnapshotOrderByWithRelationInput[]
    cursor?: InventorySnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySnapshotScalarFieldEnum | InventorySnapshotScalarFieldEnum[]
  }

  /**
   * Bar.visits
   */
  export type Bar$visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    where?: BarVisitWhereInput
    orderBy?: BarVisitOrderByWithRelationInput | BarVisitOrderByWithRelationInput[]
    cursor?: BarVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarVisitScalarFieldEnum | BarVisitScalarFieldEnum[]
  }

  /**
   * Bar.varianceAlerts
   */
  export type Bar$varianceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    where?: VarianceAlertWhereInput
    orderBy?: VarianceAlertOrderByWithRelationInput | VarianceAlertOrderByWithRelationInput[]
    cursor?: VarianceAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VarianceAlertScalarFieldEnum | VarianceAlertScalarFieldEnum[]
  }

  /**
   * Bar.staticOfferings
   */
  export type Bar$staticOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    where?: StaticOfferingWhereInput
    orderBy?: StaticOfferingOrderByWithRelationInput | StaticOfferingOrderByWithRelationInput[]
    cursor?: StaticOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaticOfferingScalarFieldEnum | StaticOfferingScalarFieldEnum[]
  }

  /**
   * Bar.drinkSpecials
   */
  export type Bar$drinkSpecialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    where?: DrinkSpecialWhereInput
    orderBy?: DrinkSpecialOrderByWithRelationInput | DrinkSpecialOrderByWithRelationInput[]
    cursor?: DrinkSpecialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DrinkSpecialScalarFieldEnum | DrinkSpecialScalarFieldEnum[]
  }

  /**
   * Bar.foodOfferings
   */
  export type Bar$foodOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    where?: FoodOfferingWhereInput
    orderBy?: FoodOfferingOrderByWithRelationInput | FoodOfferingOrderByWithRelationInput[]
    cursor?: FoodOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodOfferingScalarFieldEnum | FoodOfferingScalarFieldEnum[]
  }

  /**
   * Bar.categoryRequests
   */
  export type Bar$categoryRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    where?: CategoryRequestWhereInput
    orderBy?: CategoryRequestOrderByWithRelationInput | CategoryRequestOrderByWithRelationInput[]
    cursor?: CategoryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryRequestScalarFieldEnum | CategoryRequestScalarFieldEnum[]
  }

  /**
   * Bar.memberships
   */
  export type Bar$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    where?: BarMembershipWhereInput
    orderBy?: BarMembershipOrderByWithRelationInput | BarMembershipOrderByWithRelationInput[]
    cursor?: BarMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarMembershipScalarFieldEnum | BarMembershipScalarFieldEnum[]
  }

  /**
   * Bar.followers
   */
  export type Bar$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    where?: BarFollowerWhereInput
    orderBy?: BarFollowerOrderByWithRelationInput | BarFollowerOrderByWithRelationInput[]
    cursor?: BarFollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarFollowerScalarFieldEnum | BarFollowerScalarFieldEnum[]
  }

  /**
   * Bar.boosts
   */
  export type Bar$boostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    where?: BoostWhereInput
    orderBy?: BoostOrderByWithRelationInput | BoostOrderByWithRelationInput[]
    cursor?: BoostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * Bar.barProducts
   */
  export type Bar$barProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    where?: BarProductWhereInput
    orderBy?: BarProductOrderByWithRelationInput | BarProductOrderByWithRelationInput[]
    cursor?: BarProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarProductScalarFieldEnum | BarProductScalarFieldEnum[]
  }

  /**
   * Bar.inventoryScanSessions
   */
  export type Bar$inventoryScanSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    where?: InventoryScanSessionWhereInput
    orderBy?: InventoryScanSessionOrderByWithRelationInput | InventoryScanSessionOrderByWithRelationInput[]
    cursor?: InventoryScanSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScanSessionScalarFieldEnum | InventoryScanSessionScalarFieldEnum[]
  }

  /**
   * Bar.inventoryCounts
   */
  export type Bar$inventoryCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    where?: InventoryCountWhereInput
    orderBy?: InventoryCountOrderByWithRelationInput | InventoryCountOrderByWithRelationInput[]
    cursor?: InventoryCountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryCountScalarFieldEnum | InventoryCountScalarFieldEnum[]
  }

  /**
   * Bar.patronSearchEvents
   */
  export type Bar$patronSearchEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    where?: PatronSearchEventWhereInput
    orderBy?: PatronSearchEventOrderByWithRelationInput | PatronSearchEventOrderByWithRelationInput[]
    cursor?: PatronSearchEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatronSearchEventScalarFieldEnum | PatronSearchEventScalarFieldEnum[]
  }

  /**
   * Bar.barActions
   */
  export type Bar$barActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    where?: BarActionWhereInput
    orderBy?: BarActionOrderByWithRelationInput | BarActionOrderByWithRelationInput[]
    cursor?: BarActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarActionScalarFieldEnum | BarActionScalarFieldEnum[]
  }

  /**
   * Bar.adminNotes
   */
  export type Bar$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * Bar.supportTickets
   */
  export type Bar$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Bar without action
   */
  export type BarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
  }


  /**
   * Model Offering
   */

  export type AggregateOffering = {
    _count: OfferingCountAggregateOutputType | null
    _avg: OfferingAvgAggregateOutputType | null
    _sum: OfferingSumAggregateOutputType | null
    _min: OfferingMinAggregateOutputType | null
    _max: OfferingMaxAggregateOutputType | null
  }

  export type OfferingAvgAggregateOutputType = {
    dayOfWeek: number | null
    coverCharge: Decimal | null
    ageRestriction: number | null
    clickCount: number | null
  }

  export type OfferingSumAggregateOutputType = {
    dayOfWeek: number | null
    coverCharge: Decimal | null
    ageRestriction: number | null
    clickCount: number | null
  }

  export type OfferingMinAggregateOutputType = {
    id: string | null
    barId: string | null
    dayOfWeek: number | null
    category: string | null
    customTitle: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    recurrence: $Enums.Recurrence | null
    startDate: Date | null
    endDate: Date | null
    coverCharge: Decimal | null
    prize: string | null
    ageRestriction: number | null
    isActive: boolean | null
    isSpecial: boolean | null
    isNew: boolean | null
    specialExpiresAt: Date | null
    newUntil: Date | null
    expiresAt: Date | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferingMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    dayOfWeek: number | null
    category: string | null
    customTitle: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    recurrence: $Enums.Recurrence | null
    startDate: Date | null
    endDate: Date | null
    coverCharge: Decimal | null
    prize: string | null
    ageRestriction: number | null
    isActive: boolean | null
    isSpecial: boolean | null
    isNew: boolean | null
    specialExpiresAt: Date | null
    newUntil: Date | null
    expiresAt: Date | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferingCountAggregateOutputType = {
    id: number
    barId: number
    dayOfWeek: number
    category: number
    customTitle: number
    description: number
    startTime: number
    endTime: number
    recurrence: number
    startDate: number
    endDate: number
    tags: number
    coverCharge: number
    prize: number
    ageRestriction: number
    isActive: number
    isSpecial: number
    isNew: number
    specialExpiresAt: number
    newUntil: number
    expiresAt: number
    clickCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferingAvgAggregateInputType = {
    dayOfWeek?: true
    coverCharge?: true
    ageRestriction?: true
    clickCount?: true
  }

  export type OfferingSumAggregateInputType = {
    dayOfWeek?: true
    coverCharge?: true
    ageRestriction?: true
    clickCount?: true
  }

  export type OfferingMinAggregateInputType = {
    id?: true
    barId?: true
    dayOfWeek?: true
    category?: true
    customTitle?: true
    description?: true
    startTime?: true
    endTime?: true
    recurrence?: true
    startDate?: true
    endDate?: true
    coverCharge?: true
    prize?: true
    ageRestriction?: true
    isActive?: true
    isSpecial?: true
    isNew?: true
    specialExpiresAt?: true
    newUntil?: true
    expiresAt?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferingMaxAggregateInputType = {
    id?: true
    barId?: true
    dayOfWeek?: true
    category?: true
    customTitle?: true
    description?: true
    startTime?: true
    endTime?: true
    recurrence?: true
    startDate?: true
    endDate?: true
    coverCharge?: true
    prize?: true
    ageRestriction?: true
    isActive?: true
    isSpecial?: true
    isNew?: true
    specialExpiresAt?: true
    newUntil?: true
    expiresAt?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferingCountAggregateInputType = {
    id?: true
    barId?: true
    dayOfWeek?: true
    category?: true
    customTitle?: true
    description?: true
    startTime?: true
    endTime?: true
    recurrence?: true
    startDate?: true
    endDate?: true
    tags?: true
    coverCharge?: true
    prize?: true
    ageRestriction?: true
    isActive?: true
    isSpecial?: true
    isNew?: true
    specialExpiresAt?: true
    newUntil?: true
    expiresAt?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offering to aggregate.
     */
    where?: OfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offerings to fetch.
     */
    orderBy?: OfferingOrderByWithRelationInput | OfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offerings
    **/
    _count?: true | OfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferingMaxAggregateInputType
  }

  export type GetOfferingAggregateType<T extends OfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffering[P]>
      : GetScalarType<T[P], AggregateOffering[P]>
  }




  export type OfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferingWhereInput
    orderBy?: OfferingOrderByWithAggregationInput | OfferingOrderByWithAggregationInput[]
    by: OfferingScalarFieldEnum[] | OfferingScalarFieldEnum
    having?: OfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferingCountAggregateInputType | true
    _avg?: OfferingAvgAggregateInputType
    _sum?: OfferingSumAggregateInputType
    _min?: OfferingMinAggregateInputType
    _max?: OfferingMaxAggregateInputType
  }

  export type OfferingGroupByOutputType = {
    id: string
    barId: string
    dayOfWeek: number
    category: string
    customTitle: string | null
    description: string | null
    startTime: string
    endTime: string | null
    recurrence: $Enums.Recurrence
    startDate: Date | null
    endDate: Date | null
    tags: string[]
    coverCharge: Decimal | null
    prize: string | null
    ageRestriction: number | null
    isActive: boolean
    isSpecial: boolean
    isNew: boolean
    specialExpiresAt: Date | null
    newUntil: Date | null
    expiresAt: Date | null
    clickCount: number
    createdAt: Date
    updatedAt: Date
    _count: OfferingCountAggregateOutputType | null
    _avg: OfferingAvgAggregateOutputType | null
    _sum: OfferingSumAggregateOutputType | null
    _min: OfferingMinAggregateOutputType | null
    _max: OfferingMaxAggregateOutputType | null
  }

  type GetOfferingGroupByPayload<T extends OfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferingGroupByOutputType[P]>
            : GetScalarType<T[P], OfferingGroupByOutputType[P]>
        }
      >
    >


  export type OfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    dayOfWeek?: boolean
    category?: boolean
    customTitle?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    recurrence?: boolean
    startDate?: boolean
    endDate?: boolean
    tags?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    expiresAt?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offering"]>

  export type OfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    dayOfWeek?: boolean
    category?: boolean
    customTitle?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    recurrence?: boolean
    startDate?: boolean
    endDate?: boolean
    tags?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    expiresAt?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offering"]>

  export type OfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    dayOfWeek?: boolean
    category?: boolean
    customTitle?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    recurrence?: boolean
    startDate?: boolean
    endDate?: boolean
    tags?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    expiresAt?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offering"]>

  export type OfferingSelectScalar = {
    id?: boolean
    barId?: boolean
    dayOfWeek?: boolean
    category?: boolean
    customTitle?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    recurrence?: boolean
    startDate?: boolean
    endDate?: boolean
    tags?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    expiresAt?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "dayOfWeek" | "category" | "customTitle" | "description" | "startTime" | "endTime" | "recurrence" | "startDate" | "endDate" | "tags" | "coverCharge" | "prize" | "ageRestriction" | "isActive" | "isSpecial" | "isNew" | "specialExpiresAt" | "newUntil" | "expiresAt" | "clickCount" | "createdAt" | "updatedAt", ExtArgs["result"]["offering"]>
  export type OfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type OfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type OfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $OfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offering"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      dayOfWeek: number
      category: string
      customTitle: string | null
      description: string | null
      startTime: string
      endTime: string | null
      recurrence: $Enums.Recurrence
      startDate: Date | null
      endDate: Date | null
      tags: string[]
      coverCharge: Prisma.Decimal | null
      prize: string | null
      ageRestriction: number | null
      isActive: boolean
      isSpecial: boolean
      isNew: boolean
      specialExpiresAt: Date | null
      newUntil: Date | null
      expiresAt: Date | null
      clickCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offering"]>
    composites: {}
  }

  type OfferingGetPayload<S extends boolean | null | undefined | OfferingDefaultArgs> = $Result.GetResult<Prisma.$OfferingPayload, S>

  type OfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferingCountAggregateInputType | true
    }

  export interface OfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offering'], meta: { name: 'Offering' } }
    /**
     * Find zero or one Offering that matches the filter.
     * @param {OfferingFindUniqueArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferingFindUniqueArgs>(args: SelectSubset<T, OfferingFindUniqueArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferingFindUniqueOrThrowArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingFindFirstArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferingFindFirstArgs>(args?: SelectSubset<T, OfferingFindFirstArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingFindFirstOrThrowArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offerings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offerings
     * const offerings = await prisma.offering.findMany()
     * 
     * // Get first 10 Offerings
     * const offerings = await prisma.offering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeringWithIdOnly = await prisma.offering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferingFindManyArgs>(args?: SelectSubset<T, OfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offering.
     * @param {OfferingCreateArgs} args - Arguments to create a Offering.
     * @example
     * // Create one Offering
     * const Offering = await prisma.offering.create({
     *   data: {
     *     // ... data to create a Offering
     *   }
     * })
     * 
     */
    create<T extends OfferingCreateArgs>(args: SelectSubset<T, OfferingCreateArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offerings.
     * @param {OfferingCreateManyArgs} args - Arguments to create many Offerings.
     * @example
     * // Create many Offerings
     * const offering = await prisma.offering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferingCreateManyArgs>(args?: SelectSubset<T, OfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offerings and returns the data saved in the database.
     * @param {OfferingCreateManyAndReturnArgs} args - Arguments to create many Offerings.
     * @example
     * // Create many Offerings
     * const offering = await prisma.offering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offerings and only return the `id`
     * const offeringWithIdOnly = await prisma.offering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Offering.
     * @param {OfferingDeleteArgs} args - Arguments to delete one Offering.
     * @example
     * // Delete one Offering
     * const Offering = await prisma.offering.delete({
     *   where: {
     *     // ... filter to delete one Offering
     *   }
     * })
     * 
     */
    delete<T extends OfferingDeleteArgs>(args: SelectSubset<T, OfferingDeleteArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offering.
     * @param {OfferingUpdateArgs} args - Arguments to update one Offering.
     * @example
     * // Update one Offering
     * const offering = await prisma.offering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferingUpdateArgs>(args: SelectSubset<T, OfferingUpdateArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offerings.
     * @param {OfferingDeleteManyArgs} args - Arguments to filter Offerings to delete.
     * @example
     * // Delete a few Offerings
     * const { count } = await prisma.offering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferingDeleteManyArgs>(args?: SelectSubset<T, OfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offerings
     * const offering = await prisma.offering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferingUpdateManyArgs>(args: SelectSubset<T, OfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offerings and returns the data updated in the database.
     * @param {OfferingUpdateManyAndReturnArgs} args - Arguments to update many Offerings.
     * @example
     * // Update many Offerings
     * const offering = await prisma.offering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Offerings and only return the `id`
     * const offeringWithIdOnly = await prisma.offering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, OfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Offering.
     * @param {OfferingUpsertArgs} args - Arguments to update or create a Offering.
     * @example
     * // Update or create a Offering
     * const offering = await prisma.offering.upsert({
     *   create: {
     *     // ... data to create a Offering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offering we want to update
     *   }
     * })
     */
    upsert<T extends OfferingUpsertArgs>(args: SelectSubset<T, OfferingUpsertArgs<ExtArgs>>): Prisma__OfferingClient<$Result.GetResult<Prisma.$OfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingCountArgs} args - Arguments to filter Offerings to count.
     * @example
     * // Count the number of Offerings
     * const count = await prisma.offering.count({
     *   where: {
     *     // ... the filter for the Offerings we want to count
     *   }
     * })
    **/
    count<T extends OfferingCountArgs>(
      args?: Subset<T, OfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferingAggregateArgs>(args: Subset<T, OfferingAggregateArgs>): Prisma.PrismaPromise<GetOfferingAggregateType<T>>

    /**
     * Group by Offering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferingGroupByArgs['orderBy'] }
        : { orderBy?: OfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offering model
   */
  readonly fields: OfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offering model
   */
  interface OfferingFieldRefs {
    readonly id: FieldRef<"Offering", 'String'>
    readonly barId: FieldRef<"Offering", 'String'>
    readonly dayOfWeek: FieldRef<"Offering", 'Int'>
    readonly category: FieldRef<"Offering", 'String'>
    readonly customTitle: FieldRef<"Offering", 'String'>
    readonly description: FieldRef<"Offering", 'String'>
    readonly startTime: FieldRef<"Offering", 'String'>
    readonly endTime: FieldRef<"Offering", 'String'>
    readonly recurrence: FieldRef<"Offering", 'Recurrence'>
    readonly startDate: FieldRef<"Offering", 'DateTime'>
    readonly endDate: FieldRef<"Offering", 'DateTime'>
    readonly tags: FieldRef<"Offering", 'String[]'>
    readonly coverCharge: FieldRef<"Offering", 'Decimal'>
    readonly prize: FieldRef<"Offering", 'String'>
    readonly ageRestriction: FieldRef<"Offering", 'Int'>
    readonly isActive: FieldRef<"Offering", 'Boolean'>
    readonly isSpecial: FieldRef<"Offering", 'Boolean'>
    readonly isNew: FieldRef<"Offering", 'Boolean'>
    readonly specialExpiresAt: FieldRef<"Offering", 'DateTime'>
    readonly newUntil: FieldRef<"Offering", 'DateTime'>
    readonly expiresAt: FieldRef<"Offering", 'DateTime'>
    readonly clickCount: FieldRef<"Offering", 'Int'>
    readonly createdAt: FieldRef<"Offering", 'DateTime'>
    readonly updatedAt: FieldRef<"Offering", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offering findUnique
   */
  export type OfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * Filter, which Offering to fetch.
     */
    where: OfferingWhereUniqueInput
  }

  /**
   * Offering findUniqueOrThrow
   */
  export type OfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * Filter, which Offering to fetch.
     */
    where: OfferingWhereUniqueInput
  }

  /**
   * Offering findFirst
   */
  export type OfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * Filter, which Offering to fetch.
     */
    where?: OfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offerings to fetch.
     */
    orderBy?: OfferingOrderByWithRelationInput | OfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offerings.
     */
    cursor?: OfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offerings.
     */
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * Offering findFirstOrThrow
   */
  export type OfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * Filter, which Offering to fetch.
     */
    where?: OfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offerings to fetch.
     */
    orderBy?: OfferingOrderByWithRelationInput | OfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offerings.
     */
    cursor?: OfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offerings.
     */
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * Offering findMany
   */
  export type OfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * Filter, which Offerings to fetch.
     */
    where?: OfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offerings to fetch.
     */
    orderBy?: OfferingOrderByWithRelationInput | OfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offerings.
     */
    cursor?: OfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offerings.
     */
    skip?: number
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * Offering create
   */
  export type OfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a Offering.
     */
    data: XOR<OfferingCreateInput, OfferingUncheckedCreateInput>
  }

  /**
   * Offering createMany
   */
  export type OfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offerings.
     */
    data: OfferingCreateManyInput | OfferingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offering createManyAndReturn
   */
  export type OfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * The data used to create many Offerings.
     */
    data: OfferingCreateManyInput | OfferingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offering update
   */
  export type OfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a Offering.
     */
    data: XOR<OfferingUpdateInput, OfferingUncheckedUpdateInput>
    /**
     * Choose, which Offering to update.
     */
    where: OfferingWhereUniqueInput
  }

  /**
   * Offering updateMany
   */
  export type OfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offerings.
     */
    data: XOR<OfferingUpdateManyMutationInput, OfferingUncheckedUpdateManyInput>
    /**
     * Filter which Offerings to update
     */
    where?: OfferingWhereInput
    /**
     * Limit how many Offerings to update.
     */
    limit?: number
  }

  /**
   * Offering updateManyAndReturn
   */
  export type OfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * The data used to update Offerings.
     */
    data: XOR<OfferingUpdateManyMutationInput, OfferingUncheckedUpdateManyInput>
    /**
     * Filter which Offerings to update
     */
    where?: OfferingWhereInput
    /**
     * Limit how many Offerings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offering upsert
   */
  export type OfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the Offering to update in case it exists.
     */
    where: OfferingWhereUniqueInput
    /**
     * In case the Offering found by the `where` argument doesn't exist, create a new Offering with this data.
     */
    create: XOR<OfferingCreateInput, OfferingUncheckedCreateInput>
    /**
     * In case the Offering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferingUpdateInput, OfferingUncheckedUpdateInput>
  }

  /**
   * Offering delete
   */
  export type OfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
    /**
     * Filter which Offering to delete.
     */
    where: OfferingWhereUniqueInput
  }

  /**
   * Offering deleteMany
   */
  export type OfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offerings to delete
     */
    where?: OfferingWhereInput
    /**
     * Limit how many Offerings to delete.
     */
    limit?: number
  }

  /**
   * Offering without action
   */
  export type OfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering
     */
    select?: OfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Offering
     */
    omit?: OfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferingInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    coverCharge: Decimal | null
    ageRestriction: number | null
    clickCount: number | null
  }

  export type EventSumAggregateOutputType = {
    coverCharge: Decimal | null
    ageRestriction: number | null
    clickCount: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    barId: string | null
    title: string | null
    description: string | null
    category: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    isRecurring: boolean | null
    recurrenceRule: string | null
    recurrence: $Enums.Recurrence | null
    isActive: boolean | null
    isSpecial: boolean | null
    isNew: boolean | null
    specialExpiresAt: Date | null
    newUntil: Date | null
    autoExpire: boolean | null
    coverCharge: Decimal | null
    prize: string | null
    ageRestriction: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    title: string | null
    description: string | null
    category: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    isRecurring: boolean | null
    recurrenceRule: string | null
    recurrence: $Enums.Recurrence | null
    isActive: boolean | null
    isSpecial: boolean | null
    isNew: boolean | null
    specialExpiresAt: Date | null
    newUntil: Date | null
    autoExpire: boolean | null
    coverCharge: Decimal | null
    prize: string | null
    ageRestriction: number | null
    clickCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    barId: number
    title: number
    description: number
    category: number
    startDate: number
    endDate: number
    startTime: number
    endTime: number
    isRecurring: number
    recurrenceRule: number
    recurrence: number
    tags: number
    isActive: number
    isSpecial: number
    isNew: number
    specialExpiresAt: number
    newUntil: number
    autoExpire: number
    coverCharge: number
    prize: number
    ageRestriction: number
    clickCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    coverCharge?: true
    ageRestriction?: true
    clickCount?: true
  }

  export type EventSumAggregateInputType = {
    coverCharge?: true
    ageRestriction?: true
    clickCount?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    barId?: true
    title?: true
    description?: true
    category?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    isRecurring?: true
    recurrenceRule?: true
    recurrence?: true
    isActive?: true
    isSpecial?: true
    isNew?: true
    specialExpiresAt?: true
    newUntil?: true
    autoExpire?: true
    coverCharge?: true
    prize?: true
    ageRestriction?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    barId?: true
    title?: true
    description?: true
    category?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    isRecurring?: true
    recurrenceRule?: true
    recurrence?: true
    isActive?: true
    isSpecial?: true
    isNew?: true
    specialExpiresAt?: true
    newUntil?: true
    autoExpire?: true
    coverCharge?: true
    prize?: true
    ageRestriction?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    barId?: true
    title?: true
    description?: true
    category?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    isRecurring?: true
    recurrenceRule?: true
    recurrence?: true
    tags?: true
    isActive?: true
    isSpecial?: true
    isNew?: true
    specialExpiresAt?: true
    newUntil?: true
    autoExpire?: true
    coverCharge?: true
    prize?: true
    ageRestriction?: true
    clickCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    barId: string
    title: string
    description: string | null
    category: string | null
    startDate: Date
    endDate: Date | null
    startTime: string
    endTime: string | null
    isRecurring: boolean
    recurrenceRule: string | null
    recurrence: $Enums.Recurrence | null
    tags: string[]
    isActive: boolean
    isSpecial: boolean
    isNew: boolean
    specialExpiresAt: Date | null
    newUntil: Date | null
    autoExpire: boolean
    coverCharge: Decimal | null
    prize: string | null
    ageRestriction: number | null
    clickCount: number
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    recurrence?: boolean
    tags?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    autoExpire?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    recurrence?: boolean
    tags?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    autoExpire?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    recurrence?: boolean
    tags?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    autoExpire?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    barId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    recurrence?: boolean
    tags?: boolean
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: boolean
    newUntil?: boolean
    autoExpire?: boolean
    coverCharge?: boolean
    prize?: boolean
    ageRestriction?: boolean
    clickCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "title" | "description" | "category" | "startDate" | "endDate" | "startTime" | "endTime" | "isRecurring" | "recurrenceRule" | "recurrence" | "tags" | "isActive" | "isSpecial" | "isNew" | "specialExpiresAt" | "newUntil" | "autoExpire" | "coverCharge" | "prize" | "ageRestriction" | "clickCount" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      title: string
      description: string | null
      category: string | null
      startDate: Date
      endDate: Date | null
      startTime: string
      endTime: string | null
      isRecurring: boolean
      recurrenceRule: string | null
      recurrence: $Enums.Recurrence | null
      tags: string[]
      isActive: boolean
      isSpecial: boolean
      isNew: boolean
      specialExpiresAt: Date | null
      newUntil: Date | null
      autoExpire: boolean
      coverCharge: Prisma.Decimal | null
      prize: string | null
      ageRestriction: number | null
      clickCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly barId: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly category: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly startTime: FieldRef<"Event", 'String'>
    readonly endTime: FieldRef<"Event", 'String'>
    readonly isRecurring: FieldRef<"Event", 'Boolean'>
    readonly recurrenceRule: FieldRef<"Event", 'String'>
    readonly recurrence: FieldRef<"Event", 'Recurrence'>
    readonly tags: FieldRef<"Event", 'String[]'>
    readonly isActive: FieldRef<"Event", 'Boolean'>
    readonly isSpecial: FieldRef<"Event", 'Boolean'>
    readonly isNew: FieldRef<"Event", 'Boolean'>
    readonly specialExpiresAt: FieldRef<"Event", 'DateTime'>
    readonly newUntil: FieldRef<"Event", 'DateTime'>
    readonly autoExpire: FieldRef<"Event", 'Boolean'>
    readonly coverCharge: FieldRef<"Event", 'Decimal'>
    readonly prize: FieldRef<"Event", 'String'>
    readonly ageRestriction: FieldRef<"Event", 'Int'>
    readonly clickCount: FieldRef<"Event", 'Int'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    barId: string | null
    createdAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    barId: string | null
    createdAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userId: number
    barId: number
    createdAt: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    barId?: true
    createdAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    barId?: true
    createdAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    barId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    userId: string
    barId: string
    createdAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    barId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    barId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    barId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    barId?: boolean
    createdAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "barId" | "createdAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      barId: string
      createdAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly barId: FieldRef<"Favorite", 'String'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model ActivityCategory
   */

  export type AggregateActivityCategory = {
    _count: ActivityCategoryCountAggregateOutputType | null
    _avg: ActivityCategoryAvgAggregateOutputType | null
    _sum: ActivityCategorySumAggregateOutputType | null
    _min: ActivityCategoryMinAggregateOutputType | null
    _max: ActivityCategoryMaxAggregateOutputType | null
  }

  export type ActivityCategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ActivityCategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ActivityCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    icon: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ActivityCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    icon: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ActivityCategoryCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    icon: number
    sortOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ActivityCategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ActivityCategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type ActivityCategoryMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    icon?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type ActivityCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    icon?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type ActivityCategoryCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    icon?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityCategory to aggregate.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityCategories
    **/
    _count?: true | ActivityCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityCategoryMaxAggregateInputType
  }

  export type GetActivityCategoryAggregateType<T extends ActivityCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityCategory[P]>
      : GetScalarType<T[P], AggregateActivityCategory[P]>
  }




  export type ActivityCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityCategoryWhereInput
    orderBy?: ActivityCategoryOrderByWithAggregationInput | ActivityCategoryOrderByWithAggregationInput[]
    by: ActivityCategoryScalarFieldEnum[] | ActivityCategoryScalarFieldEnum
    having?: ActivityCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCategoryCountAggregateInputType | true
    _avg?: ActivityCategoryAvgAggregateInputType
    _sum?: ActivityCategorySumAggregateInputType
    _min?: ActivityCategoryMinAggregateInputType
    _max?: ActivityCategoryMaxAggregateInputType
  }

  export type ActivityCategoryGroupByOutputType = {
    id: string
    name: string
    displayName: string
    icon: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    _count: ActivityCategoryCountAggregateOutputType | null
    _avg: ActivityCategoryAvgAggregateOutputType | null
    _sum: ActivityCategorySumAggregateOutputType | null
    _min: ActivityCategoryMinAggregateOutputType | null
    _max: ActivityCategoryMaxAggregateOutputType | null
  }

  type GetActivityCategoryGroupByPayload<T extends ActivityCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ActivityCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    icon?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityCategory"]>

  export type ActivityCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    icon?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityCategory"]>

  export type ActivityCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    icon?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityCategory"]>

  export type ActivityCategorySelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    icon?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ActivityCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "icon" | "sortOrder" | "isActive" | "createdAt", ExtArgs["result"]["activityCategory"]>

  export type $ActivityCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityCategory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      icon: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["activityCategory"]>
    composites: {}
  }

  type ActivityCategoryGetPayload<S extends boolean | null | undefined | ActivityCategoryDefaultArgs> = $Result.GetResult<Prisma.$ActivityCategoryPayload, S>

  type ActivityCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCategoryCountAggregateInputType | true
    }

  export interface ActivityCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityCategory'], meta: { name: 'ActivityCategory' } }
    /**
     * Find zero or one ActivityCategory that matches the filter.
     * @param {ActivityCategoryFindUniqueArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityCategoryFindUniqueArgs>(args: SelectSubset<T, ActivityCategoryFindUniqueArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityCategoryFindUniqueOrThrowArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryFindFirstArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityCategoryFindFirstArgs>(args?: SelectSubset<T, ActivityCategoryFindFirstArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryFindFirstOrThrowArgs} args - Arguments to find a ActivityCategory
     * @example
     * // Get one ActivityCategory
     * const activityCategory = await prisma.activityCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityCategories
     * const activityCategories = await prisma.activityCategory.findMany()
     * 
     * // Get first 10 ActivityCategories
     * const activityCategories = await prisma.activityCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityCategoryFindManyArgs>(args?: SelectSubset<T, ActivityCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityCategory.
     * @param {ActivityCategoryCreateArgs} args - Arguments to create a ActivityCategory.
     * @example
     * // Create one ActivityCategory
     * const ActivityCategory = await prisma.activityCategory.create({
     *   data: {
     *     // ... data to create a ActivityCategory
     *   }
     * })
     * 
     */
    create<T extends ActivityCategoryCreateArgs>(args: SelectSubset<T, ActivityCategoryCreateArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityCategories.
     * @param {ActivityCategoryCreateManyArgs} args - Arguments to create many ActivityCategories.
     * @example
     * // Create many ActivityCategories
     * const activityCategory = await prisma.activityCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCategoryCreateManyArgs>(args?: SelectSubset<T, ActivityCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityCategories and returns the data saved in the database.
     * @param {ActivityCategoryCreateManyAndReturnArgs} args - Arguments to create many ActivityCategories.
     * @example
     * // Create many ActivityCategories
     * const activityCategory = await prisma.activityCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityCategories and only return the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityCategory.
     * @param {ActivityCategoryDeleteArgs} args - Arguments to delete one ActivityCategory.
     * @example
     * // Delete one ActivityCategory
     * const ActivityCategory = await prisma.activityCategory.delete({
     *   where: {
     *     // ... filter to delete one ActivityCategory
     *   }
     * })
     * 
     */
    delete<T extends ActivityCategoryDeleteArgs>(args: SelectSubset<T, ActivityCategoryDeleteArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityCategory.
     * @param {ActivityCategoryUpdateArgs} args - Arguments to update one ActivityCategory.
     * @example
     * // Update one ActivityCategory
     * const activityCategory = await prisma.activityCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityCategoryUpdateArgs>(args: SelectSubset<T, ActivityCategoryUpdateArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityCategories.
     * @param {ActivityCategoryDeleteManyArgs} args - Arguments to filter ActivityCategories to delete.
     * @example
     * // Delete a few ActivityCategories
     * const { count } = await prisma.activityCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityCategoryDeleteManyArgs>(args?: SelectSubset<T, ActivityCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityCategories
     * const activityCategory = await prisma.activityCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityCategoryUpdateManyArgs>(args: SelectSubset<T, ActivityCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityCategories and returns the data updated in the database.
     * @param {ActivityCategoryUpdateManyAndReturnArgs} args - Arguments to update many ActivityCategories.
     * @example
     * // Update many ActivityCategories
     * const activityCategory = await prisma.activityCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityCategories and only return the `id`
     * const activityCategoryWithIdOnly = await prisma.activityCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityCategory.
     * @param {ActivityCategoryUpsertArgs} args - Arguments to update or create a ActivityCategory.
     * @example
     * // Update or create a ActivityCategory
     * const activityCategory = await prisma.activityCategory.upsert({
     *   create: {
     *     // ... data to create a ActivityCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityCategory we want to update
     *   }
     * })
     */
    upsert<T extends ActivityCategoryUpsertArgs>(args: SelectSubset<T, ActivityCategoryUpsertArgs<ExtArgs>>): Prisma__ActivityCategoryClient<$Result.GetResult<Prisma.$ActivityCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryCountArgs} args - Arguments to filter ActivityCategories to count.
     * @example
     * // Count the number of ActivityCategories
     * const count = await prisma.activityCategory.count({
     *   where: {
     *     // ... the filter for the ActivityCategories we want to count
     *   }
     * })
    **/
    count<T extends ActivityCategoryCountArgs>(
      args?: Subset<T, ActivityCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityCategoryAggregateArgs>(args: Subset<T, ActivityCategoryAggregateArgs>): Prisma.PrismaPromise<GetActivityCategoryAggregateType<T>>

    /**
     * Group by ActivityCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ActivityCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityCategory model
   */
  readonly fields: ActivityCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityCategory model
   */
  interface ActivityCategoryFieldRefs {
    readonly id: FieldRef<"ActivityCategory", 'String'>
    readonly name: FieldRef<"ActivityCategory", 'String'>
    readonly displayName: FieldRef<"ActivityCategory", 'String'>
    readonly icon: FieldRef<"ActivityCategory", 'String'>
    readonly sortOrder: FieldRef<"ActivityCategory", 'Int'>
    readonly isActive: FieldRef<"ActivityCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ActivityCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityCategory findUnique
   */
  export type ActivityCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory findUniqueOrThrow
   */
  export type ActivityCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory findFirst
   */
  export type ActivityCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityCategories.
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityCategories.
     */
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * ActivityCategory findFirstOrThrow
   */
  export type ActivityCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * Filter, which ActivityCategory to fetch.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityCategories.
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityCategories.
     */
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * ActivityCategory findMany
   */
  export type ActivityCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * Filter, which ActivityCategories to fetch.
     */
    where?: ActivityCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityCategories to fetch.
     */
    orderBy?: ActivityCategoryOrderByWithRelationInput | ActivityCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityCategories.
     */
    cursor?: ActivityCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityCategories.
     */
    skip?: number
    distinct?: ActivityCategoryScalarFieldEnum | ActivityCategoryScalarFieldEnum[]
  }

  /**
   * ActivityCategory create
   */
  export type ActivityCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * The data needed to create a ActivityCategory.
     */
    data: XOR<ActivityCategoryCreateInput, ActivityCategoryUncheckedCreateInput>
  }

  /**
   * ActivityCategory createMany
   */
  export type ActivityCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityCategories.
     */
    data: ActivityCategoryCreateManyInput | ActivityCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityCategory createManyAndReturn
   */
  export type ActivityCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityCategories.
     */
    data: ActivityCategoryCreateManyInput | ActivityCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityCategory update
   */
  export type ActivityCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * The data needed to update a ActivityCategory.
     */
    data: XOR<ActivityCategoryUpdateInput, ActivityCategoryUncheckedUpdateInput>
    /**
     * Choose, which ActivityCategory to update.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory updateMany
   */
  export type ActivityCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityCategories.
     */
    data: XOR<ActivityCategoryUpdateManyMutationInput, ActivityCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ActivityCategories to update
     */
    where?: ActivityCategoryWhereInput
    /**
     * Limit how many ActivityCategories to update.
     */
    limit?: number
  }

  /**
   * ActivityCategory updateManyAndReturn
   */
  export type ActivityCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ActivityCategories.
     */
    data: XOR<ActivityCategoryUpdateManyMutationInput, ActivityCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ActivityCategories to update
     */
    where?: ActivityCategoryWhereInput
    /**
     * Limit how many ActivityCategories to update.
     */
    limit?: number
  }

  /**
   * ActivityCategory upsert
   */
  export type ActivityCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * The filter to search for the ActivityCategory to update in case it exists.
     */
    where: ActivityCategoryWhereUniqueInput
    /**
     * In case the ActivityCategory found by the `where` argument doesn't exist, create a new ActivityCategory with this data.
     */
    create: XOR<ActivityCategoryCreateInput, ActivityCategoryUncheckedCreateInput>
    /**
     * In case the ActivityCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityCategoryUpdateInput, ActivityCategoryUncheckedUpdateInput>
  }

  /**
   * ActivityCategory delete
   */
  export type ActivityCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
    /**
     * Filter which ActivityCategory to delete.
     */
    where: ActivityCategoryWhereUniqueInput
  }

  /**
   * ActivityCategory deleteMany
   */
  export type ActivityCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityCategories to delete
     */
    where?: ActivityCategoryWhereInput
    /**
     * Limit how many ActivityCategories to delete.
     */
    limit?: number
  }

  /**
   * ActivityCategory without action
   */
  export type ActivityCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCategory
     */
    select?: ActivityCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityCategory
     */
    omit?: ActivityCategoryOmit<ExtArgs> | null
  }


  /**
   * Model CategoryRequest
   */

  export type AggregateCategoryRequest = {
    _count: CategoryRequestCountAggregateOutputType | null
    _min: CategoryRequestMinAggregateOutputType | null
    _max: CategoryRequestMaxAggregateOutputType | null
  }

  export type CategoryRequestMinAggregateOutputType = {
    id: string | null
    barId: string | null
    ownerId: string | null
    requestedByEmail: string | null
    requestedByName: string | null
    category: string | null
    status: $Enums.CategoryRequestStatus | null
    reviewedAt: Date | null
    reviewedByEmail: string | null
    createdAt: Date | null
  }

  export type CategoryRequestMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    ownerId: string | null
    requestedByEmail: string | null
    requestedByName: string | null
    category: string | null
    status: $Enums.CategoryRequestStatus | null
    reviewedAt: Date | null
    reviewedByEmail: string | null
    createdAt: Date | null
  }

  export type CategoryRequestCountAggregateOutputType = {
    id: number
    barId: number
    ownerId: number
    requestedByEmail: number
    requestedByName: number
    category: number
    status: number
    reviewedAt: number
    reviewedByEmail: number
    createdAt: number
    _all: number
  }


  export type CategoryRequestMinAggregateInputType = {
    id?: true
    barId?: true
    ownerId?: true
    requestedByEmail?: true
    requestedByName?: true
    category?: true
    status?: true
    reviewedAt?: true
    reviewedByEmail?: true
    createdAt?: true
  }

  export type CategoryRequestMaxAggregateInputType = {
    id?: true
    barId?: true
    ownerId?: true
    requestedByEmail?: true
    requestedByName?: true
    category?: true
    status?: true
    reviewedAt?: true
    reviewedByEmail?: true
    createdAt?: true
  }

  export type CategoryRequestCountAggregateInputType = {
    id?: true
    barId?: true
    ownerId?: true
    requestedByEmail?: true
    requestedByName?: true
    category?: true
    status?: true
    reviewedAt?: true
    reviewedByEmail?: true
    createdAt?: true
    _all?: true
  }

  export type CategoryRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryRequest to aggregate.
     */
    where?: CategoryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryRequests to fetch.
     */
    orderBy?: CategoryRequestOrderByWithRelationInput | CategoryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryRequests
    **/
    _count?: true | CategoryRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryRequestMaxAggregateInputType
  }

  export type GetCategoryRequestAggregateType<T extends CategoryRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryRequest[P]>
      : GetScalarType<T[P], AggregateCategoryRequest[P]>
  }




  export type CategoryRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryRequestWhereInput
    orderBy?: CategoryRequestOrderByWithAggregationInput | CategoryRequestOrderByWithAggregationInput[]
    by: CategoryRequestScalarFieldEnum[] | CategoryRequestScalarFieldEnum
    having?: CategoryRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryRequestCountAggregateInputType | true
    _min?: CategoryRequestMinAggregateInputType
    _max?: CategoryRequestMaxAggregateInputType
  }

  export type CategoryRequestGroupByOutputType = {
    id: string
    barId: string
    ownerId: string
    requestedByEmail: string
    requestedByName: string | null
    category: string
    status: $Enums.CategoryRequestStatus
    reviewedAt: Date | null
    reviewedByEmail: string | null
    createdAt: Date
    _count: CategoryRequestCountAggregateOutputType | null
    _min: CategoryRequestMinAggregateOutputType | null
    _max: CategoryRequestMaxAggregateOutputType | null
  }

  type GetCategoryRequestGroupByPayload<T extends CategoryRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryRequestGroupByOutputType[P]>
        }
      >
    >


  export type CategoryRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    requestedByEmail?: boolean
    requestedByName?: boolean
    category?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedByEmail?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryRequest"]>

  export type CategoryRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    requestedByEmail?: boolean
    requestedByName?: boolean
    category?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedByEmail?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryRequest"]>

  export type CategoryRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    requestedByEmail?: boolean
    requestedByName?: boolean
    category?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedByEmail?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryRequest"]>

  export type CategoryRequestSelectScalar = {
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    requestedByEmail?: boolean
    requestedByName?: boolean
    category?: boolean
    status?: boolean
    reviewedAt?: boolean
    reviewedByEmail?: boolean
    createdAt?: boolean
  }

  export type CategoryRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "ownerId" | "requestedByEmail" | "requestedByName" | "category" | "status" | "reviewedAt" | "reviewedByEmail" | "createdAt", ExtArgs["result"]["categoryRequest"]>
  export type CategoryRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type CategoryRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type CategoryRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $CategoryRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryRequest"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      ownerId: string
      requestedByEmail: string
      requestedByName: string | null
      category: string
      status: $Enums.CategoryRequestStatus
      reviewedAt: Date | null
      reviewedByEmail: string | null
      createdAt: Date
    }, ExtArgs["result"]["categoryRequest"]>
    composites: {}
  }

  type CategoryRequestGetPayload<S extends boolean | null | undefined | CategoryRequestDefaultArgs> = $Result.GetResult<Prisma.$CategoryRequestPayload, S>

  type CategoryRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryRequestCountAggregateInputType | true
    }

  export interface CategoryRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryRequest'], meta: { name: 'CategoryRequest' } }
    /**
     * Find zero or one CategoryRequest that matches the filter.
     * @param {CategoryRequestFindUniqueArgs} args - Arguments to find a CategoryRequest
     * @example
     * // Get one CategoryRequest
     * const categoryRequest = await prisma.categoryRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryRequestFindUniqueArgs>(args: SelectSubset<T, CategoryRequestFindUniqueArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoryRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryRequestFindUniqueOrThrowArgs} args - Arguments to find a CategoryRequest
     * @example
     * // Get one CategoryRequest
     * const categoryRequest = await prisma.categoryRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestFindFirstArgs} args - Arguments to find a CategoryRequest
     * @example
     * // Get one CategoryRequest
     * const categoryRequest = await prisma.categoryRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryRequestFindFirstArgs>(args?: SelectSubset<T, CategoryRequestFindFirstArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestFindFirstOrThrowArgs} args - Arguments to find a CategoryRequest
     * @example
     * // Get one CategoryRequest
     * const categoryRequest = await prisma.categoryRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoryRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryRequests
     * const categoryRequests = await prisma.categoryRequest.findMany()
     * 
     * // Get first 10 CategoryRequests
     * const categoryRequests = await prisma.categoryRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryRequestWithIdOnly = await prisma.categoryRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryRequestFindManyArgs>(args?: SelectSubset<T, CategoryRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoryRequest.
     * @param {CategoryRequestCreateArgs} args - Arguments to create a CategoryRequest.
     * @example
     * // Create one CategoryRequest
     * const CategoryRequest = await prisma.categoryRequest.create({
     *   data: {
     *     // ... data to create a CategoryRequest
     *   }
     * })
     * 
     */
    create<T extends CategoryRequestCreateArgs>(args: SelectSubset<T, CategoryRequestCreateArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoryRequests.
     * @param {CategoryRequestCreateManyArgs} args - Arguments to create many CategoryRequests.
     * @example
     * // Create many CategoryRequests
     * const categoryRequest = await prisma.categoryRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryRequestCreateManyArgs>(args?: SelectSubset<T, CategoryRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryRequests and returns the data saved in the database.
     * @param {CategoryRequestCreateManyAndReturnArgs} args - Arguments to create many CategoryRequests.
     * @example
     * // Create many CategoryRequests
     * const categoryRequest = await prisma.categoryRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryRequests and only return the `id`
     * const categoryRequestWithIdOnly = await prisma.categoryRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoryRequest.
     * @param {CategoryRequestDeleteArgs} args - Arguments to delete one CategoryRequest.
     * @example
     * // Delete one CategoryRequest
     * const CategoryRequest = await prisma.categoryRequest.delete({
     *   where: {
     *     // ... filter to delete one CategoryRequest
     *   }
     * })
     * 
     */
    delete<T extends CategoryRequestDeleteArgs>(args: SelectSubset<T, CategoryRequestDeleteArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoryRequest.
     * @param {CategoryRequestUpdateArgs} args - Arguments to update one CategoryRequest.
     * @example
     * // Update one CategoryRequest
     * const categoryRequest = await prisma.categoryRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryRequestUpdateArgs>(args: SelectSubset<T, CategoryRequestUpdateArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoryRequests.
     * @param {CategoryRequestDeleteManyArgs} args - Arguments to filter CategoryRequests to delete.
     * @example
     * // Delete a few CategoryRequests
     * const { count } = await prisma.categoryRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryRequestDeleteManyArgs>(args?: SelectSubset<T, CategoryRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryRequests
     * const categoryRequest = await prisma.categoryRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryRequestUpdateManyArgs>(args: SelectSubset<T, CategoryRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryRequests and returns the data updated in the database.
     * @param {CategoryRequestUpdateManyAndReturnArgs} args - Arguments to update many CategoryRequests.
     * @example
     * // Update many CategoryRequests
     * const categoryRequest = await prisma.categoryRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoryRequests and only return the `id`
     * const categoryRequestWithIdOnly = await prisma.categoryRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoryRequest.
     * @param {CategoryRequestUpsertArgs} args - Arguments to update or create a CategoryRequest.
     * @example
     * // Update or create a CategoryRequest
     * const categoryRequest = await prisma.categoryRequest.upsert({
     *   create: {
     *     // ... data to create a CategoryRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryRequest we want to update
     *   }
     * })
     */
    upsert<T extends CategoryRequestUpsertArgs>(args: SelectSubset<T, CategoryRequestUpsertArgs<ExtArgs>>): Prisma__CategoryRequestClient<$Result.GetResult<Prisma.$CategoryRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestCountArgs} args - Arguments to filter CategoryRequests to count.
     * @example
     * // Count the number of CategoryRequests
     * const count = await prisma.categoryRequest.count({
     *   where: {
     *     // ... the filter for the CategoryRequests we want to count
     *   }
     * })
    **/
    count<T extends CategoryRequestCountArgs>(
      args?: Subset<T, CategoryRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryRequestAggregateArgs>(args: Subset<T, CategoryRequestAggregateArgs>): Prisma.PrismaPromise<GetCategoryRequestAggregateType<T>>

    /**
     * Group by CategoryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryRequestGroupByArgs['orderBy'] }
        : { orderBy?: CategoryRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryRequest model
   */
  readonly fields: CategoryRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryRequest model
   */
  interface CategoryRequestFieldRefs {
    readonly id: FieldRef<"CategoryRequest", 'String'>
    readonly barId: FieldRef<"CategoryRequest", 'String'>
    readonly ownerId: FieldRef<"CategoryRequest", 'String'>
    readonly requestedByEmail: FieldRef<"CategoryRequest", 'String'>
    readonly requestedByName: FieldRef<"CategoryRequest", 'String'>
    readonly category: FieldRef<"CategoryRequest", 'String'>
    readonly status: FieldRef<"CategoryRequest", 'CategoryRequestStatus'>
    readonly reviewedAt: FieldRef<"CategoryRequest", 'DateTime'>
    readonly reviewedByEmail: FieldRef<"CategoryRequest", 'String'>
    readonly createdAt: FieldRef<"CategoryRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoryRequest findUnique
   */
  export type CategoryRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * Filter, which CategoryRequest to fetch.
     */
    where: CategoryRequestWhereUniqueInput
  }

  /**
   * CategoryRequest findUniqueOrThrow
   */
  export type CategoryRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * Filter, which CategoryRequest to fetch.
     */
    where: CategoryRequestWhereUniqueInput
  }

  /**
   * CategoryRequest findFirst
   */
  export type CategoryRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * Filter, which CategoryRequest to fetch.
     */
    where?: CategoryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryRequests to fetch.
     */
    orderBy?: CategoryRequestOrderByWithRelationInput | CategoryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryRequests.
     */
    cursor?: CategoryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryRequests.
     */
    distinct?: CategoryRequestScalarFieldEnum | CategoryRequestScalarFieldEnum[]
  }

  /**
   * CategoryRequest findFirstOrThrow
   */
  export type CategoryRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * Filter, which CategoryRequest to fetch.
     */
    where?: CategoryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryRequests to fetch.
     */
    orderBy?: CategoryRequestOrderByWithRelationInput | CategoryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryRequests.
     */
    cursor?: CategoryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryRequests.
     */
    distinct?: CategoryRequestScalarFieldEnum | CategoryRequestScalarFieldEnum[]
  }

  /**
   * CategoryRequest findMany
   */
  export type CategoryRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * Filter, which CategoryRequests to fetch.
     */
    where?: CategoryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryRequests to fetch.
     */
    orderBy?: CategoryRequestOrderByWithRelationInput | CategoryRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryRequests.
     */
    cursor?: CategoryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryRequests.
     */
    skip?: number
    distinct?: CategoryRequestScalarFieldEnum | CategoryRequestScalarFieldEnum[]
  }

  /**
   * CategoryRequest create
   */
  export type CategoryRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryRequest.
     */
    data: XOR<CategoryRequestCreateInput, CategoryRequestUncheckedCreateInput>
  }

  /**
   * CategoryRequest createMany
   */
  export type CategoryRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryRequests.
     */
    data: CategoryRequestCreateManyInput | CategoryRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryRequest createManyAndReturn
   */
  export type CategoryRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * The data used to create many CategoryRequests.
     */
    data: CategoryRequestCreateManyInput | CategoryRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryRequest update
   */
  export type CategoryRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryRequest.
     */
    data: XOR<CategoryRequestUpdateInput, CategoryRequestUncheckedUpdateInput>
    /**
     * Choose, which CategoryRequest to update.
     */
    where: CategoryRequestWhereUniqueInput
  }

  /**
   * CategoryRequest updateMany
   */
  export type CategoryRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryRequests.
     */
    data: XOR<CategoryRequestUpdateManyMutationInput, CategoryRequestUncheckedUpdateManyInput>
    /**
     * Filter which CategoryRequests to update
     */
    where?: CategoryRequestWhereInput
    /**
     * Limit how many CategoryRequests to update.
     */
    limit?: number
  }

  /**
   * CategoryRequest updateManyAndReturn
   */
  export type CategoryRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * The data used to update CategoryRequests.
     */
    data: XOR<CategoryRequestUpdateManyMutationInput, CategoryRequestUncheckedUpdateManyInput>
    /**
     * Filter which CategoryRequests to update
     */
    where?: CategoryRequestWhereInput
    /**
     * Limit how many CategoryRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryRequest upsert
   */
  export type CategoryRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryRequest to update in case it exists.
     */
    where: CategoryRequestWhereUniqueInput
    /**
     * In case the CategoryRequest found by the `where` argument doesn't exist, create a new CategoryRequest with this data.
     */
    create: XOR<CategoryRequestCreateInput, CategoryRequestUncheckedCreateInput>
    /**
     * In case the CategoryRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryRequestUpdateInput, CategoryRequestUncheckedUpdateInput>
  }

  /**
   * CategoryRequest delete
   */
  export type CategoryRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
    /**
     * Filter which CategoryRequest to delete.
     */
    where: CategoryRequestWhereUniqueInput
  }

  /**
   * CategoryRequest deleteMany
   */
  export type CategoryRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryRequests to delete
     */
    where?: CategoryRequestWhereInput
    /**
     * Limit how many CategoryRequests to delete.
     */
    limit?: number
  }

  /**
   * CategoryRequest without action
   */
  export type CategoryRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryRequest
     */
    select?: CategoryRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryRequest
     */
    omit?: CategoryRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryRequestInclude<ExtArgs> | null
  }


  /**
   * Model OwnerPasswordReset
   */

  export type AggregateOwnerPasswordReset = {
    _count: OwnerPasswordResetCountAggregateOutputType | null
    _min: OwnerPasswordResetMinAggregateOutputType | null
    _max: OwnerPasswordResetMaxAggregateOutputType | null
  }

  export type OwnerPasswordResetMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type OwnerPasswordResetMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type OwnerPasswordResetCountAggregateOutputType = {
    id: number
    ownerId: number
    tokenHash: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type OwnerPasswordResetMinAggregateInputType = {
    id?: true
    ownerId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type OwnerPasswordResetMaxAggregateInputType = {
    id?: true
    ownerId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type OwnerPasswordResetCountAggregateInputType = {
    id?: true
    ownerId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type OwnerPasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerPasswordReset to aggregate.
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerPasswordResets to fetch.
     */
    orderBy?: OwnerPasswordResetOrderByWithRelationInput | OwnerPasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerPasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerPasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerPasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerPasswordResets
    **/
    _count?: true | OwnerPasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerPasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerPasswordResetMaxAggregateInputType
  }

  export type GetOwnerPasswordResetAggregateType<T extends OwnerPasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerPasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerPasswordReset[P]>
      : GetScalarType<T[P], AggregateOwnerPasswordReset[P]>
  }




  export type OwnerPasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerPasswordResetWhereInput
    orderBy?: OwnerPasswordResetOrderByWithAggregationInput | OwnerPasswordResetOrderByWithAggregationInput[]
    by: OwnerPasswordResetScalarFieldEnum[] | OwnerPasswordResetScalarFieldEnum
    having?: OwnerPasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerPasswordResetCountAggregateInputType | true
    _min?: OwnerPasswordResetMinAggregateInputType
    _max?: OwnerPasswordResetMaxAggregateInputType
  }

  export type OwnerPasswordResetGroupByOutputType = {
    id: string
    ownerId: string
    tokenHash: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: OwnerPasswordResetCountAggregateOutputType | null
    _min: OwnerPasswordResetMinAggregateOutputType | null
    _max: OwnerPasswordResetMaxAggregateOutputType | null
  }

  type GetOwnerPasswordResetGroupByPayload<T extends OwnerPasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerPasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerPasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerPasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerPasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type OwnerPasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerPasswordReset"]>

  export type OwnerPasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerPasswordReset"]>

  export type OwnerPasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerPasswordReset"]>

  export type OwnerPasswordResetSelectScalar = {
    id?: boolean
    ownerId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type OwnerPasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "tokenHash" | "expiresAt" | "usedAt" | "createdAt", ExtArgs["result"]["ownerPasswordReset"]>
  export type OwnerPasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type OwnerPasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type OwnerPasswordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $OwnerPasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerPasswordReset"
    objects: {
      owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      tokenHash: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["ownerPasswordReset"]>
    composites: {}
  }

  type OwnerPasswordResetGetPayload<S extends boolean | null | undefined | OwnerPasswordResetDefaultArgs> = $Result.GetResult<Prisma.$OwnerPasswordResetPayload, S>

  type OwnerPasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerPasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerPasswordResetCountAggregateInputType | true
    }

  export interface OwnerPasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerPasswordReset'], meta: { name: 'OwnerPasswordReset' } }
    /**
     * Find zero or one OwnerPasswordReset that matches the filter.
     * @param {OwnerPasswordResetFindUniqueArgs} args - Arguments to find a OwnerPasswordReset
     * @example
     * // Get one OwnerPasswordReset
     * const ownerPasswordReset = await prisma.ownerPasswordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerPasswordResetFindUniqueArgs>(args: SelectSubset<T, OwnerPasswordResetFindUniqueArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnerPasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerPasswordResetFindUniqueOrThrowArgs} args - Arguments to find a OwnerPasswordReset
     * @example
     * // Get one OwnerPasswordReset
     * const ownerPasswordReset = await prisma.ownerPasswordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerPasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerPasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerPasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetFindFirstArgs} args - Arguments to find a OwnerPasswordReset
     * @example
     * // Get one OwnerPasswordReset
     * const ownerPasswordReset = await prisma.ownerPasswordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerPasswordResetFindFirstArgs>(args?: SelectSubset<T, OwnerPasswordResetFindFirstArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerPasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetFindFirstOrThrowArgs} args - Arguments to find a OwnerPasswordReset
     * @example
     * // Get one OwnerPasswordReset
     * const ownerPasswordReset = await prisma.ownerPasswordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerPasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerPasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnerPasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerPasswordResets
     * const ownerPasswordResets = await prisma.ownerPasswordReset.findMany()
     * 
     * // Get first 10 OwnerPasswordResets
     * const ownerPasswordResets = await prisma.ownerPasswordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerPasswordResetWithIdOnly = await prisma.ownerPasswordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerPasswordResetFindManyArgs>(args?: SelectSubset<T, OwnerPasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnerPasswordReset.
     * @param {OwnerPasswordResetCreateArgs} args - Arguments to create a OwnerPasswordReset.
     * @example
     * // Create one OwnerPasswordReset
     * const OwnerPasswordReset = await prisma.ownerPasswordReset.create({
     *   data: {
     *     // ... data to create a OwnerPasswordReset
     *   }
     * })
     * 
     */
    create<T extends OwnerPasswordResetCreateArgs>(args: SelectSubset<T, OwnerPasswordResetCreateArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnerPasswordResets.
     * @param {OwnerPasswordResetCreateManyArgs} args - Arguments to create many OwnerPasswordResets.
     * @example
     * // Create many OwnerPasswordResets
     * const ownerPasswordReset = await prisma.ownerPasswordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerPasswordResetCreateManyArgs>(args?: SelectSubset<T, OwnerPasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerPasswordResets and returns the data saved in the database.
     * @param {OwnerPasswordResetCreateManyAndReturnArgs} args - Arguments to create many OwnerPasswordResets.
     * @example
     * // Create many OwnerPasswordResets
     * const ownerPasswordReset = await prisma.ownerPasswordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerPasswordResets and only return the `id`
     * const ownerPasswordResetWithIdOnly = await prisma.ownerPasswordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerPasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerPasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnerPasswordReset.
     * @param {OwnerPasswordResetDeleteArgs} args - Arguments to delete one OwnerPasswordReset.
     * @example
     * // Delete one OwnerPasswordReset
     * const OwnerPasswordReset = await prisma.ownerPasswordReset.delete({
     *   where: {
     *     // ... filter to delete one OwnerPasswordReset
     *   }
     * })
     * 
     */
    delete<T extends OwnerPasswordResetDeleteArgs>(args: SelectSubset<T, OwnerPasswordResetDeleteArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnerPasswordReset.
     * @param {OwnerPasswordResetUpdateArgs} args - Arguments to update one OwnerPasswordReset.
     * @example
     * // Update one OwnerPasswordReset
     * const ownerPasswordReset = await prisma.ownerPasswordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerPasswordResetUpdateArgs>(args: SelectSubset<T, OwnerPasswordResetUpdateArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnerPasswordResets.
     * @param {OwnerPasswordResetDeleteManyArgs} args - Arguments to filter OwnerPasswordResets to delete.
     * @example
     * // Delete a few OwnerPasswordResets
     * const { count } = await prisma.ownerPasswordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerPasswordResetDeleteManyArgs>(args?: SelectSubset<T, OwnerPasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerPasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerPasswordResets
     * const ownerPasswordReset = await prisma.ownerPasswordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerPasswordResetUpdateManyArgs>(args: SelectSubset<T, OwnerPasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerPasswordResets and returns the data updated in the database.
     * @param {OwnerPasswordResetUpdateManyAndReturnArgs} args - Arguments to update many OwnerPasswordResets.
     * @example
     * // Update many OwnerPasswordResets
     * const ownerPasswordReset = await prisma.ownerPasswordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnerPasswordResets and only return the `id`
     * const ownerPasswordResetWithIdOnly = await prisma.ownerPasswordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerPasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerPasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnerPasswordReset.
     * @param {OwnerPasswordResetUpsertArgs} args - Arguments to update or create a OwnerPasswordReset.
     * @example
     * // Update or create a OwnerPasswordReset
     * const ownerPasswordReset = await prisma.ownerPasswordReset.upsert({
     *   create: {
     *     // ... data to create a OwnerPasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerPasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends OwnerPasswordResetUpsertArgs>(args: SelectSubset<T, OwnerPasswordResetUpsertArgs<ExtArgs>>): Prisma__OwnerPasswordResetClient<$Result.GetResult<Prisma.$OwnerPasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnerPasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetCountArgs} args - Arguments to filter OwnerPasswordResets to count.
     * @example
     * // Count the number of OwnerPasswordResets
     * const count = await prisma.ownerPasswordReset.count({
     *   where: {
     *     // ... the filter for the OwnerPasswordResets we want to count
     *   }
     * })
    **/
    count<T extends OwnerPasswordResetCountArgs>(
      args?: Subset<T, OwnerPasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerPasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerPasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerPasswordResetAggregateArgs>(args: Subset<T, OwnerPasswordResetAggregateArgs>): Prisma.PrismaPromise<GetOwnerPasswordResetAggregateType<T>>

    /**
     * Group by OwnerPasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerPasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerPasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerPasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: OwnerPasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerPasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerPasswordReset model
   */
  readonly fields: OwnerPasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerPasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerPasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerPasswordReset model
   */
  interface OwnerPasswordResetFieldRefs {
    readonly id: FieldRef<"OwnerPasswordReset", 'String'>
    readonly ownerId: FieldRef<"OwnerPasswordReset", 'String'>
    readonly tokenHash: FieldRef<"OwnerPasswordReset", 'String'>
    readonly expiresAt: FieldRef<"OwnerPasswordReset", 'DateTime'>
    readonly usedAt: FieldRef<"OwnerPasswordReset", 'DateTime'>
    readonly createdAt: FieldRef<"OwnerPasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OwnerPasswordReset findUnique
   */
  export type OwnerPasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which OwnerPasswordReset to fetch.
     */
    where: OwnerPasswordResetWhereUniqueInput
  }

  /**
   * OwnerPasswordReset findUniqueOrThrow
   */
  export type OwnerPasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which OwnerPasswordReset to fetch.
     */
    where: OwnerPasswordResetWhereUniqueInput
  }

  /**
   * OwnerPasswordReset findFirst
   */
  export type OwnerPasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which OwnerPasswordReset to fetch.
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerPasswordResets to fetch.
     */
    orderBy?: OwnerPasswordResetOrderByWithRelationInput | OwnerPasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerPasswordResets.
     */
    cursor?: OwnerPasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerPasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerPasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerPasswordResets.
     */
    distinct?: OwnerPasswordResetScalarFieldEnum | OwnerPasswordResetScalarFieldEnum[]
  }

  /**
   * OwnerPasswordReset findFirstOrThrow
   */
  export type OwnerPasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which OwnerPasswordReset to fetch.
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerPasswordResets to fetch.
     */
    orderBy?: OwnerPasswordResetOrderByWithRelationInput | OwnerPasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerPasswordResets.
     */
    cursor?: OwnerPasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerPasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerPasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerPasswordResets.
     */
    distinct?: OwnerPasswordResetScalarFieldEnum | OwnerPasswordResetScalarFieldEnum[]
  }

  /**
   * OwnerPasswordReset findMany
   */
  export type OwnerPasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which OwnerPasswordResets to fetch.
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerPasswordResets to fetch.
     */
    orderBy?: OwnerPasswordResetOrderByWithRelationInput | OwnerPasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerPasswordResets.
     */
    cursor?: OwnerPasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerPasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerPasswordResets.
     */
    skip?: number
    distinct?: OwnerPasswordResetScalarFieldEnum | OwnerPasswordResetScalarFieldEnum[]
  }

  /**
   * OwnerPasswordReset create
   */
  export type OwnerPasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerPasswordReset.
     */
    data: XOR<OwnerPasswordResetCreateInput, OwnerPasswordResetUncheckedCreateInput>
  }

  /**
   * OwnerPasswordReset createMany
   */
  export type OwnerPasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerPasswordResets.
     */
    data: OwnerPasswordResetCreateManyInput | OwnerPasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerPasswordReset createManyAndReturn
   */
  export type OwnerPasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many OwnerPasswordResets.
     */
    data: OwnerPasswordResetCreateManyInput | OwnerPasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerPasswordReset update
   */
  export type OwnerPasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerPasswordReset.
     */
    data: XOR<OwnerPasswordResetUpdateInput, OwnerPasswordResetUncheckedUpdateInput>
    /**
     * Choose, which OwnerPasswordReset to update.
     */
    where: OwnerPasswordResetWhereUniqueInput
  }

  /**
   * OwnerPasswordReset updateMany
   */
  export type OwnerPasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerPasswordResets.
     */
    data: XOR<OwnerPasswordResetUpdateManyMutationInput, OwnerPasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which OwnerPasswordResets to update
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * Limit how many OwnerPasswordResets to update.
     */
    limit?: number
  }

  /**
   * OwnerPasswordReset updateManyAndReturn
   */
  export type OwnerPasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update OwnerPasswordResets.
     */
    data: XOR<OwnerPasswordResetUpdateManyMutationInput, OwnerPasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which OwnerPasswordResets to update
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * Limit how many OwnerPasswordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerPasswordReset upsert
   */
  export type OwnerPasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerPasswordReset to update in case it exists.
     */
    where: OwnerPasswordResetWhereUniqueInput
    /**
     * In case the OwnerPasswordReset found by the `where` argument doesn't exist, create a new OwnerPasswordReset with this data.
     */
    create: XOR<OwnerPasswordResetCreateInput, OwnerPasswordResetUncheckedCreateInput>
    /**
     * In case the OwnerPasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerPasswordResetUpdateInput, OwnerPasswordResetUncheckedUpdateInput>
  }

  /**
   * OwnerPasswordReset delete
   */
  export type OwnerPasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
    /**
     * Filter which OwnerPasswordReset to delete.
     */
    where: OwnerPasswordResetWhereUniqueInput
  }

  /**
   * OwnerPasswordReset deleteMany
   */
  export type OwnerPasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerPasswordResets to delete
     */
    where?: OwnerPasswordResetWhereInput
    /**
     * Limit how many OwnerPasswordResets to delete.
     */
    limit?: number
  }

  /**
   * OwnerPasswordReset without action
   */
  export type OwnerPasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerPasswordReset
     */
    select?: OwnerPasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerPasswordReset
     */
    omit?: OwnerPasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerPasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    maxRedemptions: number | null
    usedCount: number | null
    grantMonths: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    maxRedemptions: number | null
    usedCount: number | null
    grantMonths: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    maxRedemptions: number | null
    usedCount: number | null
    expiresAt: Date | null
    grantPlan: $Enums.SubscriptionPlan | null
    grantMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    maxRedemptions: number | null
    usedCount: number | null
    expiresAt: Date | null
    grantPlan: $Enums.SubscriptionPlan | null
    grantMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    isActive: number
    maxRedemptions: number
    usedCount: number
    expiresAt: number
    grantPlan: number
    grantMonths: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    maxRedemptions?: true
    usedCount?: true
    grantMonths?: true
  }

  export type PromoCodeSumAggregateInputType = {
    maxRedemptions?: true
    usedCount?: true
    grantMonths?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    isActive?: true
    maxRedemptions?: true
    usedCount?: true
    expiresAt?: true
    grantPlan?: true
    grantMonths?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    isActive?: true
    maxRedemptions?: true
    usedCount?: true
    expiresAt?: true
    grantPlan?: true
    grantMonths?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    isActive?: true
    maxRedemptions?: true
    usedCount?: true
    expiresAt?: true
    grantPlan?: true
    grantMonths?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    isActive: boolean
    maxRedemptions: number | null
    usedCount: number
    expiresAt: Date | null
    grantPlan: $Enums.SubscriptionPlan | null
    grantMonths: number | null
    createdAt: Date
    updatedAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    maxRedemptions?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    grantPlan?: boolean
    grantMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    redemptions?: boolean | PromoCode$redemptionsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    maxRedemptions?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    grantPlan?: boolean
    grantMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    maxRedemptions?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    grantPlan?: boolean
    grantMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    maxRedemptions?: boolean
    usedCount?: boolean
    expiresAt?: boolean
    grantPlan?: boolean
    grantMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "isActive" | "maxRedemptions" | "usedCount" | "expiresAt" | "grantPlan" | "grantMonths" | "createdAt" | "updatedAt", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | PromoCode$redemptionsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromoCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      redemptions: Prisma.$PromoRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      isActive: boolean
      maxRedemptions: number | null
      usedCount: number
      expiresAt: Date | null
      grantPlan: $Enums.SubscriptionPlan | null
      grantMonths: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes and returns the data updated in the database.
     * @param {PromoCodeUpdateManyAndReturnArgs} args - Arguments to update many PromoCodes.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redemptions<T extends PromoCode$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly isActive: FieldRef<"PromoCode", 'Boolean'>
    readonly maxRedemptions: FieldRef<"PromoCode", 'Int'>
    readonly usedCount: FieldRef<"PromoCode", 'Int'>
    readonly expiresAt: FieldRef<"PromoCode", 'DateTime'>
    readonly grantPlan: FieldRef<"PromoCode", 'SubscriptionPlan'>
    readonly grantMonths: FieldRef<"PromoCode", 'Int'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
    readonly updatedAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode updateManyAndReturn
   */
  export type PromoCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode.redemptions
   */
  export type PromoCode$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    where?: PromoRedemptionWhereInput
    orderBy?: PromoRedemptionOrderByWithRelationInput | PromoRedemptionOrderByWithRelationInput[]
    cursor?: PromoRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoRedemptionScalarFieldEnum | PromoRedemptionScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model PromoRedemption
   */

  export type AggregatePromoRedemption = {
    _count: PromoRedemptionCountAggregateOutputType | null
    _min: PromoRedemptionMinAggregateOutputType | null
    _max: PromoRedemptionMaxAggregateOutputType | null
  }

  export type PromoRedemptionMinAggregateOutputType = {
    id: string | null
    promoCodeId: string | null
    ownerId: string | null
    redeemedAt: Date | null
  }

  export type PromoRedemptionMaxAggregateOutputType = {
    id: string | null
    promoCodeId: string | null
    ownerId: string | null
    redeemedAt: Date | null
  }

  export type PromoRedemptionCountAggregateOutputType = {
    id: number
    promoCodeId: number
    ownerId: number
    redeemedAt: number
    _all: number
  }


  export type PromoRedemptionMinAggregateInputType = {
    id?: true
    promoCodeId?: true
    ownerId?: true
    redeemedAt?: true
  }

  export type PromoRedemptionMaxAggregateInputType = {
    id?: true
    promoCodeId?: true
    ownerId?: true
    redeemedAt?: true
  }

  export type PromoRedemptionCountAggregateInputType = {
    id?: true
    promoCodeId?: true
    ownerId?: true
    redeemedAt?: true
    _all?: true
  }

  export type PromoRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoRedemption to aggregate.
     */
    where?: PromoRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoRedemptions to fetch.
     */
    orderBy?: PromoRedemptionOrderByWithRelationInput | PromoRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoRedemptions
    **/
    _count?: true | PromoRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoRedemptionMaxAggregateInputType
  }

  export type GetPromoRedemptionAggregateType<T extends PromoRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoRedemption[P]>
      : GetScalarType<T[P], AggregatePromoRedemption[P]>
  }




  export type PromoRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoRedemptionWhereInput
    orderBy?: PromoRedemptionOrderByWithAggregationInput | PromoRedemptionOrderByWithAggregationInput[]
    by: PromoRedemptionScalarFieldEnum[] | PromoRedemptionScalarFieldEnum
    having?: PromoRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoRedemptionCountAggregateInputType | true
    _min?: PromoRedemptionMinAggregateInputType
    _max?: PromoRedemptionMaxAggregateInputType
  }

  export type PromoRedemptionGroupByOutputType = {
    id: string
    promoCodeId: string
    ownerId: string
    redeemedAt: Date
    _count: PromoRedemptionCountAggregateOutputType | null
    _min: PromoRedemptionMinAggregateOutputType | null
    _max: PromoRedemptionMaxAggregateOutputType | null
  }

  type GetPromoRedemptionGroupByPayload<T extends PromoRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], PromoRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type PromoRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    ownerId?: boolean
    redeemedAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoRedemption"]>

  export type PromoRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    ownerId?: boolean
    redeemedAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoRedemption"]>

  export type PromoRedemptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    ownerId?: boolean
    redeemedAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoRedemption"]>

  export type PromoRedemptionSelectScalar = {
    id?: boolean
    promoCodeId?: boolean
    ownerId?: boolean
    redeemedAt?: boolean
  }

  export type PromoRedemptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promoCodeId" | "ownerId" | "redeemedAt", ExtArgs["result"]["promoRedemption"]>
  export type PromoRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type PromoRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type PromoRedemptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $PromoRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoRedemption"
    objects: {
      promoCode: Prisma.$PromoCodePayload<ExtArgs>
      owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promoCodeId: string
      ownerId: string
      redeemedAt: Date
    }, ExtArgs["result"]["promoRedemption"]>
    composites: {}
  }

  type PromoRedemptionGetPayload<S extends boolean | null | undefined | PromoRedemptionDefaultArgs> = $Result.GetResult<Prisma.$PromoRedemptionPayload, S>

  type PromoRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoRedemptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoRedemptionCountAggregateInputType | true
    }

  export interface PromoRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoRedemption'], meta: { name: 'PromoRedemption' } }
    /**
     * Find zero or one PromoRedemption that matches the filter.
     * @param {PromoRedemptionFindUniqueArgs} args - Arguments to find a PromoRedemption
     * @example
     * // Get one PromoRedemption
     * const promoRedemption = await prisma.promoRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoRedemptionFindUniqueArgs>(args: SelectSubset<T, PromoRedemptionFindUniqueArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoRedemption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoRedemptionFindUniqueOrThrowArgs} args - Arguments to find a PromoRedemption
     * @example
     * // Get one PromoRedemption
     * const promoRedemption = await prisma.promoRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionFindFirstArgs} args - Arguments to find a PromoRedemption
     * @example
     * // Get one PromoRedemption
     * const promoRedemption = await prisma.promoRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoRedemptionFindFirstArgs>(args?: SelectSubset<T, PromoRedemptionFindFirstArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionFindFirstOrThrowArgs} args - Arguments to find a PromoRedemption
     * @example
     * // Get one PromoRedemption
     * const promoRedemption = await prisma.promoRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoRedemptions
     * const promoRedemptions = await prisma.promoRedemption.findMany()
     * 
     * // Get first 10 PromoRedemptions
     * const promoRedemptions = await prisma.promoRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoRedemptionWithIdOnly = await prisma.promoRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoRedemptionFindManyArgs>(args?: SelectSubset<T, PromoRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoRedemption.
     * @param {PromoRedemptionCreateArgs} args - Arguments to create a PromoRedemption.
     * @example
     * // Create one PromoRedemption
     * const PromoRedemption = await prisma.promoRedemption.create({
     *   data: {
     *     // ... data to create a PromoRedemption
     *   }
     * })
     * 
     */
    create<T extends PromoRedemptionCreateArgs>(args: SelectSubset<T, PromoRedemptionCreateArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoRedemptions.
     * @param {PromoRedemptionCreateManyArgs} args - Arguments to create many PromoRedemptions.
     * @example
     * // Create many PromoRedemptions
     * const promoRedemption = await prisma.promoRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoRedemptionCreateManyArgs>(args?: SelectSubset<T, PromoRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoRedemptions and returns the data saved in the database.
     * @param {PromoRedemptionCreateManyAndReturnArgs} args - Arguments to create many PromoRedemptions.
     * @example
     * // Create many PromoRedemptions
     * const promoRedemption = await prisma.promoRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoRedemptions and only return the `id`
     * const promoRedemptionWithIdOnly = await prisma.promoRedemption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoRedemption.
     * @param {PromoRedemptionDeleteArgs} args - Arguments to delete one PromoRedemption.
     * @example
     * // Delete one PromoRedemption
     * const PromoRedemption = await prisma.promoRedemption.delete({
     *   where: {
     *     // ... filter to delete one PromoRedemption
     *   }
     * })
     * 
     */
    delete<T extends PromoRedemptionDeleteArgs>(args: SelectSubset<T, PromoRedemptionDeleteArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoRedemption.
     * @param {PromoRedemptionUpdateArgs} args - Arguments to update one PromoRedemption.
     * @example
     * // Update one PromoRedemption
     * const promoRedemption = await prisma.promoRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoRedemptionUpdateArgs>(args: SelectSubset<T, PromoRedemptionUpdateArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoRedemptions.
     * @param {PromoRedemptionDeleteManyArgs} args - Arguments to filter PromoRedemptions to delete.
     * @example
     * // Delete a few PromoRedemptions
     * const { count } = await prisma.promoRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoRedemptionDeleteManyArgs>(args?: SelectSubset<T, PromoRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoRedemptions
     * const promoRedemption = await prisma.promoRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoRedemptionUpdateManyArgs>(args: SelectSubset<T, PromoRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoRedemptions and returns the data updated in the database.
     * @param {PromoRedemptionUpdateManyAndReturnArgs} args - Arguments to update many PromoRedemptions.
     * @example
     * // Update many PromoRedemptions
     * const promoRedemption = await prisma.promoRedemption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoRedemptions and only return the `id`
     * const promoRedemptionWithIdOnly = await prisma.promoRedemption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoRedemptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoRedemptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoRedemption.
     * @param {PromoRedemptionUpsertArgs} args - Arguments to update or create a PromoRedemption.
     * @example
     * // Update or create a PromoRedemption
     * const promoRedemption = await prisma.promoRedemption.upsert({
     *   create: {
     *     // ... data to create a PromoRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoRedemption we want to update
     *   }
     * })
     */
    upsert<T extends PromoRedemptionUpsertArgs>(args: SelectSubset<T, PromoRedemptionUpsertArgs<ExtArgs>>): Prisma__PromoRedemptionClient<$Result.GetResult<Prisma.$PromoRedemptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionCountArgs} args - Arguments to filter PromoRedemptions to count.
     * @example
     * // Count the number of PromoRedemptions
     * const count = await prisma.promoRedemption.count({
     *   where: {
     *     // ... the filter for the PromoRedemptions we want to count
     *   }
     * })
    **/
    count<T extends PromoRedemptionCountArgs>(
      args?: Subset<T, PromoRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoRedemptionAggregateArgs>(args: Subset<T, PromoRedemptionAggregateArgs>): Prisma.PrismaPromise<GetPromoRedemptionAggregateType<T>>

    /**
     * Group by PromoRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: PromoRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoRedemption model
   */
  readonly fields: PromoRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promoCode<T extends PromoCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromoCodeDefaultArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoRedemption model
   */
  interface PromoRedemptionFieldRefs {
    readonly id: FieldRef<"PromoRedemption", 'String'>
    readonly promoCodeId: FieldRef<"PromoRedemption", 'String'>
    readonly ownerId: FieldRef<"PromoRedemption", 'String'>
    readonly redeemedAt: FieldRef<"PromoRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoRedemption findUnique
   */
  export type PromoRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromoRedemption to fetch.
     */
    where: PromoRedemptionWhereUniqueInput
  }

  /**
   * PromoRedemption findUniqueOrThrow
   */
  export type PromoRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromoRedemption to fetch.
     */
    where: PromoRedemptionWhereUniqueInput
  }

  /**
   * PromoRedemption findFirst
   */
  export type PromoRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromoRedemption to fetch.
     */
    where?: PromoRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoRedemptions to fetch.
     */
    orderBy?: PromoRedemptionOrderByWithRelationInput | PromoRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoRedemptions.
     */
    cursor?: PromoRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoRedemptions.
     */
    distinct?: PromoRedemptionScalarFieldEnum | PromoRedemptionScalarFieldEnum[]
  }

  /**
   * PromoRedemption findFirstOrThrow
   */
  export type PromoRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromoRedemption to fetch.
     */
    where?: PromoRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoRedemptions to fetch.
     */
    orderBy?: PromoRedemptionOrderByWithRelationInput | PromoRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoRedemptions.
     */
    cursor?: PromoRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoRedemptions.
     */
    distinct?: PromoRedemptionScalarFieldEnum | PromoRedemptionScalarFieldEnum[]
  }

  /**
   * PromoRedemption findMany
   */
  export type PromoRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromoRedemptions to fetch.
     */
    where?: PromoRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoRedemptions to fetch.
     */
    orderBy?: PromoRedemptionOrderByWithRelationInput | PromoRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoRedemptions.
     */
    cursor?: PromoRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoRedemptions.
     */
    skip?: number
    distinct?: PromoRedemptionScalarFieldEnum | PromoRedemptionScalarFieldEnum[]
  }

  /**
   * PromoRedemption create
   */
  export type PromoRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoRedemption.
     */
    data: XOR<PromoRedemptionCreateInput, PromoRedemptionUncheckedCreateInput>
  }

  /**
   * PromoRedemption createMany
   */
  export type PromoRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoRedemptions.
     */
    data: PromoRedemptionCreateManyInput | PromoRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoRedemption createManyAndReturn
   */
  export type PromoRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * The data used to create many PromoRedemptions.
     */
    data: PromoRedemptionCreateManyInput | PromoRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoRedemption update
   */
  export type PromoRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoRedemption.
     */
    data: XOR<PromoRedemptionUpdateInput, PromoRedemptionUncheckedUpdateInput>
    /**
     * Choose, which PromoRedemption to update.
     */
    where: PromoRedemptionWhereUniqueInput
  }

  /**
   * PromoRedemption updateMany
   */
  export type PromoRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoRedemptions.
     */
    data: XOR<PromoRedemptionUpdateManyMutationInput, PromoRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromoRedemptions to update
     */
    where?: PromoRedemptionWhereInput
    /**
     * Limit how many PromoRedemptions to update.
     */
    limit?: number
  }

  /**
   * PromoRedemption updateManyAndReturn
   */
  export type PromoRedemptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * The data used to update PromoRedemptions.
     */
    data: XOR<PromoRedemptionUpdateManyMutationInput, PromoRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromoRedemptions to update
     */
    where?: PromoRedemptionWhereInput
    /**
     * Limit how many PromoRedemptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoRedemption upsert
   */
  export type PromoRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoRedemption to update in case it exists.
     */
    where: PromoRedemptionWhereUniqueInput
    /**
     * In case the PromoRedemption found by the `where` argument doesn't exist, create a new PromoRedemption with this data.
     */
    create: XOR<PromoRedemptionCreateInput, PromoRedemptionUncheckedCreateInput>
    /**
     * In case the PromoRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoRedemptionUpdateInput, PromoRedemptionUncheckedUpdateInput>
  }

  /**
   * PromoRedemption delete
   */
  export type PromoRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
    /**
     * Filter which PromoRedemption to delete.
     */
    where: PromoRedemptionWhereUniqueInput
  }

  /**
   * PromoRedemption deleteMany
   */
  export type PromoRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoRedemptions to delete
     */
    where?: PromoRedemptionWhereInput
    /**
     * Limit how many PromoRedemptions to delete.
     */
    limit?: number
  }

  /**
   * PromoRedemption without action
   */
  export type PromoRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoRedemption
     */
    select?: PromoRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoRedemption
     */
    omit?: PromoRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoRedemptionInclude<ExtArgs> | null
  }


  /**
   * Model BarAnalytics
   */

  export type AggregateBarAnalytics = {
    _count: BarAnalyticsCountAggregateOutputType | null
    _avg: BarAnalyticsAvgAggregateOutputType | null
    _sum: BarAnalyticsSumAggregateOutputType | null
    _min: BarAnalyticsMinAggregateOutputType | null
    _max: BarAnalyticsMaxAggregateOutputType | null
  }

  export type BarAnalyticsAvgAggregateOutputType = {
    dayOfWeek: number | null
    profileViews: number | null
    profileClicks: number | null
    searchAppears: number | null
  }

  export type BarAnalyticsSumAggregateOutputType = {
    dayOfWeek: number | null
    profileViews: number | null
    profileClicks: number | null
    searchAppears: number | null
  }

  export type BarAnalyticsMinAggregateOutputType = {
    id: string | null
    barId: string | null
    date: Date | null
    dayOfWeek: number | null
    profileViews: number | null
    profileClicks: number | null
    searchAppears: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarAnalyticsMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    date: Date | null
    dayOfWeek: number | null
    profileViews: number | null
    profileClicks: number | null
    searchAppears: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarAnalyticsCountAggregateOutputType = {
    id: number
    barId: number
    date: number
    dayOfWeek: number
    profileViews: number
    profileClicks: number
    searchAppears: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BarAnalyticsAvgAggregateInputType = {
    dayOfWeek?: true
    profileViews?: true
    profileClicks?: true
    searchAppears?: true
  }

  export type BarAnalyticsSumAggregateInputType = {
    dayOfWeek?: true
    profileViews?: true
    profileClicks?: true
    searchAppears?: true
  }

  export type BarAnalyticsMinAggregateInputType = {
    id?: true
    barId?: true
    date?: true
    dayOfWeek?: true
    profileViews?: true
    profileClicks?: true
    searchAppears?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarAnalyticsMaxAggregateInputType = {
    id?: true
    barId?: true
    date?: true
    dayOfWeek?: true
    profileViews?: true
    profileClicks?: true
    searchAppears?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarAnalyticsCountAggregateInputType = {
    id?: true
    barId?: true
    date?: true
    dayOfWeek?: true
    profileViews?: true
    profileClicks?: true
    searchAppears?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BarAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarAnalytics to aggregate.
     */
    where?: BarAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarAnalytics to fetch.
     */
    orderBy?: BarAnalyticsOrderByWithRelationInput | BarAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarAnalytics
    **/
    _count?: true | BarAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarAnalyticsMaxAggregateInputType
  }

  export type GetBarAnalyticsAggregateType<T extends BarAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateBarAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarAnalytics[P]>
      : GetScalarType<T[P], AggregateBarAnalytics[P]>
  }




  export type BarAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarAnalyticsWhereInput
    orderBy?: BarAnalyticsOrderByWithAggregationInput | BarAnalyticsOrderByWithAggregationInput[]
    by: BarAnalyticsScalarFieldEnum[] | BarAnalyticsScalarFieldEnum
    having?: BarAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarAnalyticsCountAggregateInputType | true
    _avg?: BarAnalyticsAvgAggregateInputType
    _sum?: BarAnalyticsSumAggregateInputType
    _min?: BarAnalyticsMinAggregateInputType
    _max?: BarAnalyticsMaxAggregateInputType
  }

  export type BarAnalyticsGroupByOutputType = {
    id: string
    barId: string
    date: Date
    dayOfWeek: number
    profileViews: number
    profileClicks: number
    searchAppears: number
    createdAt: Date
    updatedAt: Date
    _count: BarAnalyticsCountAggregateOutputType | null
    _avg: BarAnalyticsAvgAggregateOutputType | null
    _sum: BarAnalyticsSumAggregateOutputType | null
    _min: BarAnalyticsMinAggregateOutputType | null
    _max: BarAnalyticsMaxAggregateOutputType | null
  }

  type GetBarAnalyticsGroupByPayload<T extends BarAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], BarAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type BarAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    date?: boolean
    dayOfWeek?: boolean
    profileViews?: boolean
    profileClicks?: boolean
    searchAppears?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barAnalytics"]>

  export type BarAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    date?: boolean
    dayOfWeek?: boolean
    profileViews?: boolean
    profileClicks?: boolean
    searchAppears?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barAnalytics"]>

  export type BarAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    date?: boolean
    dayOfWeek?: boolean
    profileViews?: boolean
    profileClicks?: boolean
    searchAppears?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barAnalytics"]>

  export type BarAnalyticsSelectScalar = {
    id?: boolean
    barId?: boolean
    date?: boolean
    dayOfWeek?: boolean
    profileViews?: boolean
    profileClicks?: boolean
    searchAppears?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BarAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "date" | "dayOfWeek" | "profileViews" | "profileClicks" | "searchAppears" | "createdAt" | "updatedAt", ExtArgs["result"]["barAnalytics"]>
  export type BarAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $BarAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarAnalytics"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      date: Date
      dayOfWeek: number
      profileViews: number
      profileClicks: number
      searchAppears: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["barAnalytics"]>
    composites: {}
  }

  type BarAnalyticsGetPayload<S extends boolean | null | undefined | BarAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$BarAnalyticsPayload, S>

  type BarAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarAnalyticsCountAggregateInputType | true
    }

  export interface BarAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarAnalytics'], meta: { name: 'BarAnalytics' } }
    /**
     * Find zero or one BarAnalytics that matches the filter.
     * @param {BarAnalyticsFindUniqueArgs} args - Arguments to find a BarAnalytics
     * @example
     * // Get one BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarAnalyticsFindUniqueArgs>(args: SelectSubset<T, BarAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a BarAnalytics
     * @example
     * // Get one BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, BarAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsFindFirstArgs} args - Arguments to find a BarAnalytics
     * @example
     * // Get one BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarAnalyticsFindFirstArgs>(args?: SelectSubset<T, BarAnalyticsFindFirstArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsFindFirstOrThrowArgs} args - Arguments to find a BarAnalytics
     * @example
     * // Get one BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, BarAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.findMany()
     * 
     * // Get first 10 BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barAnalyticsWithIdOnly = await prisma.barAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarAnalyticsFindManyArgs>(args?: SelectSubset<T, BarAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarAnalytics.
     * @param {BarAnalyticsCreateArgs} args - Arguments to create a BarAnalytics.
     * @example
     * // Create one BarAnalytics
     * const BarAnalytics = await prisma.barAnalytics.create({
     *   data: {
     *     // ... data to create a BarAnalytics
     *   }
     * })
     * 
     */
    create<T extends BarAnalyticsCreateArgs>(args: SelectSubset<T, BarAnalyticsCreateArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarAnalytics.
     * @param {BarAnalyticsCreateManyArgs} args - Arguments to create many BarAnalytics.
     * @example
     * // Create many BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarAnalyticsCreateManyArgs>(args?: SelectSubset<T, BarAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarAnalytics and returns the data saved in the database.
     * @param {BarAnalyticsCreateManyAndReturnArgs} args - Arguments to create many BarAnalytics.
     * @example
     * // Create many BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarAnalytics and only return the `id`
     * const barAnalyticsWithIdOnly = await prisma.barAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, BarAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarAnalytics.
     * @param {BarAnalyticsDeleteArgs} args - Arguments to delete one BarAnalytics.
     * @example
     * // Delete one BarAnalytics
     * const BarAnalytics = await prisma.barAnalytics.delete({
     *   where: {
     *     // ... filter to delete one BarAnalytics
     *   }
     * })
     * 
     */
    delete<T extends BarAnalyticsDeleteArgs>(args: SelectSubset<T, BarAnalyticsDeleteArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarAnalytics.
     * @param {BarAnalyticsUpdateArgs} args - Arguments to update one BarAnalytics.
     * @example
     * // Update one BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarAnalyticsUpdateArgs>(args: SelectSubset<T, BarAnalyticsUpdateArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarAnalytics.
     * @param {BarAnalyticsDeleteManyArgs} args - Arguments to filter BarAnalytics to delete.
     * @example
     * // Delete a few BarAnalytics
     * const { count } = await prisma.barAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarAnalyticsDeleteManyArgs>(args?: SelectSubset<T, BarAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarAnalyticsUpdateManyArgs>(args: SelectSubset<T, BarAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarAnalytics and returns the data updated in the database.
     * @param {BarAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many BarAnalytics.
     * @example
     * // Update many BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarAnalytics and only return the `id`
     * const barAnalyticsWithIdOnly = await prisma.barAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, BarAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarAnalytics.
     * @param {BarAnalyticsUpsertArgs} args - Arguments to update or create a BarAnalytics.
     * @example
     * // Update or create a BarAnalytics
     * const barAnalytics = await prisma.barAnalytics.upsert({
     *   create: {
     *     // ... data to create a BarAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends BarAnalyticsUpsertArgs>(args: SelectSubset<T, BarAnalyticsUpsertArgs<ExtArgs>>): Prisma__BarAnalyticsClient<$Result.GetResult<Prisma.$BarAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsCountArgs} args - Arguments to filter BarAnalytics to count.
     * @example
     * // Count the number of BarAnalytics
     * const count = await prisma.barAnalytics.count({
     *   where: {
     *     // ... the filter for the BarAnalytics we want to count
     *   }
     * })
    **/
    count<T extends BarAnalyticsCountArgs>(
      args?: Subset<T, BarAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarAnalyticsAggregateArgs>(args: Subset<T, BarAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetBarAnalyticsAggregateType<T>>

    /**
     * Group by BarAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: BarAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarAnalytics model
   */
  readonly fields: BarAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarAnalytics model
   */
  interface BarAnalyticsFieldRefs {
    readonly id: FieldRef<"BarAnalytics", 'String'>
    readonly barId: FieldRef<"BarAnalytics", 'String'>
    readonly date: FieldRef<"BarAnalytics", 'DateTime'>
    readonly dayOfWeek: FieldRef<"BarAnalytics", 'Int'>
    readonly profileViews: FieldRef<"BarAnalytics", 'Int'>
    readonly profileClicks: FieldRef<"BarAnalytics", 'Int'>
    readonly searchAppears: FieldRef<"BarAnalytics", 'Int'>
    readonly createdAt: FieldRef<"BarAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"BarAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarAnalytics findUnique
   */
  export type BarAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which BarAnalytics to fetch.
     */
    where: BarAnalyticsWhereUniqueInput
  }

  /**
   * BarAnalytics findUniqueOrThrow
   */
  export type BarAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which BarAnalytics to fetch.
     */
    where: BarAnalyticsWhereUniqueInput
  }

  /**
   * BarAnalytics findFirst
   */
  export type BarAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which BarAnalytics to fetch.
     */
    where?: BarAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarAnalytics to fetch.
     */
    orderBy?: BarAnalyticsOrderByWithRelationInput | BarAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarAnalytics.
     */
    cursor?: BarAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarAnalytics.
     */
    distinct?: BarAnalyticsScalarFieldEnum | BarAnalyticsScalarFieldEnum[]
  }

  /**
   * BarAnalytics findFirstOrThrow
   */
  export type BarAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which BarAnalytics to fetch.
     */
    where?: BarAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarAnalytics to fetch.
     */
    orderBy?: BarAnalyticsOrderByWithRelationInput | BarAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarAnalytics.
     */
    cursor?: BarAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarAnalytics.
     */
    distinct?: BarAnalyticsScalarFieldEnum | BarAnalyticsScalarFieldEnum[]
  }

  /**
   * BarAnalytics findMany
   */
  export type BarAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which BarAnalytics to fetch.
     */
    where?: BarAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarAnalytics to fetch.
     */
    orderBy?: BarAnalyticsOrderByWithRelationInput | BarAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarAnalytics.
     */
    cursor?: BarAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarAnalytics.
     */
    skip?: number
    distinct?: BarAnalyticsScalarFieldEnum | BarAnalyticsScalarFieldEnum[]
  }

  /**
   * BarAnalytics create
   */
  export type BarAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a BarAnalytics.
     */
    data: XOR<BarAnalyticsCreateInput, BarAnalyticsUncheckedCreateInput>
  }

  /**
   * BarAnalytics createMany
   */
  export type BarAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarAnalytics.
     */
    data: BarAnalyticsCreateManyInput | BarAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarAnalytics createManyAndReturn
   */
  export type BarAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many BarAnalytics.
     */
    data: BarAnalyticsCreateManyInput | BarAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarAnalytics update
   */
  export type BarAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a BarAnalytics.
     */
    data: XOR<BarAnalyticsUpdateInput, BarAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which BarAnalytics to update.
     */
    where: BarAnalyticsWhereUniqueInput
  }

  /**
   * BarAnalytics updateMany
   */
  export type BarAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarAnalytics.
     */
    data: XOR<BarAnalyticsUpdateManyMutationInput, BarAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which BarAnalytics to update
     */
    where?: BarAnalyticsWhereInput
    /**
     * Limit how many BarAnalytics to update.
     */
    limit?: number
  }

  /**
   * BarAnalytics updateManyAndReturn
   */
  export type BarAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update BarAnalytics.
     */
    data: XOR<BarAnalyticsUpdateManyMutationInput, BarAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which BarAnalytics to update
     */
    where?: BarAnalyticsWhereInput
    /**
     * Limit how many BarAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarAnalytics upsert
   */
  export type BarAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the BarAnalytics to update in case it exists.
     */
    where: BarAnalyticsWhereUniqueInput
    /**
     * In case the BarAnalytics found by the `where` argument doesn't exist, create a new BarAnalytics with this data.
     */
    create: XOR<BarAnalyticsCreateInput, BarAnalyticsUncheckedCreateInput>
    /**
     * In case the BarAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarAnalyticsUpdateInput, BarAnalyticsUncheckedUpdateInput>
  }

  /**
   * BarAnalytics delete
   */
  export type BarAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which BarAnalytics to delete.
     */
    where: BarAnalyticsWhereUniqueInput
  }

  /**
   * BarAnalytics deleteMany
   */
  export type BarAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarAnalytics to delete
     */
    where?: BarAnalyticsWhereInput
    /**
     * Limit how many BarAnalytics to delete.
     */
    limit?: number
  }

  /**
   * BarAnalytics without action
   */
  export type BarAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAnalytics
     */
    select?: BarAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAnalytics
     */
    omit?: BarAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model SearchQuery
   */

  export type AggregateSearchQuery = {
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  export type SearchQueryAvgAggregateOutputType = {
    dayOfWeek: number | null
    count: number | null
  }

  export type SearchQuerySumAggregateOutputType = {
    dayOfWeek: number | null
    count: number | null
  }

  export type SearchQueryMinAggregateOutputType = {
    id: string | null
    query: string | null
    location: string | null
    category: string | null
    dayOfWeek: number | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchQueryMaxAggregateOutputType = {
    id: string | null
    query: string | null
    location: string | null
    category: string | null
    dayOfWeek: number | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchQueryCountAggregateOutputType = {
    id: number
    query: number
    location: number
    category: number
    dayOfWeek: number
    count: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SearchQueryAvgAggregateInputType = {
    dayOfWeek?: true
    count?: true
  }

  export type SearchQuerySumAggregateInputType = {
    dayOfWeek?: true
    count?: true
  }

  export type SearchQueryMinAggregateInputType = {
    id?: true
    query?: true
    location?: true
    category?: true
    dayOfWeek?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchQueryMaxAggregateInputType = {
    id?: true
    query?: true
    location?: true
    category?: true
    dayOfWeek?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchQueryCountAggregateInputType = {
    id?: true
    query?: true
    location?: true
    category?: true
    dayOfWeek?: true
    count?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SearchQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQuery to aggregate.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchQueries
    **/
    _count?: true | SearchQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchQueryMaxAggregateInputType
  }

  export type GetSearchQueryAggregateType<T extends SearchQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchQuery[P]>
      : GetScalarType<T[P], AggregateSearchQuery[P]>
  }




  export type SearchQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithAggregationInput | SearchQueryOrderByWithAggregationInput[]
    by: SearchQueryScalarFieldEnum[] | SearchQueryScalarFieldEnum
    having?: SearchQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchQueryCountAggregateInputType | true
    _avg?: SearchQueryAvgAggregateInputType
    _sum?: SearchQuerySumAggregateInputType
    _min?: SearchQueryMinAggregateInputType
    _max?: SearchQueryMaxAggregateInputType
  }

  export type SearchQueryGroupByOutputType = {
    id: string
    query: string
    location: string | null
    category: string | null
    dayOfWeek: number
    count: number
    createdAt: Date
    updatedAt: Date
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  type GetSearchQueryGroupByPayload<T extends SearchQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
        }
      >
    >


  export type SearchQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    location?: boolean
    category?: boolean
    dayOfWeek?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    location?: boolean
    category?: boolean
    dayOfWeek?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    location?: boolean
    category?: boolean
    dayOfWeek?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectScalar = {
    id?: boolean
    query?: boolean
    location?: boolean
    category?: boolean
    dayOfWeek?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SearchQueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "location" | "category" | "dayOfWeek" | "count" | "createdAt" | "updatedAt", ExtArgs["result"]["searchQuery"]>

  export type $SearchQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchQuery"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      location: string | null
      category: string | null
      dayOfWeek: number
      count: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["searchQuery"]>
    composites: {}
  }

  type SearchQueryGetPayload<S extends boolean | null | undefined | SearchQueryDefaultArgs> = $Result.GetResult<Prisma.$SearchQueryPayload, S>

  type SearchQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchQueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchQueryCountAggregateInputType | true
    }

  export interface SearchQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchQuery'], meta: { name: 'SearchQuery' } }
    /**
     * Find zero or one SearchQuery that matches the filter.
     * @param {SearchQueryFindUniqueArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchQueryFindUniqueArgs>(args: SelectSubset<T, SearchQueryFindUniqueArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchQuery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchQueryFindUniqueOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchQueryFindFirstArgs>(args?: SelectSubset<T, SearchQueryFindFirstArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany()
     * 
     * // Get first 10 SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchQueryFindManyArgs>(args?: SelectSubset<T, SearchQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchQuery.
     * @param {SearchQueryCreateArgs} args - Arguments to create a SearchQuery.
     * @example
     * // Create one SearchQuery
     * const SearchQuery = await prisma.searchQuery.create({
     *   data: {
     *     // ... data to create a SearchQuery
     *   }
     * })
     * 
     */
    create<T extends SearchQueryCreateArgs>(args: SelectSubset<T, SearchQueryCreateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchQueries.
     * @param {SearchQueryCreateManyArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchQueryCreateManyArgs>(args?: SelectSubset<T, SearchQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchQueries and returns the data saved in the database.
     * @param {SearchQueryCreateManyAndReturnArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchQuery.
     * @param {SearchQueryDeleteArgs} args - Arguments to delete one SearchQuery.
     * @example
     * // Delete one SearchQuery
     * const SearchQuery = await prisma.searchQuery.delete({
     *   where: {
     *     // ... filter to delete one SearchQuery
     *   }
     * })
     * 
     */
    delete<T extends SearchQueryDeleteArgs>(args: SelectSubset<T, SearchQueryDeleteArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchQuery.
     * @param {SearchQueryUpdateArgs} args - Arguments to update one SearchQuery.
     * @example
     * // Update one SearchQuery
     * const searchQuery = await prisma.searchQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchQueryUpdateArgs>(args: SelectSubset<T, SearchQueryUpdateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchQueries.
     * @param {SearchQueryDeleteManyArgs} args - Arguments to filter SearchQueries to delete.
     * @example
     * // Delete a few SearchQueries
     * const { count } = await prisma.searchQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchQueryDeleteManyArgs>(args?: SelectSubset<T, SearchQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchQueryUpdateManyArgs>(args: SelectSubset<T, SearchQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries and returns the data updated in the database.
     * @param {SearchQueryUpdateManyAndReturnArgs} args - Arguments to update many SearchQueries.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchQueryUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchQueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchQuery.
     * @param {SearchQueryUpsertArgs} args - Arguments to update or create a SearchQuery.
     * @example
     * // Update or create a SearchQuery
     * const searchQuery = await prisma.searchQuery.upsert({
     *   create: {
     *     // ... data to create a SearchQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchQuery we want to update
     *   }
     * })
     */
    upsert<T extends SearchQueryUpsertArgs>(args: SelectSubset<T, SearchQueryUpsertArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryCountArgs} args - Arguments to filter SearchQueries to count.
     * @example
     * // Count the number of SearchQueries
     * const count = await prisma.searchQuery.count({
     *   where: {
     *     // ... the filter for the SearchQueries we want to count
     *   }
     * })
    **/
    count<T extends SearchQueryCountArgs>(
      args?: Subset<T, SearchQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchQueryAggregateArgs>(args: Subset<T, SearchQueryAggregateArgs>): Prisma.PrismaPromise<GetSearchQueryAggregateType<T>>

    /**
     * Group by SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchQueryGroupByArgs['orderBy'] }
        : { orderBy?: SearchQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchQuery model
   */
  readonly fields: SearchQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchQuery model
   */
  interface SearchQueryFieldRefs {
    readonly id: FieldRef<"SearchQuery", 'String'>
    readonly query: FieldRef<"SearchQuery", 'String'>
    readonly location: FieldRef<"SearchQuery", 'String'>
    readonly category: FieldRef<"SearchQuery", 'String'>
    readonly dayOfWeek: FieldRef<"SearchQuery", 'Int'>
    readonly count: FieldRef<"SearchQuery", 'Int'>
    readonly createdAt: FieldRef<"SearchQuery", 'DateTime'>
    readonly updatedAt: FieldRef<"SearchQuery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchQuery findUnique
   */
  export type SearchQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findUniqueOrThrow
   */
  export type SearchQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findFirst
   */
  export type SearchQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findFirstOrThrow
   */
  export type SearchQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findMany
   */
  export type SearchQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter, which SearchQueries to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery create
   */
  export type SearchQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data needed to create a SearchQuery.
     */
    data: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
  }

  /**
   * SearchQuery createMany
   */
  export type SearchQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery createManyAndReturn
   */
  export type SearchQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery update
   */
  export type SearchQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data needed to update a SearchQuery.
     */
    data: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    /**
     * Choose, which SearchQuery to update.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery updateMany
   */
  export type SearchQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
  }

  /**
   * SearchQuery updateManyAndReturn
   */
  export type SearchQueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
  }

  /**
   * SearchQuery upsert
   */
  export type SearchQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The filter to search for the SearchQuery to update in case it exists.
     */
    where: SearchQueryWhereUniqueInput
    /**
     * In case the SearchQuery found by the `where` argument doesn't exist, create a new SearchQuery with this data.
     */
    create: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    /**
     * In case the SearchQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
  }

  /**
   * SearchQuery delete
   */
  export type SearchQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Filter which SearchQuery to delete.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery deleteMany
   */
  export type SearchQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQueries to delete
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to delete.
     */
    limit?: number
  }

  /**
   * SearchQuery without action
   */
  export type SearchQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
  }


  /**
   * Model BarClick
   */

  export type AggregateBarClick = {
    _count: BarClickCountAggregateOutputType | null
    _avg: BarClickAvgAggregateOutputType | null
    _sum: BarClickSumAggregateOutputType | null
    _min: BarClickMinAggregateOutputType | null
    _max: BarClickMaxAggregateOutputType | null
  }

  export type BarClickAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BarClickSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BarClickMinAggregateOutputType = {
    id: string | null
    barId: string | null
    source: string | null
    query: string | null
    dayOfWeek: number | null
    createdAt: Date | null
  }

  export type BarClickMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    source: string | null
    query: string | null
    dayOfWeek: number | null
    createdAt: Date | null
  }

  export type BarClickCountAggregateOutputType = {
    id: number
    barId: number
    source: number
    query: number
    dayOfWeek: number
    createdAt: number
    _all: number
  }


  export type BarClickAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type BarClickSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type BarClickMinAggregateInputType = {
    id?: true
    barId?: true
    source?: true
    query?: true
    dayOfWeek?: true
    createdAt?: true
  }

  export type BarClickMaxAggregateInputType = {
    id?: true
    barId?: true
    source?: true
    query?: true
    dayOfWeek?: true
    createdAt?: true
  }

  export type BarClickCountAggregateInputType = {
    id?: true
    barId?: true
    source?: true
    query?: true
    dayOfWeek?: true
    createdAt?: true
    _all?: true
  }

  export type BarClickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarClick to aggregate.
     */
    where?: BarClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarClicks to fetch.
     */
    orderBy?: BarClickOrderByWithRelationInput | BarClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarClicks
    **/
    _count?: true | BarClickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarClickAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarClickSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarClickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarClickMaxAggregateInputType
  }

  export type GetBarClickAggregateType<T extends BarClickAggregateArgs> = {
        [P in keyof T & keyof AggregateBarClick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarClick[P]>
      : GetScalarType<T[P], AggregateBarClick[P]>
  }




  export type BarClickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarClickWhereInput
    orderBy?: BarClickOrderByWithAggregationInput | BarClickOrderByWithAggregationInput[]
    by: BarClickScalarFieldEnum[] | BarClickScalarFieldEnum
    having?: BarClickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarClickCountAggregateInputType | true
    _avg?: BarClickAvgAggregateInputType
    _sum?: BarClickSumAggregateInputType
    _min?: BarClickMinAggregateInputType
    _max?: BarClickMaxAggregateInputType
  }

  export type BarClickGroupByOutputType = {
    id: string
    barId: string
    source: string
    query: string | null
    dayOfWeek: number
    createdAt: Date
    _count: BarClickCountAggregateOutputType | null
    _avg: BarClickAvgAggregateOutputType | null
    _sum: BarClickSumAggregateOutputType | null
    _min: BarClickMinAggregateOutputType | null
    _max: BarClickMaxAggregateOutputType | null
  }

  type GetBarClickGroupByPayload<T extends BarClickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarClickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarClickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarClickGroupByOutputType[P]>
            : GetScalarType<T[P], BarClickGroupByOutputType[P]>
        }
      >
    >


  export type BarClickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    source?: boolean
    query?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barClick"]>

  export type BarClickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    source?: boolean
    query?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barClick"]>

  export type BarClickSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    source?: boolean
    query?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barClick"]>

  export type BarClickSelectScalar = {
    id?: boolean
    barId?: boolean
    source?: boolean
    query?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
  }

  export type BarClickOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "source" | "query" | "dayOfWeek" | "createdAt", ExtArgs["result"]["barClick"]>
  export type BarClickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarClickIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarClickIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $BarClickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarClick"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      source: string
      query: string | null
      dayOfWeek: number
      createdAt: Date
    }, ExtArgs["result"]["barClick"]>
    composites: {}
  }

  type BarClickGetPayload<S extends boolean | null | undefined | BarClickDefaultArgs> = $Result.GetResult<Prisma.$BarClickPayload, S>

  type BarClickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarClickFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarClickCountAggregateInputType | true
    }

  export interface BarClickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarClick'], meta: { name: 'BarClick' } }
    /**
     * Find zero or one BarClick that matches the filter.
     * @param {BarClickFindUniqueArgs} args - Arguments to find a BarClick
     * @example
     * // Get one BarClick
     * const barClick = await prisma.barClick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarClickFindUniqueArgs>(args: SelectSubset<T, BarClickFindUniqueArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarClick that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarClickFindUniqueOrThrowArgs} args - Arguments to find a BarClick
     * @example
     * // Get one BarClick
     * const barClick = await prisma.barClick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarClickFindUniqueOrThrowArgs>(args: SelectSubset<T, BarClickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarClick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickFindFirstArgs} args - Arguments to find a BarClick
     * @example
     * // Get one BarClick
     * const barClick = await prisma.barClick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarClickFindFirstArgs>(args?: SelectSubset<T, BarClickFindFirstArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarClick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickFindFirstOrThrowArgs} args - Arguments to find a BarClick
     * @example
     * // Get one BarClick
     * const barClick = await prisma.barClick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarClickFindFirstOrThrowArgs>(args?: SelectSubset<T, BarClickFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarClicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarClicks
     * const barClicks = await prisma.barClick.findMany()
     * 
     * // Get first 10 BarClicks
     * const barClicks = await prisma.barClick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barClickWithIdOnly = await prisma.barClick.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarClickFindManyArgs>(args?: SelectSubset<T, BarClickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarClick.
     * @param {BarClickCreateArgs} args - Arguments to create a BarClick.
     * @example
     * // Create one BarClick
     * const BarClick = await prisma.barClick.create({
     *   data: {
     *     // ... data to create a BarClick
     *   }
     * })
     * 
     */
    create<T extends BarClickCreateArgs>(args: SelectSubset<T, BarClickCreateArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarClicks.
     * @param {BarClickCreateManyArgs} args - Arguments to create many BarClicks.
     * @example
     * // Create many BarClicks
     * const barClick = await prisma.barClick.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarClickCreateManyArgs>(args?: SelectSubset<T, BarClickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarClicks and returns the data saved in the database.
     * @param {BarClickCreateManyAndReturnArgs} args - Arguments to create many BarClicks.
     * @example
     * // Create many BarClicks
     * const barClick = await prisma.barClick.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarClicks and only return the `id`
     * const barClickWithIdOnly = await prisma.barClick.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarClickCreateManyAndReturnArgs>(args?: SelectSubset<T, BarClickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarClick.
     * @param {BarClickDeleteArgs} args - Arguments to delete one BarClick.
     * @example
     * // Delete one BarClick
     * const BarClick = await prisma.barClick.delete({
     *   where: {
     *     // ... filter to delete one BarClick
     *   }
     * })
     * 
     */
    delete<T extends BarClickDeleteArgs>(args: SelectSubset<T, BarClickDeleteArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarClick.
     * @param {BarClickUpdateArgs} args - Arguments to update one BarClick.
     * @example
     * // Update one BarClick
     * const barClick = await prisma.barClick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarClickUpdateArgs>(args: SelectSubset<T, BarClickUpdateArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarClicks.
     * @param {BarClickDeleteManyArgs} args - Arguments to filter BarClicks to delete.
     * @example
     * // Delete a few BarClicks
     * const { count } = await prisma.barClick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarClickDeleteManyArgs>(args?: SelectSubset<T, BarClickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarClicks
     * const barClick = await prisma.barClick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarClickUpdateManyArgs>(args: SelectSubset<T, BarClickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarClicks and returns the data updated in the database.
     * @param {BarClickUpdateManyAndReturnArgs} args - Arguments to update many BarClicks.
     * @example
     * // Update many BarClicks
     * const barClick = await prisma.barClick.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarClicks and only return the `id`
     * const barClickWithIdOnly = await prisma.barClick.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarClickUpdateManyAndReturnArgs>(args: SelectSubset<T, BarClickUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarClick.
     * @param {BarClickUpsertArgs} args - Arguments to update or create a BarClick.
     * @example
     * // Update or create a BarClick
     * const barClick = await prisma.barClick.upsert({
     *   create: {
     *     // ... data to create a BarClick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarClick we want to update
     *   }
     * })
     */
    upsert<T extends BarClickUpsertArgs>(args: SelectSubset<T, BarClickUpsertArgs<ExtArgs>>): Prisma__BarClickClient<$Result.GetResult<Prisma.$BarClickPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickCountArgs} args - Arguments to filter BarClicks to count.
     * @example
     * // Count the number of BarClicks
     * const count = await prisma.barClick.count({
     *   where: {
     *     // ... the filter for the BarClicks we want to count
     *   }
     * })
    **/
    count<T extends BarClickCountArgs>(
      args?: Subset<T, BarClickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarClickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarClickAggregateArgs>(args: Subset<T, BarClickAggregateArgs>): Prisma.PrismaPromise<GetBarClickAggregateType<T>>

    /**
     * Group by BarClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarClickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarClickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarClickGroupByArgs['orderBy'] }
        : { orderBy?: BarClickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarClickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarClickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarClick model
   */
  readonly fields: BarClickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarClick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarClickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarClick model
   */
  interface BarClickFieldRefs {
    readonly id: FieldRef<"BarClick", 'String'>
    readonly barId: FieldRef<"BarClick", 'String'>
    readonly source: FieldRef<"BarClick", 'String'>
    readonly query: FieldRef<"BarClick", 'String'>
    readonly dayOfWeek: FieldRef<"BarClick", 'Int'>
    readonly createdAt: FieldRef<"BarClick", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarClick findUnique
   */
  export type BarClickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * Filter, which BarClick to fetch.
     */
    where: BarClickWhereUniqueInput
  }

  /**
   * BarClick findUniqueOrThrow
   */
  export type BarClickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * Filter, which BarClick to fetch.
     */
    where: BarClickWhereUniqueInput
  }

  /**
   * BarClick findFirst
   */
  export type BarClickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * Filter, which BarClick to fetch.
     */
    where?: BarClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarClicks to fetch.
     */
    orderBy?: BarClickOrderByWithRelationInput | BarClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarClicks.
     */
    cursor?: BarClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarClicks.
     */
    distinct?: BarClickScalarFieldEnum | BarClickScalarFieldEnum[]
  }

  /**
   * BarClick findFirstOrThrow
   */
  export type BarClickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * Filter, which BarClick to fetch.
     */
    where?: BarClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarClicks to fetch.
     */
    orderBy?: BarClickOrderByWithRelationInput | BarClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarClicks.
     */
    cursor?: BarClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarClicks.
     */
    distinct?: BarClickScalarFieldEnum | BarClickScalarFieldEnum[]
  }

  /**
   * BarClick findMany
   */
  export type BarClickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * Filter, which BarClicks to fetch.
     */
    where?: BarClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarClicks to fetch.
     */
    orderBy?: BarClickOrderByWithRelationInput | BarClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarClicks.
     */
    cursor?: BarClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarClicks.
     */
    skip?: number
    distinct?: BarClickScalarFieldEnum | BarClickScalarFieldEnum[]
  }

  /**
   * BarClick create
   */
  export type BarClickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * The data needed to create a BarClick.
     */
    data: XOR<BarClickCreateInput, BarClickUncheckedCreateInput>
  }

  /**
   * BarClick createMany
   */
  export type BarClickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarClicks.
     */
    data: BarClickCreateManyInput | BarClickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarClick createManyAndReturn
   */
  export type BarClickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * The data used to create many BarClicks.
     */
    data: BarClickCreateManyInput | BarClickCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarClick update
   */
  export type BarClickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * The data needed to update a BarClick.
     */
    data: XOR<BarClickUpdateInput, BarClickUncheckedUpdateInput>
    /**
     * Choose, which BarClick to update.
     */
    where: BarClickWhereUniqueInput
  }

  /**
   * BarClick updateMany
   */
  export type BarClickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarClicks.
     */
    data: XOR<BarClickUpdateManyMutationInput, BarClickUncheckedUpdateManyInput>
    /**
     * Filter which BarClicks to update
     */
    where?: BarClickWhereInput
    /**
     * Limit how many BarClicks to update.
     */
    limit?: number
  }

  /**
   * BarClick updateManyAndReturn
   */
  export type BarClickUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * The data used to update BarClicks.
     */
    data: XOR<BarClickUpdateManyMutationInput, BarClickUncheckedUpdateManyInput>
    /**
     * Filter which BarClicks to update
     */
    where?: BarClickWhereInput
    /**
     * Limit how many BarClicks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarClick upsert
   */
  export type BarClickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * The filter to search for the BarClick to update in case it exists.
     */
    where: BarClickWhereUniqueInput
    /**
     * In case the BarClick found by the `where` argument doesn't exist, create a new BarClick with this data.
     */
    create: XOR<BarClickCreateInput, BarClickUncheckedCreateInput>
    /**
     * In case the BarClick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarClickUpdateInput, BarClickUncheckedUpdateInput>
  }

  /**
   * BarClick delete
   */
  export type BarClickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
    /**
     * Filter which BarClick to delete.
     */
    where: BarClickWhereUniqueInput
  }

  /**
   * BarClick deleteMany
   */
  export type BarClickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarClicks to delete
     */
    where?: BarClickWhereInput
    /**
     * Limit how many BarClicks to delete.
     */
    limit?: number
  }

  /**
   * BarClick without action
   */
  export type BarClickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarClick
     */
    select?: BarClickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarClick
     */
    omit?: BarClickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarClickInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type BadgeSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    icon: string | null
    tier: $Enums.BadgeTier | null
    category: $Enums.BadgeCategory | null
    requirement: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    icon: string | null
    tier: $Enums.BadgeTier | null
    category: $Enums.BadgeCategory | null
    requirement: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    icon: number
    tier: number
    category: number
    requirement: number
    color: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    sortOrder?: true
  }

  export type BadgeSumAggregateInputType = {
    sortOrder?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    icon?: true
    tier?: true
    category?: true
    requirement?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    icon?: true
    tier?: true
    category?: true
    requirement?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    icon?: true
    tier?: true
    category?: true
    requirement?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string
    icon: string
    tier: $Enums.BadgeTier
    category: $Enums.BadgeCategory
    requirement: string
    color: string
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    tier?: boolean
    category?: boolean
    requirement?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barBadges?: boolean | Badge$barBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    tier?: boolean
    category?: boolean
    requirement?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    tier?: boolean
    category?: boolean
    requirement?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    tier?: boolean
    category?: boolean
    requirement?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "description" | "icon" | "tier" | "category" | "requirement" | "color" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barBadges?: boolean | Badge$barBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      barBadges: Prisma.$BarBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string
      icon: string
      tier: $Enums.BadgeTier
      category: $Enums.BadgeCategory
      requirement: string
      color: string
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barBadges<T extends Badge$barBadgesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$barBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly key: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly icon: FieldRef<"Badge", 'String'>
    readonly tier: FieldRef<"Badge", 'BadgeTier'>
    readonly category: FieldRef<"Badge", 'BadgeCategory'>
    readonly requirement: FieldRef<"Badge", 'String'>
    readonly color: FieldRef<"Badge", 'String'>
    readonly isActive: FieldRef<"Badge", 'Boolean'>
    readonly sortOrder: FieldRef<"Badge", 'Int'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly updatedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.barBadges
   */
  export type Badge$barBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    where?: BarBadgeWhereInput
    orderBy?: BarBadgeOrderByWithRelationInput | BarBadgeOrderByWithRelationInput[]
    cursor?: BarBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarBadgeScalarFieldEnum | BarBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model BarBadge
   */

  export type AggregateBarBadge = {
    _count: BarBadgeCountAggregateOutputType | null
    _min: BarBadgeMinAggregateOutputType | null
    _max: BarBadgeMaxAggregateOutputType | null
  }

  export type BarBadgeMinAggregateOutputType = {
    id: string | null
    barId: string | null
    badgeKey: string | null
    awardedAt: Date | null
  }

  export type BarBadgeMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    badgeKey: string | null
    awardedAt: Date | null
  }

  export type BarBadgeCountAggregateOutputType = {
    id: number
    barId: number
    badgeKey: number
    awardedAt: number
    progress: number
    metadata: number
    _all: number
  }


  export type BarBadgeMinAggregateInputType = {
    id?: true
    barId?: true
    badgeKey?: true
    awardedAt?: true
  }

  export type BarBadgeMaxAggregateInputType = {
    id?: true
    barId?: true
    badgeKey?: true
    awardedAt?: true
  }

  export type BarBadgeCountAggregateInputType = {
    id?: true
    barId?: true
    badgeKey?: true
    awardedAt?: true
    progress?: true
    metadata?: true
    _all?: true
  }

  export type BarBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarBadge to aggregate.
     */
    where?: BarBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarBadges to fetch.
     */
    orderBy?: BarBadgeOrderByWithRelationInput | BarBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarBadges
    **/
    _count?: true | BarBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarBadgeMaxAggregateInputType
  }

  export type GetBarBadgeAggregateType<T extends BarBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBarBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarBadge[P]>
      : GetScalarType<T[P], AggregateBarBadge[P]>
  }




  export type BarBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarBadgeWhereInput
    orderBy?: BarBadgeOrderByWithAggregationInput | BarBadgeOrderByWithAggregationInput[]
    by: BarBadgeScalarFieldEnum[] | BarBadgeScalarFieldEnum
    having?: BarBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarBadgeCountAggregateInputType | true
    _min?: BarBadgeMinAggregateInputType
    _max?: BarBadgeMaxAggregateInputType
  }

  export type BarBadgeGroupByOutputType = {
    id: string
    barId: string
    badgeKey: string
    awardedAt: Date
    progress: JsonValue | null
    metadata: JsonValue | null
    _count: BarBadgeCountAggregateOutputType | null
    _min: BarBadgeMinAggregateOutputType | null
    _max: BarBadgeMaxAggregateOutputType | null
  }

  type GetBarBadgeGroupByPayload<T extends BarBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BarBadgeGroupByOutputType[P]>
        }
      >
    >


  export type BarBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    badgeKey?: boolean
    awardedAt?: boolean
    progress?: boolean
    metadata?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barBadge"]>

  export type BarBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    badgeKey?: boolean
    awardedAt?: boolean
    progress?: boolean
    metadata?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barBadge"]>

  export type BarBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    badgeKey?: boolean
    awardedAt?: boolean
    progress?: boolean
    metadata?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barBadge"]>

  export type BarBadgeSelectScalar = {
    id?: boolean
    barId?: boolean
    badgeKey?: boolean
    awardedAt?: boolean
    progress?: boolean
    metadata?: boolean
  }

  export type BarBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "badgeKey" | "awardedAt" | "progress" | "metadata", ExtArgs["result"]["barBadge"]>
  export type BarBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type BarBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type BarBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $BarBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarBadge"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      badgeKey: string
      awardedAt: Date
      progress: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["barBadge"]>
    composites: {}
  }

  type BarBadgeGetPayload<S extends boolean | null | undefined | BarBadgeDefaultArgs> = $Result.GetResult<Prisma.$BarBadgePayload, S>

  type BarBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarBadgeCountAggregateInputType | true
    }

  export interface BarBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarBadge'], meta: { name: 'BarBadge' } }
    /**
     * Find zero or one BarBadge that matches the filter.
     * @param {BarBadgeFindUniqueArgs} args - Arguments to find a BarBadge
     * @example
     * // Get one BarBadge
     * const barBadge = await prisma.barBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarBadgeFindUniqueArgs>(args: SelectSubset<T, BarBadgeFindUniqueArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarBadgeFindUniqueOrThrowArgs} args - Arguments to find a BarBadge
     * @example
     * // Get one BarBadge
     * const barBadge = await prisma.barBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BarBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeFindFirstArgs} args - Arguments to find a BarBadge
     * @example
     * // Get one BarBadge
     * const barBadge = await prisma.barBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarBadgeFindFirstArgs>(args?: SelectSubset<T, BarBadgeFindFirstArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeFindFirstOrThrowArgs} args - Arguments to find a BarBadge
     * @example
     * // Get one BarBadge
     * const barBadge = await prisma.barBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BarBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarBadges
     * const barBadges = await prisma.barBadge.findMany()
     * 
     * // Get first 10 BarBadges
     * const barBadges = await prisma.barBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barBadgeWithIdOnly = await prisma.barBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarBadgeFindManyArgs>(args?: SelectSubset<T, BarBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarBadge.
     * @param {BarBadgeCreateArgs} args - Arguments to create a BarBadge.
     * @example
     * // Create one BarBadge
     * const BarBadge = await prisma.barBadge.create({
     *   data: {
     *     // ... data to create a BarBadge
     *   }
     * })
     * 
     */
    create<T extends BarBadgeCreateArgs>(args: SelectSubset<T, BarBadgeCreateArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarBadges.
     * @param {BarBadgeCreateManyArgs} args - Arguments to create many BarBadges.
     * @example
     * // Create many BarBadges
     * const barBadge = await prisma.barBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarBadgeCreateManyArgs>(args?: SelectSubset<T, BarBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarBadges and returns the data saved in the database.
     * @param {BarBadgeCreateManyAndReturnArgs} args - Arguments to create many BarBadges.
     * @example
     * // Create many BarBadges
     * const barBadge = await prisma.barBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarBadges and only return the `id`
     * const barBadgeWithIdOnly = await prisma.barBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BarBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarBadge.
     * @param {BarBadgeDeleteArgs} args - Arguments to delete one BarBadge.
     * @example
     * // Delete one BarBadge
     * const BarBadge = await prisma.barBadge.delete({
     *   where: {
     *     // ... filter to delete one BarBadge
     *   }
     * })
     * 
     */
    delete<T extends BarBadgeDeleteArgs>(args: SelectSubset<T, BarBadgeDeleteArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarBadge.
     * @param {BarBadgeUpdateArgs} args - Arguments to update one BarBadge.
     * @example
     * // Update one BarBadge
     * const barBadge = await prisma.barBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarBadgeUpdateArgs>(args: SelectSubset<T, BarBadgeUpdateArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarBadges.
     * @param {BarBadgeDeleteManyArgs} args - Arguments to filter BarBadges to delete.
     * @example
     * // Delete a few BarBadges
     * const { count } = await prisma.barBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarBadgeDeleteManyArgs>(args?: SelectSubset<T, BarBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarBadges
     * const barBadge = await prisma.barBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarBadgeUpdateManyArgs>(args: SelectSubset<T, BarBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarBadges and returns the data updated in the database.
     * @param {BarBadgeUpdateManyAndReturnArgs} args - Arguments to update many BarBadges.
     * @example
     * // Update many BarBadges
     * const barBadge = await prisma.barBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarBadges and only return the `id`
     * const barBadgeWithIdOnly = await prisma.barBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BarBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarBadge.
     * @param {BarBadgeUpsertArgs} args - Arguments to update or create a BarBadge.
     * @example
     * // Update or create a BarBadge
     * const barBadge = await prisma.barBadge.upsert({
     *   create: {
     *     // ... data to create a BarBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarBadge we want to update
     *   }
     * })
     */
    upsert<T extends BarBadgeUpsertArgs>(args: SelectSubset<T, BarBadgeUpsertArgs<ExtArgs>>): Prisma__BarBadgeClient<$Result.GetResult<Prisma.$BarBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeCountArgs} args - Arguments to filter BarBadges to count.
     * @example
     * // Count the number of BarBadges
     * const count = await prisma.barBadge.count({
     *   where: {
     *     // ... the filter for the BarBadges we want to count
     *   }
     * })
    **/
    count<T extends BarBadgeCountArgs>(
      args?: Subset<T, BarBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarBadgeAggregateArgs>(args: Subset<T, BarBadgeAggregateArgs>): Prisma.PrismaPromise<GetBarBadgeAggregateType<T>>

    /**
     * Group by BarBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarBadgeGroupByArgs['orderBy'] }
        : { orderBy?: BarBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarBadge model
   */
  readonly fields: BarBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarBadge model
   */
  interface BarBadgeFieldRefs {
    readonly id: FieldRef<"BarBadge", 'String'>
    readonly barId: FieldRef<"BarBadge", 'String'>
    readonly badgeKey: FieldRef<"BarBadge", 'String'>
    readonly awardedAt: FieldRef<"BarBadge", 'DateTime'>
    readonly progress: FieldRef<"BarBadge", 'Json'>
    readonly metadata: FieldRef<"BarBadge", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * BarBadge findUnique
   */
  export type BarBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * Filter, which BarBadge to fetch.
     */
    where: BarBadgeWhereUniqueInput
  }

  /**
   * BarBadge findUniqueOrThrow
   */
  export type BarBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * Filter, which BarBadge to fetch.
     */
    where: BarBadgeWhereUniqueInput
  }

  /**
   * BarBadge findFirst
   */
  export type BarBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * Filter, which BarBadge to fetch.
     */
    where?: BarBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarBadges to fetch.
     */
    orderBy?: BarBadgeOrderByWithRelationInput | BarBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarBadges.
     */
    cursor?: BarBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarBadges.
     */
    distinct?: BarBadgeScalarFieldEnum | BarBadgeScalarFieldEnum[]
  }

  /**
   * BarBadge findFirstOrThrow
   */
  export type BarBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * Filter, which BarBadge to fetch.
     */
    where?: BarBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarBadges to fetch.
     */
    orderBy?: BarBadgeOrderByWithRelationInput | BarBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarBadges.
     */
    cursor?: BarBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarBadges.
     */
    distinct?: BarBadgeScalarFieldEnum | BarBadgeScalarFieldEnum[]
  }

  /**
   * BarBadge findMany
   */
  export type BarBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * Filter, which BarBadges to fetch.
     */
    where?: BarBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarBadges to fetch.
     */
    orderBy?: BarBadgeOrderByWithRelationInput | BarBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarBadges.
     */
    cursor?: BarBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarBadges.
     */
    skip?: number
    distinct?: BarBadgeScalarFieldEnum | BarBadgeScalarFieldEnum[]
  }

  /**
   * BarBadge create
   */
  export type BarBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a BarBadge.
     */
    data: XOR<BarBadgeCreateInput, BarBadgeUncheckedCreateInput>
  }

  /**
   * BarBadge createMany
   */
  export type BarBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarBadges.
     */
    data: BarBadgeCreateManyInput | BarBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarBadge createManyAndReturn
   */
  export type BarBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many BarBadges.
     */
    data: BarBadgeCreateManyInput | BarBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarBadge update
   */
  export type BarBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a BarBadge.
     */
    data: XOR<BarBadgeUpdateInput, BarBadgeUncheckedUpdateInput>
    /**
     * Choose, which BarBadge to update.
     */
    where: BarBadgeWhereUniqueInput
  }

  /**
   * BarBadge updateMany
   */
  export type BarBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarBadges.
     */
    data: XOR<BarBadgeUpdateManyMutationInput, BarBadgeUncheckedUpdateManyInput>
    /**
     * Filter which BarBadges to update
     */
    where?: BarBadgeWhereInput
    /**
     * Limit how many BarBadges to update.
     */
    limit?: number
  }

  /**
   * BarBadge updateManyAndReturn
   */
  export type BarBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * The data used to update BarBadges.
     */
    data: XOR<BarBadgeUpdateManyMutationInput, BarBadgeUncheckedUpdateManyInput>
    /**
     * Filter which BarBadges to update
     */
    where?: BarBadgeWhereInput
    /**
     * Limit how many BarBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarBadge upsert
   */
  export type BarBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the BarBadge to update in case it exists.
     */
    where: BarBadgeWhereUniqueInput
    /**
     * In case the BarBadge found by the `where` argument doesn't exist, create a new BarBadge with this data.
     */
    create: XOR<BarBadgeCreateInput, BarBadgeUncheckedCreateInput>
    /**
     * In case the BarBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarBadgeUpdateInput, BarBadgeUncheckedUpdateInput>
  }

  /**
   * BarBadge delete
   */
  export type BarBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
    /**
     * Filter which BarBadge to delete.
     */
    where: BarBadgeWhereUniqueInput
  }

  /**
   * BarBadge deleteMany
   */
  export type BarBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarBadges to delete
     */
    where?: BarBadgeWhereInput
    /**
     * Limit how many BarBadges to delete.
     */
    limit?: number
  }

  /**
   * BarBadge without action
   */
  export type BarBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarBadge
     */
    select?: BarBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarBadge
     */
    omit?: BarBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarBadgeInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    bottleSizeMl: number | null
    startingQtyBottles: number | null
    costPerBottle: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    bottleSizeMl: number | null
    startingQtyBottles: number | null
    costPerBottle: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    category: string | null
    bottleSizeMl: number | null
    startingQtyBottles: number | null
    costPerBottle: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    category: string | null
    bottleSizeMl: number | null
    startingQtyBottles: number | null
    costPerBottle: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    barId: number
    name: number
    category: number
    bottleSizeMl: number
    startingQtyBottles: number
    costPerBottle: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    bottleSizeMl?: true
    startingQtyBottles?: true
    costPerBottle?: true
  }

  export type InventoryItemSumAggregateInputType = {
    bottleSizeMl?: true
    startingQtyBottles?: true
    costPerBottle?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    category?: true
    bottleSizeMl?: true
    startingQtyBottles?: true
    costPerBottle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    category?: true
    bottleSizeMl?: true
    startingQtyBottles?: true
    costPerBottle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    category?: true
    bottleSizeMl?: true
    startingQtyBottles?: true
    costPerBottle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    barId: string
    name: string
    category: string | null
    bottleSizeMl: number
    startingQtyBottles: number
    costPerBottle: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    category?: boolean
    bottleSizeMl?: boolean
    startingQtyBottles?: boolean
    costPerBottle?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    snapshotItems?: boolean | InventoryItem$snapshotItemsArgs<ExtArgs>
    shiftUsageItems?: boolean | InventoryItem$shiftUsageItemsArgs<ExtArgs>
    costingProfiles?: boolean | InventoryItem$costingProfilesArgs<ExtArgs>
    varianceAlerts?: boolean | InventoryItem$varianceAlertsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    category?: boolean
    bottleSizeMl?: boolean
    startingQtyBottles?: boolean
    costPerBottle?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    category?: boolean
    bottleSizeMl?: boolean
    startingQtyBottles?: boolean
    costPerBottle?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    barId?: boolean
    name?: boolean
    category?: boolean
    bottleSizeMl?: boolean
    startingQtyBottles?: boolean
    costPerBottle?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "name" | "category" | "bottleSizeMl" | "startingQtyBottles" | "costPerBottle" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    snapshotItems?: boolean | InventoryItem$snapshotItemsArgs<ExtArgs>
    shiftUsageItems?: boolean | InventoryItem$shiftUsageItemsArgs<ExtArgs>
    costingProfiles?: boolean | InventoryItem$costingProfilesArgs<ExtArgs>
    varianceAlerts?: boolean | InventoryItem$varianceAlertsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      snapshotItems: Prisma.$InventorySnapshotItemPayload<ExtArgs>[]
      shiftUsageItems: Prisma.$ShiftUsageItemPayload<ExtArgs>[]
      costingProfiles: Prisma.$CostingProfilePayload<ExtArgs>[]
      varianceAlerts: Prisma.$VarianceAlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      name: string
      category: string | null
      bottleSizeMl: number
      startingQtyBottles: number
      costPerBottle: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    snapshotItems<T extends InventoryItem$snapshotItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$snapshotItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shiftUsageItems<T extends InventoryItem$shiftUsageItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$shiftUsageItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    costingProfiles<T extends InventoryItem$costingProfilesArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$costingProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    varianceAlerts<T extends InventoryItem$varianceAlertsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$varianceAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly barId: FieldRef<"InventoryItem", 'String'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly category: FieldRef<"InventoryItem", 'String'>
    readonly bottleSizeMl: FieldRef<"InventoryItem", 'Int'>
    readonly startingQtyBottles: FieldRef<"InventoryItem", 'Int'>
    readonly costPerBottle: FieldRef<"InventoryItem", 'Decimal'>
    readonly isActive: FieldRef<"InventoryItem", 'Boolean'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.snapshotItems
   */
  export type InventoryItem$snapshotItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    where?: InventorySnapshotItemWhereInput
    orderBy?: InventorySnapshotItemOrderByWithRelationInput | InventorySnapshotItemOrderByWithRelationInput[]
    cursor?: InventorySnapshotItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySnapshotItemScalarFieldEnum | InventorySnapshotItemScalarFieldEnum[]
  }

  /**
   * InventoryItem.shiftUsageItems
   */
  export type InventoryItem$shiftUsageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    where?: ShiftUsageItemWhereInput
    orderBy?: ShiftUsageItemOrderByWithRelationInput | ShiftUsageItemOrderByWithRelationInput[]
    cursor?: ShiftUsageItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftUsageItemScalarFieldEnum | ShiftUsageItemScalarFieldEnum[]
  }

  /**
   * InventoryItem.costingProfiles
   */
  export type InventoryItem$costingProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    where?: CostingProfileWhereInput
    orderBy?: CostingProfileOrderByWithRelationInput | CostingProfileOrderByWithRelationInput[]
    cursor?: CostingProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostingProfileScalarFieldEnum | CostingProfileScalarFieldEnum[]
  }

  /**
   * InventoryItem.varianceAlerts
   */
  export type InventoryItem$varianceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    where?: VarianceAlertWhereInput
    orderBy?: VarianceAlertOrderByWithRelationInput | VarianceAlertOrderByWithRelationInput[]
    cursor?: VarianceAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VarianceAlertScalarFieldEnum | VarianceAlertScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryImport
   */

  export type AggregateInventoryImport = {
    _count: InventoryImportCountAggregateOutputType | null
    _avg: InventoryImportAvgAggregateOutputType | null
    _sum: InventoryImportSumAggregateOutputType | null
    _min: InventoryImportMinAggregateOutputType | null
    _max: InventoryImportMaxAggregateOutputType | null
  }

  export type InventoryImportAvgAggregateOutputType = {
    rowsImported: number | null
  }

  export type InventoryImportSumAggregateOutputType = {
    rowsImported: number | null
  }

  export type InventoryImportMinAggregateOutputType = {
    id: string | null
    barId: string | null
    fileName: string | null
    rowsImported: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type InventoryImportMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    fileName: string | null
    rowsImported: number | null
    createdById: string | null
    createdAt: Date | null
  }

  export type InventoryImportCountAggregateOutputType = {
    id: number
    barId: number
    fileName: number
    rowsImported: number
    mapping: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type InventoryImportAvgAggregateInputType = {
    rowsImported?: true
  }

  export type InventoryImportSumAggregateInputType = {
    rowsImported?: true
  }

  export type InventoryImportMinAggregateInputType = {
    id?: true
    barId?: true
    fileName?: true
    rowsImported?: true
    createdById?: true
    createdAt?: true
  }

  export type InventoryImportMaxAggregateInputType = {
    id?: true
    barId?: true
    fileName?: true
    rowsImported?: true
    createdById?: true
    createdAt?: true
  }

  export type InventoryImportCountAggregateInputType = {
    id?: true
    barId?: true
    fileName?: true
    rowsImported?: true
    mapping?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryImport to aggregate.
     */
    where?: InventoryImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryImports to fetch.
     */
    orderBy?: InventoryImportOrderByWithRelationInput | InventoryImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryImports
    **/
    _count?: true | InventoryImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryImportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryImportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryImportMaxAggregateInputType
  }

  export type GetInventoryImportAggregateType<T extends InventoryImportAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryImport[P]>
      : GetScalarType<T[P], AggregateInventoryImport[P]>
  }




  export type InventoryImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryImportWhereInput
    orderBy?: InventoryImportOrderByWithAggregationInput | InventoryImportOrderByWithAggregationInput[]
    by: InventoryImportScalarFieldEnum[] | InventoryImportScalarFieldEnum
    having?: InventoryImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryImportCountAggregateInputType | true
    _avg?: InventoryImportAvgAggregateInputType
    _sum?: InventoryImportSumAggregateInputType
    _min?: InventoryImportMinAggregateInputType
    _max?: InventoryImportMaxAggregateInputType
  }

  export type InventoryImportGroupByOutputType = {
    id: string
    barId: string
    fileName: string
    rowsImported: number
    mapping: JsonValue | null
    createdById: string | null
    createdAt: Date
    _count: InventoryImportCountAggregateOutputType | null
    _avg: InventoryImportAvgAggregateOutputType | null
    _sum: InventoryImportSumAggregateOutputType | null
    _min: InventoryImportMinAggregateOutputType | null
    _max: InventoryImportMaxAggregateOutputType | null
  }

  type GetInventoryImportGroupByPayload<T extends InventoryImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryImportGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryImportGroupByOutputType[P]>
        }
      >
    >


  export type InventoryImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    fileName?: boolean
    rowsImported?: boolean
    mapping?: boolean
    createdById?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    createdBy?: boolean | InventoryImport$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryImport"]>

  export type InventoryImportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    fileName?: boolean
    rowsImported?: boolean
    mapping?: boolean
    createdById?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    createdBy?: boolean | InventoryImport$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryImport"]>

  export type InventoryImportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    fileName?: boolean
    rowsImported?: boolean
    mapping?: boolean
    createdById?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    createdBy?: boolean | InventoryImport$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryImport"]>

  export type InventoryImportSelectScalar = {
    id?: boolean
    barId?: boolean
    fileName?: boolean
    rowsImported?: boolean
    mapping?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type InventoryImportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "fileName" | "rowsImported" | "mapping" | "createdById" | "createdAt", ExtArgs["result"]["inventoryImport"]>
  export type InventoryImportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    createdBy?: boolean | InventoryImport$createdByArgs<ExtArgs>
  }
  export type InventoryImportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    createdBy?: boolean | InventoryImport$createdByArgs<ExtArgs>
  }
  export type InventoryImportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    createdBy?: boolean | InventoryImport$createdByArgs<ExtArgs>
  }

  export type $InventoryImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryImport"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      fileName: string
      rowsImported: number
      mapping: Prisma.JsonValue | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryImport"]>
    composites: {}
  }

  type InventoryImportGetPayload<S extends boolean | null | undefined | InventoryImportDefaultArgs> = $Result.GetResult<Prisma.$InventoryImportPayload, S>

  type InventoryImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryImportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryImportCountAggregateInputType | true
    }

  export interface InventoryImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryImport'], meta: { name: 'InventoryImport' } }
    /**
     * Find zero or one InventoryImport that matches the filter.
     * @param {InventoryImportFindUniqueArgs} args - Arguments to find a InventoryImport
     * @example
     * // Get one InventoryImport
     * const inventoryImport = await prisma.inventoryImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryImportFindUniqueArgs>(args: SelectSubset<T, InventoryImportFindUniqueArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryImport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryImportFindUniqueOrThrowArgs} args - Arguments to find a InventoryImport
     * @example
     * // Get one InventoryImport
     * const inventoryImport = await prisma.inventoryImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryImportFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportFindFirstArgs} args - Arguments to find a InventoryImport
     * @example
     * // Get one InventoryImport
     * const inventoryImport = await prisma.inventoryImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryImportFindFirstArgs>(args?: SelectSubset<T, InventoryImportFindFirstArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportFindFirstOrThrowArgs} args - Arguments to find a InventoryImport
     * @example
     * // Get one InventoryImport
     * const inventoryImport = await prisma.inventoryImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryImportFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryImports
     * const inventoryImports = await prisma.inventoryImport.findMany()
     * 
     * // Get first 10 InventoryImports
     * const inventoryImports = await prisma.inventoryImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryImportWithIdOnly = await prisma.inventoryImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryImportFindManyArgs>(args?: SelectSubset<T, InventoryImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryImport.
     * @param {InventoryImportCreateArgs} args - Arguments to create a InventoryImport.
     * @example
     * // Create one InventoryImport
     * const InventoryImport = await prisma.inventoryImport.create({
     *   data: {
     *     // ... data to create a InventoryImport
     *   }
     * })
     * 
     */
    create<T extends InventoryImportCreateArgs>(args: SelectSubset<T, InventoryImportCreateArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryImports.
     * @param {InventoryImportCreateManyArgs} args - Arguments to create many InventoryImports.
     * @example
     * // Create many InventoryImports
     * const inventoryImport = await prisma.inventoryImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryImportCreateManyArgs>(args?: SelectSubset<T, InventoryImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryImports and returns the data saved in the database.
     * @param {InventoryImportCreateManyAndReturnArgs} args - Arguments to create many InventoryImports.
     * @example
     * // Create many InventoryImports
     * const inventoryImport = await prisma.inventoryImport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryImports and only return the `id`
     * const inventoryImportWithIdOnly = await prisma.inventoryImport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryImportCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryImportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryImport.
     * @param {InventoryImportDeleteArgs} args - Arguments to delete one InventoryImport.
     * @example
     * // Delete one InventoryImport
     * const InventoryImport = await prisma.inventoryImport.delete({
     *   where: {
     *     // ... filter to delete one InventoryImport
     *   }
     * })
     * 
     */
    delete<T extends InventoryImportDeleteArgs>(args: SelectSubset<T, InventoryImportDeleteArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryImport.
     * @param {InventoryImportUpdateArgs} args - Arguments to update one InventoryImport.
     * @example
     * // Update one InventoryImport
     * const inventoryImport = await prisma.inventoryImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryImportUpdateArgs>(args: SelectSubset<T, InventoryImportUpdateArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryImports.
     * @param {InventoryImportDeleteManyArgs} args - Arguments to filter InventoryImports to delete.
     * @example
     * // Delete a few InventoryImports
     * const { count } = await prisma.inventoryImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryImportDeleteManyArgs>(args?: SelectSubset<T, InventoryImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryImports
     * const inventoryImport = await prisma.inventoryImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryImportUpdateManyArgs>(args: SelectSubset<T, InventoryImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryImports and returns the data updated in the database.
     * @param {InventoryImportUpdateManyAndReturnArgs} args - Arguments to update many InventoryImports.
     * @example
     * // Update many InventoryImports
     * const inventoryImport = await prisma.inventoryImport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryImports and only return the `id`
     * const inventoryImportWithIdOnly = await prisma.inventoryImport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryImportUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryImportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryImport.
     * @param {InventoryImportUpsertArgs} args - Arguments to update or create a InventoryImport.
     * @example
     * // Update or create a InventoryImport
     * const inventoryImport = await prisma.inventoryImport.upsert({
     *   create: {
     *     // ... data to create a InventoryImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryImport we want to update
     *   }
     * })
     */
    upsert<T extends InventoryImportUpsertArgs>(args: SelectSubset<T, InventoryImportUpsertArgs<ExtArgs>>): Prisma__InventoryImportClient<$Result.GetResult<Prisma.$InventoryImportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportCountArgs} args - Arguments to filter InventoryImports to count.
     * @example
     * // Count the number of InventoryImports
     * const count = await prisma.inventoryImport.count({
     *   where: {
     *     // ... the filter for the InventoryImports we want to count
     *   }
     * })
    **/
    count<T extends InventoryImportCountArgs>(
      args?: Subset<T, InventoryImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryImportAggregateArgs>(args: Subset<T, InventoryImportAggregateArgs>): Prisma.PrismaPromise<GetInventoryImportAggregateType<T>>

    /**
     * Group by InventoryImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryImportGroupByArgs['orderBy'] }
        : { orderBy?: InventoryImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryImport model
   */
  readonly fields: InventoryImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends InventoryImport$createdByArgs<ExtArgs> = {}>(args?: Subset<T, InventoryImport$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryImport model
   */
  interface InventoryImportFieldRefs {
    readonly id: FieldRef<"InventoryImport", 'String'>
    readonly barId: FieldRef<"InventoryImport", 'String'>
    readonly fileName: FieldRef<"InventoryImport", 'String'>
    readonly rowsImported: FieldRef<"InventoryImport", 'Int'>
    readonly mapping: FieldRef<"InventoryImport", 'Json'>
    readonly createdById: FieldRef<"InventoryImport", 'String'>
    readonly createdAt: FieldRef<"InventoryImport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryImport findUnique
   */
  export type InventoryImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * Filter, which InventoryImport to fetch.
     */
    where: InventoryImportWhereUniqueInput
  }

  /**
   * InventoryImport findUniqueOrThrow
   */
  export type InventoryImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * Filter, which InventoryImport to fetch.
     */
    where: InventoryImportWhereUniqueInput
  }

  /**
   * InventoryImport findFirst
   */
  export type InventoryImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * Filter, which InventoryImport to fetch.
     */
    where?: InventoryImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryImports to fetch.
     */
    orderBy?: InventoryImportOrderByWithRelationInput | InventoryImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryImports.
     */
    cursor?: InventoryImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryImports.
     */
    distinct?: InventoryImportScalarFieldEnum | InventoryImportScalarFieldEnum[]
  }

  /**
   * InventoryImport findFirstOrThrow
   */
  export type InventoryImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * Filter, which InventoryImport to fetch.
     */
    where?: InventoryImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryImports to fetch.
     */
    orderBy?: InventoryImportOrderByWithRelationInput | InventoryImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryImports.
     */
    cursor?: InventoryImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryImports.
     */
    distinct?: InventoryImportScalarFieldEnum | InventoryImportScalarFieldEnum[]
  }

  /**
   * InventoryImport findMany
   */
  export type InventoryImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * Filter, which InventoryImports to fetch.
     */
    where?: InventoryImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryImports to fetch.
     */
    orderBy?: InventoryImportOrderByWithRelationInput | InventoryImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryImports.
     */
    cursor?: InventoryImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryImports.
     */
    skip?: number
    distinct?: InventoryImportScalarFieldEnum | InventoryImportScalarFieldEnum[]
  }

  /**
   * InventoryImport create
   */
  export type InventoryImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryImport.
     */
    data: XOR<InventoryImportCreateInput, InventoryImportUncheckedCreateInput>
  }

  /**
   * InventoryImport createMany
   */
  export type InventoryImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryImports.
     */
    data: InventoryImportCreateManyInput | InventoryImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryImport createManyAndReturn
   */
  export type InventoryImportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryImports.
     */
    data: InventoryImportCreateManyInput | InventoryImportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryImport update
   */
  export type InventoryImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryImport.
     */
    data: XOR<InventoryImportUpdateInput, InventoryImportUncheckedUpdateInput>
    /**
     * Choose, which InventoryImport to update.
     */
    where: InventoryImportWhereUniqueInput
  }

  /**
   * InventoryImport updateMany
   */
  export type InventoryImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryImports.
     */
    data: XOR<InventoryImportUpdateManyMutationInput, InventoryImportUncheckedUpdateManyInput>
    /**
     * Filter which InventoryImports to update
     */
    where?: InventoryImportWhereInput
    /**
     * Limit how many InventoryImports to update.
     */
    limit?: number
  }

  /**
   * InventoryImport updateManyAndReturn
   */
  export type InventoryImportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * The data used to update InventoryImports.
     */
    data: XOR<InventoryImportUpdateManyMutationInput, InventoryImportUncheckedUpdateManyInput>
    /**
     * Filter which InventoryImports to update
     */
    where?: InventoryImportWhereInput
    /**
     * Limit how many InventoryImports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryImport upsert
   */
  export type InventoryImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryImport to update in case it exists.
     */
    where: InventoryImportWhereUniqueInput
    /**
     * In case the InventoryImport found by the `where` argument doesn't exist, create a new InventoryImport with this data.
     */
    create: XOR<InventoryImportCreateInput, InventoryImportUncheckedCreateInput>
    /**
     * In case the InventoryImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryImportUpdateInput, InventoryImportUncheckedUpdateInput>
  }

  /**
   * InventoryImport delete
   */
  export type InventoryImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
    /**
     * Filter which InventoryImport to delete.
     */
    where: InventoryImportWhereUniqueInput
  }

  /**
   * InventoryImport deleteMany
   */
  export type InventoryImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryImports to delete
     */
    where?: InventoryImportWhereInput
    /**
     * Limit how many InventoryImports to delete.
     */
    limit?: number
  }

  /**
   * InventoryImport.createdBy
   */
  export type InventoryImport$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InventoryImport without action
   */
  export type InventoryImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryImport
     */
    select?: InventoryImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryImport
     */
    omit?: InventoryImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryImportInclude<ExtArgs> | null
  }


  /**
   * Model ShiftUsage
   */

  export type AggregateShiftUsage = {
    _count: ShiftUsageCountAggregateOutputType | null
    _min: ShiftUsageMinAggregateOutputType | null
    _max: ShiftUsageMaxAggregateOutputType | null
  }

  export type ShiftUsageMinAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    shiftTime: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type ShiftUsageMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    shiftTime: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type ShiftUsageCountAggregateOutputType = {
    id: number
    barId: number
    userId: number
    shiftTime: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ShiftUsageMinAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    shiftTime?: true
    notes?: true
    createdAt?: true
  }

  export type ShiftUsageMaxAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    shiftTime?: true
    notes?: true
    createdAt?: true
  }

  export type ShiftUsageCountAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    shiftTime?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ShiftUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftUsage to aggregate.
     */
    where?: ShiftUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsages to fetch.
     */
    orderBy?: ShiftUsageOrderByWithRelationInput | ShiftUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftUsages
    **/
    _count?: true | ShiftUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftUsageMaxAggregateInputType
  }

  export type GetShiftUsageAggregateType<T extends ShiftUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftUsage[P]>
      : GetScalarType<T[P], AggregateShiftUsage[P]>
  }




  export type ShiftUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftUsageWhereInput
    orderBy?: ShiftUsageOrderByWithAggregationInput | ShiftUsageOrderByWithAggregationInput[]
    by: ShiftUsageScalarFieldEnum[] | ShiftUsageScalarFieldEnum
    having?: ShiftUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftUsageCountAggregateInputType | true
    _min?: ShiftUsageMinAggregateInputType
    _max?: ShiftUsageMaxAggregateInputType
  }

  export type ShiftUsageGroupByOutputType = {
    id: string
    barId: string
    userId: string | null
    shiftTime: Date
    notes: string | null
    createdAt: Date
    _count: ShiftUsageCountAggregateOutputType | null
    _min: ShiftUsageMinAggregateOutputType | null
    _max: ShiftUsageMaxAggregateOutputType | null
  }

  type GetShiftUsageGroupByPayload<T extends ShiftUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftUsageGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftUsageGroupByOutputType[P]>
        }
      >
    >


  export type ShiftUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    shiftTime?: boolean
    notes?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | ShiftUsage$userArgs<ExtArgs>
    items?: boolean | ShiftUsage$itemsArgs<ExtArgs>
    _count?: boolean | ShiftUsageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftUsage"]>

  export type ShiftUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    shiftTime?: boolean
    notes?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | ShiftUsage$userArgs<ExtArgs>
  }, ExtArgs["result"]["shiftUsage"]>

  export type ShiftUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    shiftTime?: boolean
    notes?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | ShiftUsage$userArgs<ExtArgs>
  }, ExtArgs["result"]["shiftUsage"]>

  export type ShiftUsageSelectScalar = {
    id?: boolean
    barId?: boolean
    userId?: boolean
    shiftTime?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ShiftUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "userId" | "shiftTime" | "notes" | "createdAt", ExtArgs["result"]["shiftUsage"]>
  export type ShiftUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | ShiftUsage$userArgs<ExtArgs>
    items?: boolean | ShiftUsage$itemsArgs<ExtArgs>
    _count?: boolean | ShiftUsageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | ShiftUsage$userArgs<ExtArgs>
  }
  export type ShiftUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | ShiftUsage$userArgs<ExtArgs>
  }

  export type $ShiftUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftUsage"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$ShiftUsageItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      userId: string | null
      shiftTime: Date
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["shiftUsage"]>
    composites: {}
  }

  type ShiftUsageGetPayload<S extends boolean | null | undefined | ShiftUsageDefaultArgs> = $Result.GetResult<Prisma.$ShiftUsagePayload, S>

  type ShiftUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftUsageCountAggregateInputType | true
    }

  export interface ShiftUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftUsage'], meta: { name: 'ShiftUsage' } }
    /**
     * Find zero or one ShiftUsage that matches the filter.
     * @param {ShiftUsageFindUniqueArgs} args - Arguments to find a ShiftUsage
     * @example
     * // Get one ShiftUsage
     * const shiftUsage = await prisma.shiftUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftUsageFindUniqueArgs>(args: SelectSubset<T, ShiftUsageFindUniqueArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftUsageFindUniqueOrThrowArgs} args - Arguments to find a ShiftUsage
     * @example
     * // Get one ShiftUsage
     * const shiftUsage = await prisma.shiftUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageFindFirstArgs} args - Arguments to find a ShiftUsage
     * @example
     * // Get one ShiftUsage
     * const shiftUsage = await prisma.shiftUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftUsageFindFirstArgs>(args?: SelectSubset<T, ShiftUsageFindFirstArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageFindFirstOrThrowArgs} args - Arguments to find a ShiftUsage
     * @example
     * // Get one ShiftUsage
     * const shiftUsage = await prisma.shiftUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftUsages
     * const shiftUsages = await prisma.shiftUsage.findMany()
     * 
     * // Get first 10 ShiftUsages
     * const shiftUsages = await prisma.shiftUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftUsageWithIdOnly = await prisma.shiftUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftUsageFindManyArgs>(args?: SelectSubset<T, ShiftUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftUsage.
     * @param {ShiftUsageCreateArgs} args - Arguments to create a ShiftUsage.
     * @example
     * // Create one ShiftUsage
     * const ShiftUsage = await prisma.shiftUsage.create({
     *   data: {
     *     // ... data to create a ShiftUsage
     *   }
     * })
     * 
     */
    create<T extends ShiftUsageCreateArgs>(args: SelectSubset<T, ShiftUsageCreateArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftUsages.
     * @param {ShiftUsageCreateManyArgs} args - Arguments to create many ShiftUsages.
     * @example
     * // Create many ShiftUsages
     * const shiftUsage = await prisma.shiftUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftUsageCreateManyArgs>(args?: SelectSubset<T, ShiftUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftUsages and returns the data saved in the database.
     * @param {ShiftUsageCreateManyAndReturnArgs} args - Arguments to create many ShiftUsages.
     * @example
     * // Create many ShiftUsages
     * const shiftUsage = await prisma.shiftUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftUsages and only return the `id`
     * const shiftUsageWithIdOnly = await prisma.shiftUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShiftUsage.
     * @param {ShiftUsageDeleteArgs} args - Arguments to delete one ShiftUsage.
     * @example
     * // Delete one ShiftUsage
     * const ShiftUsage = await prisma.shiftUsage.delete({
     *   where: {
     *     // ... filter to delete one ShiftUsage
     *   }
     * })
     * 
     */
    delete<T extends ShiftUsageDeleteArgs>(args: SelectSubset<T, ShiftUsageDeleteArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftUsage.
     * @param {ShiftUsageUpdateArgs} args - Arguments to update one ShiftUsage.
     * @example
     * // Update one ShiftUsage
     * const shiftUsage = await prisma.shiftUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUsageUpdateArgs>(args: SelectSubset<T, ShiftUsageUpdateArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftUsages.
     * @param {ShiftUsageDeleteManyArgs} args - Arguments to filter ShiftUsages to delete.
     * @example
     * // Delete a few ShiftUsages
     * const { count } = await prisma.shiftUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftUsageDeleteManyArgs>(args?: SelectSubset<T, ShiftUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftUsages
     * const shiftUsage = await prisma.shiftUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUsageUpdateManyArgs>(args: SelectSubset<T, ShiftUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftUsages and returns the data updated in the database.
     * @param {ShiftUsageUpdateManyAndReturnArgs} args - Arguments to update many ShiftUsages.
     * @example
     * // Update many ShiftUsages
     * const shiftUsage = await prisma.shiftUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShiftUsages and only return the `id`
     * const shiftUsageWithIdOnly = await prisma.shiftUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShiftUsage.
     * @param {ShiftUsageUpsertArgs} args - Arguments to update or create a ShiftUsage.
     * @example
     * // Update or create a ShiftUsage
     * const shiftUsage = await prisma.shiftUsage.upsert({
     *   create: {
     *     // ... data to create a ShiftUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftUsage we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUsageUpsertArgs>(args: SelectSubset<T, ShiftUsageUpsertArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShiftUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageCountArgs} args - Arguments to filter ShiftUsages to count.
     * @example
     * // Count the number of ShiftUsages
     * const count = await prisma.shiftUsage.count({
     *   where: {
     *     // ... the filter for the ShiftUsages we want to count
     *   }
     * })
    **/
    count<T extends ShiftUsageCountArgs>(
      args?: Subset<T, ShiftUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftUsageAggregateArgs>(args: Subset<T, ShiftUsageAggregateArgs>): Prisma.PrismaPromise<GetShiftUsageAggregateType<T>>

    /**
     * Group by ShiftUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftUsageGroupByArgs['orderBy'] }
        : { orderBy?: ShiftUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftUsage model
   */
  readonly fields: ShiftUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ShiftUsage$userArgs<ExtArgs> = {}>(args?: Subset<T, ShiftUsage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends ShiftUsage$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ShiftUsage$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftUsage model
   */
  interface ShiftUsageFieldRefs {
    readonly id: FieldRef<"ShiftUsage", 'String'>
    readonly barId: FieldRef<"ShiftUsage", 'String'>
    readonly userId: FieldRef<"ShiftUsage", 'String'>
    readonly shiftTime: FieldRef<"ShiftUsage", 'DateTime'>
    readonly notes: FieldRef<"ShiftUsage", 'String'>
    readonly createdAt: FieldRef<"ShiftUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftUsage findUnique
   */
  export type ShiftUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsage to fetch.
     */
    where: ShiftUsageWhereUniqueInput
  }

  /**
   * ShiftUsage findUniqueOrThrow
   */
  export type ShiftUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsage to fetch.
     */
    where: ShiftUsageWhereUniqueInput
  }

  /**
   * ShiftUsage findFirst
   */
  export type ShiftUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsage to fetch.
     */
    where?: ShiftUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsages to fetch.
     */
    orderBy?: ShiftUsageOrderByWithRelationInput | ShiftUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftUsages.
     */
    cursor?: ShiftUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftUsages.
     */
    distinct?: ShiftUsageScalarFieldEnum | ShiftUsageScalarFieldEnum[]
  }

  /**
   * ShiftUsage findFirstOrThrow
   */
  export type ShiftUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsage to fetch.
     */
    where?: ShiftUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsages to fetch.
     */
    orderBy?: ShiftUsageOrderByWithRelationInput | ShiftUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftUsages.
     */
    cursor?: ShiftUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftUsages.
     */
    distinct?: ShiftUsageScalarFieldEnum | ShiftUsageScalarFieldEnum[]
  }

  /**
   * ShiftUsage findMany
   */
  export type ShiftUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsages to fetch.
     */
    where?: ShiftUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsages to fetch.
     */
    orderBy?: ShiftUsageOrderByWithRelationInput | ShiftUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftUsages.
     */
    cursor?: ShiftUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsages.
     */
    skip?: number
    distinct?: ShiftUsageScalarFieldEnum | ShiftUsageScalarFieldEnum[]
  }

  /**
   * ShiftUsage create
   */
  export type ShiftUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftUsage.
     */
    data: XOR<ShiftUsageCreateInput, ShiftUsageUncheckedCreateInput>
  }

  /**
   * ShiftUsage createMany
   */
  export type ShiftUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftUsages.
     */
    data: ShiftUsageCreateManyInput | ShiftUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftUsage createManyAndReturn
   */
  export type ShiftUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * The data used to create many ShiftUsages.
     */
    data: ShiftUsageCreateManyInput | ShiftUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftUsage update
   */
  export type ShiftUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftUsage.
     */
    data: XOR<ShiftUsageUpdateInput, ShiftUsageUncheckedUpdateInput>
    /**
     * Choose, which ShiftUsage to update.
     */
    where: ShiftUsageWhereUniqueInput
  }

  /**
   * ShiftUsage updateMany
   */
  export type ShiftUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftUsages.
     */
    data: XOR<ShiftUsageUpdateManyMutationInput, ShiftUsageUncheckedUpdateManyInput>
    /**
     * Filter which ShiftUsages to update
     */
    where?: ShiftUsageWhereInput
    /**
     * Limit how many ShiftUsages to update.
     */
    limit?: number
  }

  /**
   * ShiftUsage updateManyAndReturn
   */
  export type ShiftUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * The data used to update ShiftUsages.
     */
    data: XOR<ShiftUsageUpdateManyMutationInput, ShiftUsageUncheckedUpdateManyInput>
    /**
     * Filter which ShiftUsages to update
     */
    where?: ShiftUsageWhereInput
    /**
     * Limit how many ShiftUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftUsage upsert
   */
  export type ShiftUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftUsage to update in case it exists.
     */
    where: ShiftUsageWhereUniqueInput
    /**
     * In case the ShiftUsage found by the `where` argument doesn't exist, create a new ShiftUsage with this data.
     */
    create: XOR<ShiftUsageCreateInput, ShiftUsageUncheckedCreateInput>
    /**
     * In case the ShiftUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUsageUpdateInput, ShiftUsageUncheckedUpdateInput>
  }

  /**
   * ShiftUsage delete
   */
  export type ShiftUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
    /**
     * Filter which ShiftUsage to delete.
     */
    where: ShiftUsageWhereUniqueInput
  }

  /**
   * ShiftUsage deleteMany
   */
  export type ShiftUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftUsages to delete
     */
    where?: ShiftUsageWhereInput
    /**
     * Limit how many ShiftUsages to delete.
     */
    limit?: number
  }

  /**
   * ShiftUsage.user
   */
  export type ShiftUsage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ShiftUsage.items
   */
  export type ShiftUsage$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    where?: ShiftUsageItemWhereInput
    orderBy?: ShiftUsageItemOrderByWithRelationInput | ShiftUsageItemOrderByWithRelationInput[]
    cursor?: ShiftUsageItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftUsageItemScalarFieldEnum | ShiftUsageItemScalarFieldEnum[]
  }

  /**
   * ShiftUsage without action
   */
  export type ShiftUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsage
     */
    select?: ShiftUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsage
     */
    omit?: ShiftUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageInclude<ExtArgs> | null
  }


  /**
   * Model ShiftUsageItem
   */

  export type AggregateShiftUsageItem = {
    _count: ShiftUsageItemCountAggregateOutputType | null
    _avg: ShiftUsageItemAvgAggregateOutputType | null
    _sum: ShiftUsageItemSumAggregateOutputType | null
    _min: ShiftUsageItemMinAggregateOutputType | null
    _max: ShiftUsageItemMaxAggregateOutputType | null
  }

  export type ShiftUsageItemAvgAggregateOutputType = {
    quantityUsed: Decimal | null
  }

  export type ShiftUsageItemSumAggregateOutputType = {
    quantityUsed: Decimal | null
  }

  export type ShiftUsageItemMinAggregateOutputType = {
    id: string | null
    shiftUsageId: string | null
    inventoryItemId: string | null
    quantityUsed: Decimal | null
    notes: string | null
  }

  export type ShiftUsageItemMaxAggregateOutputType = {
    id: string | null
    shiftUsageId: string | null
    inventoryItemId: string | null
    quantityUsed: Decimal | null
    notes: string | null
  }

  export type ShiftUsageItemCountAggregateOutputType = {
    id: number
    shiftUsageId: number
    inventoryItemId: number
    quantityUsed: number
    notes: number
    _all: number
  }


  export type ShiftUsageItemAvgAggregateInputType = {
    quantityUsed?: true
  }

  export type ShiftUsageItemSumAggregateInputType = {
    quantityUsed?: true
  }

  export type ShiftUsageItemMinAggregateInputType = {
    id?: true
    shiftUsageId?: true
    inventoryItemId?: true
    quantityUsed?: true
    notes?: true
  }

  export type ShiftUsageItemMaxAggregateInputType = {
    id?: true
    shiftUsageId?: true
    inventoryItemId?: true
    quantityUsed?: true
    notes?: true
  }

  export type ShiftUsageItemCountAggregateInputType = {
    id?: true
    shiftUsageId?: true
    inventoryItemId?: true
    quantityUsed?: true
    notes?: true
    _all?: true
  }

  export type ShiftUsageItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftUsageItem to aggregate.
     */
    where?: ShiftUsageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsageItems to fetch.
     */
    orderBy?: ShiftUsageItemOrderByWithRelationInput | ShiftUsageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftUsageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsageItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftUsageItems
    **/
    _count?: true | ShiftUsageItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftUsageItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftUsageItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftUsageItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftUsageItemMaxAggregateInputType
  }

  export type GetShiftUsageItemAggregateType<T extends ShiftUsageItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftUsageItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftUsageItem[P]>
      : GetScalarType<T[P], AggregateShiftUsageItem[P]>
  }




  export type ShiftUsageItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftUsageItemWhereInput
    orderBy?: ShiftUsageItemOrderByWithAggregationInput | ShiftUsageItemOrderByWithAggregationInput[]
    by: ShiftUsageItemScalarFieldEnum[] | ShiftUsageItemScalarFieldEnum
    having?: ShiftUsageItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftUsageItemCountAggregateInputType | true
    _avg?: ShiftUsageItemAvgAggregateInputType
    _sum?: ShiftUsageItemSumAggregateInputType
    _min?: ShiftUsageItemMinAggregateInputType
    _max?: ShiftUsageItemMaxAggregateInputType
  }

  export type ShiftUsageItemGroupByOutputType = {
    id: string
    shiftUsageId: string
    inventoryItemId: string
    quantityUsed: Decimal
    notes: string | null
    _count: ShiftUsageItemCountAggregateOutputType | null
    _avg: ShiftUsageItemAvgAggregateOutputType | null
    _sum: ShiftUsageItemSumAggregateOutputType | null
    _min: ShiftUsageItemMinAggregateOutputType | null
    _max: ShiftUsageItemMaxAggregateOutputType | null
  }

  type GetShiftUsageItemGroupByPayload<T extends ShiftUsageItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftUsageItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftUsageItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftUsageItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftUsageItemGroupByOutputType[P]>
        }
      >
    >


  export type ShiftUsageItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftUsageId?: boolean
    inventoryItemId?: boolean
    quantityUsed?: boolean
    notes?: boolean
    shiftUsage?: boolean | ShiftUsageDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftUsageItem"]>

  export type ShiftUsageItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftUsageId?: boolean
    inventoryItemId?: boolean
    quantityUsed?: boolean
    notes?: boolean
    shiftUsage?: boolean | ShiftUsageDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftUsageItem"]>

  export type ShiftUsageItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftUsageId?: boolean
    inventoryItemId?: boolean
    quantityUsed?: boolean
    notes?: boolean
    shiftUsage?: boolean | ShiftUsageDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftUsageItem"]>

  export type ShiftUsageItemSelectScalar = {
    id?: boolean
    shiftUsageId?: boolean
    inventoryItemId?: boolean
    quantityUsed?: boolean
    notes?: boolean
  }

  export type ShiftUsageItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shiftUsageId" | "inventoryItemId" | "quantityUsed" | "notes", ExtArgs["result"]["shiftUsageItem"]>
  export type ShiftUsageItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftUsage?: boolean | ShiftUsageDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type ShiftUsageItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftUsage?: boolean | ShiftUsageDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type ShiftUsageItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftUsage?: boolean | ShiftUsageDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $ShiftUsageItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftUsageItem"
    objects: {
      shiftUsage: Prisma.$ShiftUsagePayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shiftUsageId: string
      inventoryItemId: string
      quantityUsed: Prisma.Decimal
      notes: string | null
    }, ExtArgs["result"]["shiftUsageItem"]>
    composites: {}
  }

  type ShiftUsageItemGetPayload<S extends boolean | null | undefined | ShiftUsageItemDefaultArgs> = $Result.GetResult<Prisma.$ShiftUsageItemPayload, S>

  type ShiftUsageItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftUsageItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftUsageItemCountAggregateInputType | true
    }

  export interface ShiftUsageItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftUsageItem'], meta: { name: 'ShiftUsageItem' } }
    /**
     * Find zero or one ShiftUsageItem that matches the filter.
     * @param {ShiftUsageItemFindUniqueArgs} args - Arguments to find a ShiftUsageItem
     * @example
     * // Get one ShiftUsageItem
     * const shiftUsageItem = await prisma.shiftUsageItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftUsageItemFindUniqueArgs>(args: SelectSubset<T, ShiftUsageItemFindUniqueArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftUsageItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftUsageItemFindUniqueOrThrowArgs} args - Arguments to find a ShiftUsageItem
     * @example
     * // Get one ShiftUsageItem
     * const shiftUsageItem = await prisma.shiftUsageItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftUsageItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftUsageItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftUsageItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemFindFirstArgs} args - Arguments to find a ShiftUsageItem
     * @example
     * // Get one ShiftUsageItem
     * const shiftUsageItem = await prisma.shiftUsageItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftUsageItemFindFirstArgs>(args?: SelectSubset<T, ShiftUsageItemFindFirstArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftUsageItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemFindFirstOrThrowArgs} args - Arguments to find a ShiftUsageItem
     * @example
     * // Get one ShiftUsageItem
     * const shiftUsageItem = await prisma.shiftUsageItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftUsageItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftUsageItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftUsageItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftUsageItems
     * const shiftUsageItems = await prisma.shiftUsageItem.findMany()
     * 
     * // Get first 10 ShiftUsageItems
     * const shiftUsageItems = await prisma.shiftUsageItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftUsageItemWithIdOnly = await prisma.shiftUsageItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftUsageItemFindManyArgs>(args?: SelectSubset<T, ShiftUsageItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftUsageItem.
     * @param {ShiftUsageItemCreateArgs} args - Arguments to create a ShiftUsageItem.
     * @example
     * // Create one ShiftUsageItem
     * const ShiftUsageItem = await prisma.shiftUsageItem.create({
     *   data: {
     *     // ... data to create a ShiftUsageItem
     *   }
     * })
     * 
     */
    create<T extends ShiftUsageItemCreateArgs>(args: SelectSubset<T, ShiftUsageItemCreateArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftUsageItems.
     * @param {ShiftUsageItemCreateManyArgs} args - Arguments to create many ShiftUsageItems.
     * @example
     * // Create many ShiftUsageItems
     * const shiftUsageItem = await prisma.shiftUsageItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftUsageItemCreateManyArgs>(args?: SelectSubset<T, ShiftUsageItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftUsageItems and returns the data saved in the database.
     * @param {ShiftUsageItemCreateManyAndReturnArgs} args - Arguments to create many ShiftUsageItems.
     * @example
     * // Create many ShiftUsageItems
     * const shiftUsageItem = await prisma.shiftUsageItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftUsageItems and only return the `id`
     * const shiftUsageItemWithIdOnly = await prisma.shiftUsageItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftUsageItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftUsageItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShiftUsageItem.
     * @param {ShiftUsageItemDeleteArgs} args - Arguments to delete one ShiftUsageItem.
     * @example
     * // Delete one ShiftUsageItem
     * const ShiftUsageItem = await prisma.shiftUsageItem.delete({
     *   where: {
     *     // ... filter to delete one ShiftUsageItem
     *   }
     * })
     * 
     */
    delete<T extends ShiftUsageItemDeleteArgs>(args: SelectSubset<T, ShiftUsageItemDeleteArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftUsageItem.
     * @param {ShiftUsageItemUpdateArgs} args - Arguments to update one ShiftUsageItem.
     * @example
     * // Update one ShiftUsageItem
     * const shiftUsageItem = await prisma.shiftUsageItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUsageItemUpdateArgs>(args: SelectSubset<T, ShiftUsageItemUpdateArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftUsageItems.
     * @param {ShiftUsageItemDeleteManyArgs} args - Arguments to filter ShiftUsageItems to delete.
     * @example
     * // Delete a few ShiftUsageItems
     * const { count } = await prisma.shiftUsageItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftUsageItemDeleteManyArgs>(args?: SelectSubset<T, ShiftUsageItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftUsageItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftUsageItems
     * const shiftUsageItem = await prisma.shiftUsageItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUsageItemUpdateManyArgs>(args: SelectSubset<T, ShiftUsageItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftUsageItems and returns the data updated in the database.
     * @param {ShiftUsageItemUpdateManyAndReturnArgs} args - Arguments to update many ShiftUsageItems.
     * @example
     * // Update many ShiftUsageItems
     * const shiftUsageItem = await prisma.shiftUsageItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShiftUsageItems and only return the `id`
     * const shiftUsageItemWithIdOnly = await prisma.shiftUsageItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUsageItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUsageItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShiftUsageItem.
     * @param {ShiftUsageItemUpsertArgs} args - Arguments to update or create a ShiftUsageItem.
     * @example
     * // Update or create a ShiftUsageItem
     * const shiftUsageItem = await prisma.shiftUsageItem.upsert({
     *   create: {
     *     // ... data to create a ShiftUsageItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftUsageItem we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUsageItemUpsertArgs>(args: SelectSubset<T, ShiftUsageItemUpsertArgs<ExtArgs>>): Prisma__ShiftUsageItemClient<$Result.GetResult<Prisma.$ShiftUsageItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShiftUsageItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemCountArgs} args - Arguments to filter ShiftUsageItems to count.
     * @example
     * // Count the number of ShiftUsageItems
     * const count = await prisma.shiftUsageItem.count({
     *   where: {
     *     // ... the filter for the ShiftUsageItems we want to count
     *   }
     * })
    **/
    count<T extends ShiftUsageItemCountArgs>(
      args?: Subset<T, ShiftUsageItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftUsageItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftUsageItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftUsageItemAggregateArgs>(args: Subset<T, ShiftUsageItemAggregateArgs>): Prisma.PrismaPromise<GetShiftUsageItemAggregateType<T>>

    /**
     * Group by ShiftUsageItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUsageItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftUsageItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftUsageItemGroupByArgs['orderBy'] }
        : { orderBy?: ShiftUsageItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftUsageItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftUsageItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftUsageItem model
   */
  readonly fields: ShiftUsageItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftUsageItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftUsageItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shiftUsage<T extends ShiftUsageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftUsageDefaultArgs<ExtArgs>>): Prisma__ShiftUsageClient<$Result.GetResult<Prisma.$ShiftUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftUsageItem model
   */
  interface ShiftUsageItemFieldRefs {
    readonly id: FieldRef<"ShiftUsageItem", 'String'>
    readonly shiftUsageId: FieldRef<"ShiftUsageItem", 'String'>
    readonly inventoryItemId: FieldRef<"ShiftUsageItem", 'String'>
    readonly quantityUsed: FieldRef<"ShiftUsageItem", 'Decimal'>
    readonly notes: FieldRef<"ShiftUsageItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShiftUsageItem findUnique
   */
  export type ShiftUsageItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsageItem to fetch.
     */
    where: ShiftUsageItemWhereUniqueInput
  }

  /**
   * ShiftUsageItem findUniqueOrThrow
   */
  export type ShiftUsageItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsageItem to fetch.
     */
    where: ShiftUsageItemWhereUniqueInput
  }

  /**
   * ShiftUsageItem findFirst
   */
  export type ShiftUsageItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsageItem to fetch.
     */
    where?: ShiftUsageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsageItems to fetch.
     */
    orderBy?: ShiftUsageItemOrderByWithRelationInput | ShiftUsageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftUsageItems.
     */
    cursor?: ShiftUsageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsageItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftUsageItems.
     */
    distinct?: ShiftUsageItemScalarFieldEnum | ShiftUsageItemScalarFieldEnum[]
  }

  /**
   * ShiftUsageItem findFirstOrThrow
   */
  export type ShiftUsageItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsageItem to fetch.
     */
    where?: ShiftUsageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsageItems to fetch.
     */
    orderBy?: ShiftUsageItemOrderByWithRelationInput | ShiftUsageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftUsageItems.
     */
    cursor?: ShiftUsageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsageItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftUsageItems.
     */
    distinct?: ShiftUsageItemScalarFieldEnum | ShiftUsageItemScalarFieldEnum[]
  }

  /**
   * ShiftUsageItem findMany
   */
  export type ShiftUsageItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * Filter, which ShiftUsageItems to fetch.
     */
    where?: ShiftUsageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftUsageItems to fetch.
     */
    orderBy?: ShiftUsageItemOrderByWithRelationInput | ShiftUsageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftUsageItems.
     */
    cursor?: ShiftUsageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftUsageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftUsageItems.
     */
    skip?: number
    distinct?: ShiftUsageItemScalarFieldEnum | ShiftUsageItemScalarFieldEnum[]
  }

  /**
   * ShiftUsageItem create
   */
  export type ShiftUsageItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftUsageItem.
     */
    data: XOR<ShiftUsageItemCreateInput, ShiftUsageItemUncheckedCreateInput>
  }

  /**
   * ShiftUsageItem createMany
   */
  export type ShiftUsageItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftUsageItems.
     */
    data: ShiftUsageItemCreateManyInput | ShiftUsageItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftUsageItem createManyAndReturn
   */
  export type ShiftUsageItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * The data used to create many ShiftUsageItems.
     */
    data: ShiftUsageItemCreateManyInput | ShiftUsageItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftUsageItem update
   */
  export type ShiftUsageItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftUsageItem.
     */
    data: XOR<ShiftUsageItemUpdateInput, ShiftUsageItemUncheckedUpdateInput>
    /**
     * Choose, which ShiftUsageItem to update.
     */
    where: ShiftUsageItemWhereUniqueInput
  }

  /**
   * ShiftUsageItem updateMany
   */
  export type ShiftUsageItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftUsageItems.
     */
    data: XOR<ShiftUsageItemUpdateManyMutationInput, ShiftUsageItemUncheckedUpdateManyInput>
    /**
     * Filter which ShiftUsageItems to update
     */
    where?: ShiftUsageItemWhereInput
    /**
     * Limit how many ShiftUsageItems to update.
     */
    limit?: number
  }

  /**
   * ShiftUsageItem updateManyAndReturn
   */
  export type ShiftUsageItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * The data used to update ShiftUsageItems.
     */
    data: XOR<ShiftUsageItemUpdateManyMutationInput, ShiftUsageItemUncheckedUpdateManyInput>
    /**
     * Filter which ShiftUsageItems to update
     */
    where?: ShiftUsageItemWhereInput
    /**
     * Limit how many ShiftUsageItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftUsageItem upsert
   */
  export type ShiftUsageItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftUsageItem to update in case it exists.
     */
    where: ShiftUsageItemWhereUniqueInput
    /**
     * In case the ShiftUsageItem found by the `where` argument doesn't exist, create a new ShiftUsageItem with this data.
     */
    create: XOR<ShiftUsageItemCreateInput, ShiftUsageItemUncheckedCreateInput>
    /**
     * In case the ShiftUsageItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUsageItemUpdateInput, ShiftUsageItemUncheckedUpdateInput>
  }

  /**
   * ShiftUsageItem delete
   */
  export type ShiftUsageItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
    /**
     * Filter which ShiftUsageItem to delete.
     */
    where: ShiftUsageItemWhereUniqueInput
  }

  /**
   * ShiftUsageItem deleteMany
   */
  export type ShiftUsageItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftUsageItems to delete
     */
    where?: ShiftUsageItemWhereInput
    /**
     * Limit how many ShiftUsageItems to delete.
     */
    limit?: number
  }

  /**
   * ShiftUsageItem without action
   */
  export type ShiftUsageItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftUsageItem
     */
    select?: ShiftUsageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftUsageItem
     */
    omit?: ShiftUsageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftUsageItemInclude<ExtArgs> | null
  }


  /**
   * Model InventorySnapshot
   */

  export type AggregateInventorySnapshot = {
    _count: InventorySnapshotCountAggregateOutputType | null
    _min: InventorySnapshotMinAggregateOutputType | null
    _max: InventorySnapshotMaxAggregateOutputType | null
  }

  export type InventorySnapshotMinAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    snapshotDate: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventorySnapshotMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    snapshotDate: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventorySnapshotCountAggregateOutputType = {
    id: number
    barId: number
    userId: number
    snapshotDate: number
    notes: number
    createdAt: number
    _all: number
  }


  export type InventorySnapshotMinAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    snapshotDate?: true
    notes?: true
    createdAt?: true
  }

  export type InventorySnapshotMaxAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    snapshotDate?: true
    notes?: true
    createdAt?: true
  }

  export type InventorySnapshotCountAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    snapshotDate?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type InventorySnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySnapshot to aggregate.
     */
    where?: InventorySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshots to fetch.
     */
    orderBy?: InventorySnapshotOrderByWithRelationInput | InventorySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventorySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventorySnapshots
    **/
    _count?: true | InventorySnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventorySnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventorySnapshotMaxAggregateInputType
  }

  export type GetInventorySnapshotAggregateType<T extends InventorySnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateInventorySnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventorySnapshot[P]>
      : GetScalarType<T[P], AggregateInventorySnapshot[P]>
  }




  export type InventorySnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySnapshotWhereInput
    orderBy?: InventorySnapshotOrderByWithAggregationInput | InventorySnapshotOrderByWithAggregationInput[]
    by: InventorySnapshotScalarFieldEnum[] | InventorySnapshotScalarFieldEnum
    having?: InventorySnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventorySnapshotCountAggregateInputType | true
    _min?: InventorySnapshotMinAggregateInputType
    _max?: InventorySnapshotMaxAggregateInputType
  }

  export type InventorySnapshotGroupByOutputType = {
    id: string
    barId: string
    userId: string | null
    snapshotDate: Date
    notes: string | null
    createdAt: Date
    _count: InventorySnapshotCountAggregateOutputType | null
    _min: InventorySnapshotMinAggregateOutputType | null
    _max: InventorySnapshotMaxAggregateOutputType | null
  }

  type GetInventorySnapshotGroupByPayload<T extends InventorySnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventorySnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventorySnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventorySnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], InventorySnapshotGroupByOutputType[P]>
        }
      >
    >


  export type InventorySnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    snapshotDate?: boolean
    notes?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | InventorySnapshot$userArgs<ExtArgs>
    items?: boolean | InventorySnapshot$itemsArgs<ExtArgs>
    _count?: boolean | InventorySnapshotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySnapshot"]>

  export type InventorySnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    snapshotDate?: boolean
    notes?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | InventorySnapshot$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySnapshot"]>

  export type InventorySnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    snapshotDate?: boolean
    notes?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | InventorySnapshot$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySnapshot"]>

  export type InventorySnapshotSelectScalar = {
    id?: boolean
    barId?: boolean
    userId?: boolean
    snapshotDate?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type InventorySnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "userId" | "snapshotDate" | "notes" | "createdAt", ExtArgs["result"]["inventorySnapshot"]>
  export type InventorySnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | InventorySnapshot$userArgs<ExtArgs>
    items?: boolean | InventorySnapshot$itemsArgs<ExtArgs>
    _count?: boolean | InventorySnapshotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventorySnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | InventorySnapshot$userArgs<ExtArgs>
  }
  export type InventorySnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | InventorySnapshot$userArgs<ExtArgs>
  }

  export type $InventorySnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventorySnapshot"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$InventorySnapshotItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      userId: string | null
      snapshotDate: Date
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventorySnapshot"]>
    composites: {}
  }

  type InventorySnapshotGetPayload<S extends boolean | null | undefined | InventorySnapshotDefaultArgs> = $Result.GetResult<Prisma.$InventorySnapshotPayload, S>

  type InventorySnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventorySnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventorySnapshotCountAggregateInputType | true
    }

  export interface InventorySnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventorySnapshot'], meta: { name: 'InventorySnapshot' } }
    /**
     * Find zero or one InventorySnapshot that matches the filter.
     * @param {InventorySnapshotFindUniqueArgs} args - Arguments to find a InventorySnapshot
     * @example
     * // Get one InventorySnapshot
     * const inventorySnapshot = await prisma.inventorySnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventorySnapshotFindUniqueArgs>(args: SelectSubset<T, InventorySnapshotFindUniqueArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventorySnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventorySnapshotFindUniqueOrThrowArgs} args - Arguments to find a InventorySnapshot
     * @example
     * // Get one InventorySnapshot
     * const inventorySnapshot = await prisma.inventorySnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventorySnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, InventorySnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventorySnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotFindFirstArgs} args - Arguments to find a InventorySnapshot
     * @example
     * // Get one InventorySnapshot
     * const inventorySnapshot = await prisma.inventorySnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventorySnapshotFindFirstArgs>(args?: SelectSubset<T, InventorySnapshotFindFirstArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventorySnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotFindFirstOrThrowArgs} args - Arguments to find a InventorySnapshot
     * @example
     * // Get one InventorySnapshot
     * const inventorySnapshot = await prisma.inventorySnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventorySnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, InventorySnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventorySnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventorySnapshots
     * const inventorySnapshots = await prisma.inventorySnapshot.findMany()
     * 
     * // Get first 10 InventorySnapshots
     * const inventorySnapshots = await prisma.inventorySnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventorySnapshotWithIdOnly = await prisma.inventorySnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventorySnapshotFindManyArgs>(args?: SelectSubset<T, InventorySnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventorySnapshot.
     * @param {InventorySnapshotCreateArgs} args - Arguments to create a InventorySnapshot.
     * @example
     * // Create one InventorySnapshot
     * const InventorySnapshot = await prisma.inventorySnapshot.create({
     *   data: {
     *     // ... data to create a InventorySnapshot
     *   }
     * })
     * 
     */
    create<T extends InventorySnapshotCreateArgs>(args: SelectSubset<T, InventorySnapshotCreateArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventorySnapshots.
     * @param {InventorySnapshotCreateManyArgs} args - Arguments to create many InventorySnapshots.
     * @example
     * // Create many InventorySnapshots
     * const inventorySnapshot = await prisma.inventorySnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventorySnapshotCreateManyArgs>(args?: SelectSubset<T, InventorySnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventorySnapshots and returns the data saved in the database.
     * @param {InventorySnapshotCreateManyAndReturnArgs} args - Arguments to create many InventorySnapshots.
     * @example
     * // Create many InventorySnapshots
     * const inventorySnapshot = await prisma.inventorySnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventorySnapshots and only return the `id`
     * const inventorySnapshotWithIdOnly = await prisma.inventorySnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventorySnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, InventorySnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventorySnapshot.
     * @param {InventorySnapshotDeleteArgs} args - Arguments to delete one InventorySnapshot.
     * @example
     * // Delete one InventorySnapshot
     * const InventorySnapshot = await prisma.inventorySnapshot.delete({
     *   where: {
     *     // ... filter to delete one InventorySnapshot
     *   }
     * })
     * 
     */
    delete<T extends InventorySnapshotDeleteArgs>(args: SelectSubset<T, InventorySnapshotDeleteArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventorySnapshot.
     * @param {InventorySnapshotUpdateArgs} args - Arguments to update one InventorySnapshot.
     * @example
     * // Update one InventorySnapshot
     * const inventorySnapshot = await prisma.inventorySnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventorySnapshotUpdateArgs>(args: SelectSubset<T, InventorySnapshotUpdateArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventorySnapshots.
     * @param {InventorySnapshotDeleteManyArgs} args - Arguments to filter InventorySnapshots to delete.
     * @example
     * // Delete a few InventorySnapshots
     * const { count } = await prisma.inventorySnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventorySnapshotDeleteManyArgs>(args?: SelectSubset<T, InventorySnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventorySnapshots
     * const inventorySnapshot = await prisma.inventorySnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventorySnapshotUpdateManyArgs>(args: SelectSubset<T, InventorySnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySnapshots and returns the data updated in the database.
     * @param {InventorySnapshotUpdateManyAndReturnArgs} args - Arguments to update many InventorySnapshots.
     * @example
     * // Update many InventorySnapshots
     * const inventorySnapshot = await prisma.inventorySnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventorySnapshots and only return the `id`
     * const inventorySnapshotWithIdOnly = await prisma.inventorySnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventorySnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, InventorySnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventorySnapshot.
     * @param {InventorySnapshotUpsertArgs} args - Arguments to update or create a InventorySnapshot.
     * @example
     * // Update or create a InventorySnapshot
     * const inventorySnapshot = await prisma.inventorySnapshot.upsert({
     *   create: {
     *     // ... data to create a InventorySnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventorySnapshot we want to update
     *   }
     * })
     */
    upsert<T extends InventorySnapshotUpsertArgs>(args: SelectSubset<T, InventorySnapshotUpsertArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventorySnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotCountArgs} args - Arguments to filter InventorySnapshots to count.
     * @example
     * // Count the number of InventorySnapshots
     * const count = await prisma.inventorySnapshot.count({
     *   where: {
     *     // ... the filter for the InventorySnapshots we want to count
     *   }
     * })
    **/
    count<T extends InventorySnapshotCountArgs>(
      args?: Subset<T, InventorySnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventorySnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventorySnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventorySnapshotAggregateArgs>(args: Subset<T, InventorySnapshotAggregateArgs>): Prisma.PrismaPromise<GetInventorySnapshotAggregateType<T>>

    /**
     * Group by InventorySnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventorySnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventorySnapshotGroupByArgs['orderBy'] }
        : { orderBy?: InventorySnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventorySnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventorySnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventorySnapshot model
   */
  readonly fields: InventorySnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventorySnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventorySnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends InventorySnapshot$userArgs<ExtArgs> = {}>(args?: Subset<T, InventorySnapshot$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends InventorySnapshot$itemsArgs<ExtArgs> = {}>(args?: Subset<T, InventorySnapshot$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventorySnapshot model
   */
  interface InventorySnapshotFieldRefs {
    readonly id: FieldRef<"InventorySnapshot", 'String'>
    readonly barId: FieldRef<"InventorySnapshot", 'String'>
    readonly userId: FieldRef<"InventorySnapshot", 'String'>
    readonly snapshotDate: FieldRef<"InventorySnapshot", 'DateTime'>
    readonly notes: FieldRef<"InventorySnapshot", 'String'>
    readonly createdAt: FieldRef<"InventorySnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventorySnapshot findUnique
   */
  export type InventorySnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshot to fetch.
     */
    where: InventorySnapshotWhereUniqueInput
  }

  /**
   * InventorySnapshot findUniqueOrThrow
   */
  export type InventorySnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshot to fetch.
     */
    where: InventorySnapshotWhereUniqueInput
  }

  /**
   * InventorySnapshot findFirst
   */
  export type InventorySnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshot to fetch.
     */
    where?: InventorySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshots to fetch.
     */
    orderBy?: InventorySnapshotOrderByWithRelationInput | InventorySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySnapshots.
     */
    cursor?: InventorySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySnapshots.
     */
    distinct?: InventorySnapshotScalarFieldEnum | InventorySnapshotScalarFieldEnum[]
  }

  /**
   * InventorySnapshot findFirstOrThrow
   */
  export type InventorySnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshot to fetch.
     */
    where?: InventorySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshots to fetch.
     */
    orderBy?: InventorySnapshotOrderByWithRelationInput | InventorySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySnapshots.
     */
    cursor?: InventorySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySnapshots.
     */
    distinct?: InventorySnapshotScalarFieldEnum | InventorySnapshotScalarFieldEnum[]
  }

  /**
   * InventorySnapshot findMany
   */
  export type InventorySnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshots to fetch.
     */
    where?: InventorySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshots to fetch.
     */
    orderBy?: InventorySnapshotOrderByWithRelationInput | InventorySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventorySnapshots.
     */
    cursor?: InventorySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshots.
     */
    skip?: number
    distinct?: InventorySnapshotScalarFieldEnum | InventorySnapshotScalarFieldEnum[]
  }

  /**
   * InventorySnapshot create
   */
  export type InventorySnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a InventorySnapshot.
     */
    data: XOR<InventorySnapshotCreateInput, InventorySnapshotUncheckedCreateInput>
  }

  /**
   * InventorySnapshot createMany
   */
  export type InventorySnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventorySnapshots.
     */
    data: InventorySnapshotCreateManyInput | InventorySnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventorySnapshot createManyAndReturn
   */
  export type InventorySnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many InventorySnapshots.
     */
    data: InventorySnapshotCreateManyInput | InventorySnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventorySnapshot update
   */
  export type InventorySnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a InventorySnapshot.
     */
    data: XOR<InventorySnapshotUpdateInput, InventorySnapshotUncheckedUpdateInput>
    /**
     * Choose, which InventorySnapshot to update.
     */
    where: InventorySnapshotWhereUniqueInput
  }

  /**
   * InventorySnapshot updateMany
   */
  export type InventorySnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventorySnapshots.
     */
    data: XOR<InventorySnapshotUpdateManyMutationInput, InventorySnapshotUncheckedUpdateManyInput>
    /**
     * Filter which InventorySnapshots to update
     */
    where?: InventorySnapshotWhereInput
    /**
     * Limit how many InventorySnapshots to update.
     */
    limit?: number
  }

  /**
   * InventorySnapshot updateManyAndReturn
   */
  export type InventorySnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * The data used to update InventorySnapshots.
     */
    data: XOR<InventorySnapshotUpdateManyMutationInput, InventorySnapshotUncheckedUpdateManyInput>
    /**
     * Filter which InventorySnapshots to update
     */
    where?: InventorySnapshotWhereInput
    /**
     * Limit how many InventorySnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventorySnapshot upsert
   */
  export type InventorySnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the InventorySnapshot to update in case it exists.
     */
    where: InventorySnapshotWhereUniqueInput
    /**
     * In case the InventorySnapshot found by the `where` argument doesn't exist, create a new InventorySnapshot with this data.
     */
    create: XOR<InventorySnapshotCreateInput, InventorySnapshotUncheckedCreateInput>
    /**
     * In case the InventorySnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventorySnapshotUpdateInput, InventorySnapshotUncheckedUpdateInput>
  }

  /**
   * InventorySnapshot delete
   */
  export type InventorySnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
    /**
     * Filter which InventorySnapshot to delete.
     */
    where: InventorySnapshotWhereUniqueInput
  }

  /**
   * InventorySnapshot deleteMany
   */
  export type InventorySnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySnapshots to delete
     */
    where?: InventorySnapshotWhereInput
    /**
     * Limit how many InventorySnapshots to delete.
     */
    limit?: number
  }

  /**
   * InventorySnapshot.user
   */
  export type InventorySnapshot$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InventorySnapshot.items
   */
  export type InventorySnapshot$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    where?: InventorySnapshotItemWhereInput
    orderBy?: InventorySnapshotItemOrderByWithRelationInput | InventorySnapshotItemOrderByWithRelationInput[]
    cursor?: InventorySnapshotItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySnapshotItemScalarFieldEnum | InventorySnapshotItemScalarFieldEnum[]
  }

  /**
   * InventorySnapshot without action
   */
  export type InventorySnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshot
     */
    select?: InventorySnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshot
     */
    omit?: InventorySnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotInclude<ExtArgs> | null
  }


  /**
   * Model InventorySnapshotItem
   */

  export type AggregateInventorySnapshotItem = {
    _count: InventorySnapshotItemCountAggregateOutputType | null
    _avg: InventorySnapshotItemAvgAggregateOutputType | null
    _sum: InventorySnapshotItemSumAggregateOutputType | null
    _min: InventorySnapshotItemMinAggregateOutputType | null
    _max: InventorySnapshotItemMaxAggregateOutputType | null
  }

  export type InventorySnapshotItemAvgAggregateOutputType = {
    quantityOnHand: Decimal | null
  }

  export type InventorySnapshotItemSumAggregateOutputType = {
    quantityOnHand: Decimal | null
  }

  export type InventorySnapshotItemMinAggregateOutputType = {
    id: string | null
    snapshotId: string | null
    inventoryItemId: string | null
    quantityOnHand: Decimal | null
    notes: string | null
  }

  export type InventorySnapshotItemMaxAggregateOutputType = {
    id: string | null
    snapshotId: string | null
    inventoryItemId: string | null
    quantityOnHand: Decimal | null
    notes: string | null
  }

  export type InventorySnapshotItemCountAggregateOutputType = {
    id: number
    snapshotId: number
    inventoryItemId: number
    quantityOnHand: number
    notes: number
    _all: number
  }


  export type InventorySnapshotItemAvgAggregateInputType = {
    quantityOnHand?: true
  }

  export type InventorySnapshotItemSumAggregateInputType = {
    quantityOnHand?: true
  }

  export type InventorySnapshotItemMinAggregateInputType = {
    id?: true
    snapshotId?: true
    inventoryItemId?: true
    quantityOnHand?: true
    notes?: true
  }

  export type InventorySnapshotItemMaxAggregateInputType = {
    id?: true
    snapshotId?: true
    inventoryItemId?: true
    quantityOnHand?: true
    notes?: true
  }

  export type InventorySnapshotItemCountAggregateInputType = {
    id?: true
    snapshotId?: true
    inventoryItemId?: true
    quantityOnHand?: true
    notes?: true
    _all?: true
  }

  export type InventorySnapshotItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySnapshotItem to aggregate.
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshotItems to fetch.
     */
    orderBy?: InventorySnapshotItemOrderByWithRelationInput | InventorySnapshotItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventorySnapshotItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshotItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshotItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventorySnapshotItems
    **/
    _count?: true | InventorySnapshotItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventorySnapshotItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySnapshotItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventorySnapshotItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventorySnapshotItemMaxAggregateInputType
  }

  export type GetInventorySnapshotItemAggregateType<T extends InventorySnapshotItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventorySnapshotItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventorySnapshotItem[P]>
      : GetScalarType<T[P], AggregateInventorySnapshotItem[P]>
  }




  export type InventorySnapshotItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySnapshotItemWhereInput
    orderBy?: InventorySnapshotItemOrderByWithAggregationInput | InventorySnapshotItemOrderByWithAggregationInput[]
    by: InventorySnapshotItemScalarFieldEnum[] | InventorySnapshotItemScalarFieldEnum
    having?: InventorySnapshotItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventorySnapshotItemCountAggregateInputType | true
    _avg?: InventorySnapshotItemAvgAggregateInputType
    _sum?: InventorySnapshotItemSumAggregateInputType
    _min?: InventorySnapshotItemMinAggregateInputType
    _max?: InventorySnapshotItemMaxAggregateInputType
  }

  export type InventorySnapshotItemGroupByOutputType = {
    id: string
    snapshotId: string
    inventoryItemId: string
    quantityOnHand: Decimal
    notes: string | null
    _count: InventorySnapshotItemCountAggregateOutputType | null
    _avg: InventorySnapshotItemAvgAggregateOutputType | null
    _sum: InventorySnapshotItemSumAggregateOutputType | null
    _min: InventorySnapshotItemMinAggregateOutputType | null
    _max: InventorySnapshotItemMaxAggregateOutputType | null
  }

  type GetInventorySnapshotItemGroupByPayload<T extends InventorySnapshotItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventorySnapshotItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventorySnapshotItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventorySnapshotItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventorySnapshotItemGroupByOutputType[P]>
        }
      >
    >


  export type InventorySnapshotItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotId?: boolean
    inventoryItemId?: boolean
    quantityOnHand?: boolean
    notes?: boolean
    snapshot?: boolean | InventorySnapshotDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    bottlePhoto?: boolean | InventorySnapshotItem$bottlePhotoArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySnapshotItem"]>

  export type InventorySnapshotItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotId?: boolean
    inventoryItemId?: boolean
    quantityOnHand?: boolean
    notes?: boolean
    snapshot?: boolean | InventorySnapshotDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySnapshotItem"]>

  export type InventorySnapshotItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotId?: boolean
    inventoryItemId?: boolean
    quantityOnHand?: boolean
    notes?: boolean
    snapshot?: boolean | InventorySnapshotDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySnapshotItem"]>

  export type InventorySnapshotItemSelectScalar = {
    id?: boolean
    snapshotId?: boolean
    inventoryItemId?: boolean
    quantityOnHand?: boolean
    notes?: boolean
  }

  export type InventorySnapshotItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "snapshotId" | "inventoryItemId" | "quantityOnHand" | "notes", ExtArgs["result"]["inventorySnapshotItem"]>
  export type InventorySnapshotItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshot?: boolean | InventorySnapshotDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    bottlePhoto?: boolean | InventorySnapshotItem$bottlePhotoArgs<ExtArgs>
  }
  export type InventorySnapshotItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshot?: boolean | InventorySnapshotDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventorySnapshotItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshot?: boolean | InventorySnapshotDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $InventorySnapshotItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventorySnapshotItem"
    objects: {
      snapshot: Prisma.$InventorySnapshotPayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
      bottlePhoto: Prisma.$BottlePhotoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      snapshotId: string
      inventoryItemId: string
      quantityOnHand: Prisma.Decimal
      notes: string | null
    }, ExtArgs["result"]["inventorySnapshotItem"]>
    composites: {}
  }

  type InventorySnapshotItemGetPayload<S extends boolean | null | undefined | InventorySnapshotItemDefaultArgs> = $Result.GetResult<Prisma.$InventorySnapshotItemPayload, S>

  type InventorySnapshotItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventorySnapshotItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventorySnapshotItemCountAggregateInputType | true
    }

  export interface InventorySnapshotItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventorySnapshotItem'], meta: { name: 'InventorySnapshotItem' } }
    /**
     * Find zero or one InventorySnapshotItem that matches the filter.
     * @param {InventorySnapshotItemFindUniqueArgs} args - Arguments to find a InventorySnapshotItem
     * @example
     * // Get one InventorySnapshotItem
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventorySnapshotItemFindUniqueArgs>(args: SelectSubset<T, InventorySnapshotItemFindUniqueArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventorySnapshotItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventorySnapshotItemFindUniqueOrThrowArgs} args - Arguments to find a InventorySnapshotItem
     * @example
     * // Get one InventorySnapshotItem
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventorySnapshotItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventorySnapshotItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventorySnapshotItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemFindFirstArgs} args - Arguments to find a InventorySnapshotItem
     * @example
     * // Get one InventorySnapshotItem
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventorySnapshotItemFindFirstArgs>(args?: SelectSubset<T, InventorySnapshotItemFindFirstArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventorySnapshotItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemFindFirstOrThrowArgs} args - Arguments to find a InventorySnapshotItem
     * @example
     * // Get one InventorySnapshotItem
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventorySnapshotItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventorySnapshotItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventorySnapshotItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventorySnapshotItems
     * const inventorySnapshotItems = await prisma.inventorySnapshotItem.findMany()
     * 
     * // Get first 10 InventorySnapshotItems
     * const inventorySnapshotItems = await prisma.inventorySnapshotItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventorySnapshotItemWithIdOnly = await prisma.inventorySnapshotItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventorySnapshotItemFindManyArgs>(args?: SelectSubset<T, InventorySnapshotItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventorySnapshotItem.
     * @param {InventorySnapshotItemCreateArgs} args - Arguments to create a InventorySnapshotItem.
     * @example
     * // Create one InventorySnapshotItem
     * const InventorySnapshotItem = await prisma.inventorySnapshotItem.create({
     *   data: {
     *     // ... data to create a InventorySnapshotItem
     *   }
     * })
     * 
     */
    create<T extends InventorySnapshotItemCreateArgs>(args: SelectSubset<T, InventorySnapshotItemCreateArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventorySnapshotItems.
     * @param {InventorySnapshotItemCreateManyArgs} args - Arguments to create many InventorySnapshotItems.
     * @example
     * // Create many InventorySnapshotItems
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventorySnapshotItemCreateManyArgs>(args?: SelectSubset<T, InventorySnapshotItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventorySnapshotItems and returns the data saved in the database.
     * @param {InventorySnapshotItemCreateManyAndReturnArgs} args - Arguments to create many InventorySnapshotItems.
     * @example
     * // Create many InventorySnapshotItems
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventorySnapshotItems and only return the `id`
     * const inventorySnapshotItemWithIdOnly = await prisma.inventorySnapshotItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventorySnapshotItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventorySnapshotItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventorySnapshotItem.
     * @param {InventorySnapshotItemDeleteArgs} args - Arguments to delete one InventorySnapshotItem.
     * @example
     * // Delete one InventorySnapshotItem
     * const InventorySnapshotItem = await prisma.inventorySnapshotItem.delete({
     *   where: {
     *     // ... filter to delete one InventorySnapshotItem
     *   }
     * })
     * 
     */
    delete<T extends InventorySnapshotItemDeleteArgs>(args: SelectSubset<T, InventorySnapshotItemDeleteArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventorySnapshotItem.
     * @param {InventorySnapshotItemUpdateArgs} args - Arguments to update one InventorySnapshotItem.
     * @example
     * // Update one InventorySnapshotItem
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventorySnapshotItemUpdateArgs>(args: SelectSubset<T, InventorySnapshotItemUpdateArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventorySnapshotItems.
     * @param {InventorySnapshotItemDeleteManyArgs} args - Arguments to filter InventorySnapshotItems to delete.
     * @example
     * // Delete a few InventorySnapshotItems
     * const { count } = await prisma.inventorySnapshotItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventorySnapshotItemDeleteManyArgs>(args?: SelectSubset<T, InventorySnapshotItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySnapshotItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventorySnapshotItems
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventorySnapshotItemUpdateManyArgs>(args: SelectSubset<T, InventorySnapshotItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySnapshotItems and returns the data updated in the database.
     * @param {InventorySnapshotItemUpdateManyAndReturnArgs} args - Arguments to update many InventorySnapshotItems.
     * @example
     * // Update many InventorySnapshotItems
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventorySnapshotItems and only return the `id`
     * const inventorySnapshotItemWithIdOnly = await prisma.inventorySnapshotItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventorySnapshotItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventorySnapshotItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventorySnapshotItem.
     * @param {InventorySnapshotItemUpsertArgs} args - Arguments to update or create a InventorySnapshotItem.
     * @example
     * // Update or create a InventorySnapshotItem
     * const inventorySnapshotItem = await prisma.inventorySnapshotItem.upsert({
     *   create: {
     *     // ... data to create a InventorySnapshotItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventorySnapshotItem we want to update
     *   }
     * })
     */
    upsert<T extends InventorySnapshotItemUpsertArgs>(args: SelectSubset<T, InventorySnapshotItemUpsertArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventorySnapshotItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemCountArgs} args - Arguments to filter InventorySnapshotItems to count.
     * @example
     * // Count the number of InventorySnapshotItems
     * const count = await prisma.inventorySnapshotItem.count({
     *   where: {
     *     // ... the filter for the InventorySnapshotItems we want to count
     *   }
     * })
    **/
    count<T extends InventorySnapshotItemCountArgs>(
      args?: Subset<T, InventorySnapshotItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventorySnapshotItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventorySnapshotItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventorySnapshotItemAggregateArgs>(args: Subset<T, InventorySnapshotItemAggregateArgs>): Prisma.PrismaPromise<GetInventorySnapshotItemAggregateType<T>>

    /**
     * Group by InventorySnapshotItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySnapshotItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventorySnapshotItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventorySnapshotItemGroupByArgs['orderBy'] }
        : { orderBy?: InventorySnapshotItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventorySnapshotItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventorySnapshotItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventorySnapshotItem model
   */
  readonly fields: InventorySnapshotItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventorySnapshotItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventorySnapshotItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snapshot<T extends InventorySnapshotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventorySnapshotDefaultArgs<ExtArgs>>): Prisma__InventorySnapshotClient<$Result.GetResult<Prisma.$InventorySnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bottlePhoto<T extends InventorySnapshotItem$bottlePhotoArgs<ExtArgs> = {}>(args?: Subset<T, InventorySnapshotItem$bottlePhotoArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventorySnapshotItem model
   */
  interface InventorySnapshotItemFieldRefs {
    readonly id: FieldRef<"InventorySnapshotItem", 'String'>
    readonly snapshotId: FieldRef<"InventorySnapshotItem", 'String'>
    readonly inventoryItemId: FieldRef<"InventorySnapshotItem", 'String'>
    readonly quantityOnHand: FieldRef<"InventorySnapshotItem", 'Decimal'>
    readonly notes: FieldRef<"InventorySnapshotItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventorySnapshotItem findUnique
   */
  export type InventorySnapshotItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshotItem to fetch.
     */
    where: InventorySnapshotItemWhereUniqueInput
  }

  /**
   * InventorySnapshotItem findUniqueOrThrow
   */
  export type InventorySnapshotItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshotItem to fetch.
     */
    where: InventorySnapshotItemWhereUniqueInput
  }

  /**
   * InventorySnapshotItem findFirst
   */
  export type InventorySnapshotItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshotItem to fetch.
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshotItems to fetch.
     */
    orderBy?: InventorySnapshotItemOrderByWithRelationInput | InventorySnapshotItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySnapshotItems.
     */
    cursor?: InventorySnapshotItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshotItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshotItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySnapshotItems.
     */
    distinct?: InventorySnapshotItemScalarFieldEnum | InventorySnapshotItemScalarFieldEnum[]
  }

  /**
   * InventorySnapshotItem findFirstOrThrow
   */
  export type InventorySnapshotItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshotItem to fetch.
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshotItems to fetch.
     */
    orderBy?: InventorySnapshotItemOrderByWithRelationInput | InventorySnapshotItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySnapshotItems.
     */
    cursor?: InventorySnapshotItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshotItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshotItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySnapshotItems.
     */
    distinct?: InventorySnapshotItemScalarFieldEnum | InventorySnapshotItemScalarFieldEnum[]
  }

  /**
   * InventorySnapshotItem findMany
   */
  export type InventorySnapshotItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * Filter, which InventorySnapshotItems to fetch.
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySnapshotItems to fetch.
     */
    orderBy?: InventorySnapshotItemOrderByWithRelationInput | InventorySnapshotItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventorySnapshotItems.
     */
    cursor?: InventorySnapshotItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySnapshotItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySnapshotItems.
     */
    skip?: number
    distinct?: InventorySnapshotItemScalarFieldEnum | InventorySnapshotItemScalarFieldEnum[]
  }

  /**
   * InventorySnapshotItem create
   */
  export type InventorySnapshotItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventorySnapshotItem.
     */
    data: XOR<InventorySnapshotItemCreateInput, InventorySnapshotItemUncheckedCreateInput>
  }

  /**
   * InventorySnapshotItem createMany
   */
  export type InventorySnapshotItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventorySnapshotItems.
     */
    data: InventorySnapshotItemCreateManyInput | InventorySnapshotItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventorySnapshotItem createManyAndReturn
   */
  export type InventorySnapshotItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventorySnapshotItems.
     */
    data: InventorySnapshotItemCreateManyInput | InventorySnapshotItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventorySnapshotItem update
   */
  export type InventorySnapshotItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventorySnapshotItem.
     */
    data: XOR<InventorySnapshotItemUpdateInput, InventorySnapshotItemUncheckedUpdateInput>
    /**
     * Choose, which InventorySnapshotItem to update.
     */
    where: InventorySnapshotItemWhereUniqueInput
  }

  /**
   * InventorySnapshotItem updateMany
   */
  export type InventorySnapshotItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventorySnapshotItems.
     */
    data: XOR<InventorySnapshotItemUpdateManyMutationInput, InventorySnapshotItemUncheckedUpdateManyInput>
    /**
     * Filter which InventorySnapshotItems to update
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * Limit how many InventorySnapshotItems to update.
     */
    limit?: number
  }

  /**
   * InventorySnapshotItem updateManyAndReturn
   */
  export type InventorySnapshotItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * The data used to update InventorySnapshotItems.
     */
    data: XOR<InventorySnapshotItemUpdateManyMutationInput, InventorySnapshotItemUncheckedUpdateManyInput>
    /**
     * Filter which InventorySnapshotItems to update
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * Limit how many InventorySnapshotItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventorySnapshotItem upsert
   */
  export type InventorySnapshotItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventorySnapshotItem to update in case it exists.
     */
    where: InventorySnapshotItemWhereUniqueInput
    /**
     * In case the InventorySnapshotItem found by the `where` argument doesn't exist, create a new InventorySnapshotItem with this data.
     */
    create: XOR<InventorySnapshotItemCreateInput, InventorySnapshotItemUncheckedCreateInput>
    /**
     * In case the InventorySnapshotItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventorySnapshotItemUpdateInput, InventorySnapshotItemUncheckedUpdateInput>
  }

  /**
   * InventorySnapshotItem delete
   */
  export type InventorySnapshotItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
    /**
     * Filter which InventorySnapshotItem to delete.
     */
    where: InventorySnapshotItemWhereUniqueInput
  }

  /**
   * InventorySnapshotItem deleteMany
   */
  export type InventorySnapshotItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySnapshotItems to delete
     */
    where?: InventorySnapshotItemWhereInput
    /**
     * Limit how many InventorySnapshotItems to delete.
     */
    limit?: number
  }

  /**
   * InventorySnapshotItem.bottlePhoto
   */
  export type InventorySnapshotItem$bottlePhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    where?: BottlePhotoWhereInput
  }

  /**
   * InventorySnapshotItem without action
   */
  export type InventorySnapshotItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySnapshotItem
     */
    select?: InventorySnapshotItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySnapshotItem
     */
    omit?: InventorySnapshotItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySnapshotItemInclude<ExtArgs> | null
  }


  /**
   * Model BottlePhoto
   */

  export type AggregateBottlePhoto = {
    _count: BottlePhotoCountAggregateOutputType | null
    _avg: BottlePhotoAvgAggregateOutputType | null
    _sum: BottlePhotoSumAggregateOutputType | null
    _min: BottlePhotoMinAggregateOutputType | null
    _max: BottlePhotoMaxAggregateOutputType | null
  }

  export type BottlePhotoAvgAggregateOutputType = {
    estimatedPct: Decimal | null
    estimatedMl: Decimal | null
  }

  export type BottlePhotoSumAggregateOutputType = {
    estimatedPct: Decimal | null
    estimatedMl: Decimal | null
  }

  export type BottlePhotoMinAggregateOutputType = {
    id: string | null
    snapshotItemId: string | null
    imageUrl: string | null
    estimatedPct: Decimal | null
    estimatedMl: Decimal | null
    modelVersion: string | null
    createdAt: Date | null
  }

  export type BottlePhotoMaxAggregateOutputType = {
    id: string | null
    snapshotItemId: string | null
    imageUrl: string | null
    estimatedPct: Decimal | null
    estimatedMl: Decimal | null
    modelVersion: string | null
    createdAt: Date | null
  }

  export type BottlePhotoCountAggregateOutputType = {
    id: number
    snapshotItemId: number
    imageUrl: number
    estimatedPct: number
    estimatedMl: number
    modelVersion: number
    createdAt: number
    _all: number
  }


  export type BottlePhotoAvgAggregateInputType = {
    estimatedPct?: true
    estimatedMl?: true
  }

  export type BottlePhotoSumAggregateInputType = {
    estimatedPct?: true
    estimatedMl?: true
  }

  export type BottlePhotoMinAggregateInputType = {
    id?: true
    snapshotItemId?: true
    imageUrl?: true
    estimatedPct?: true
    estimatedMl?: true
    modelVersion?: true
    createdAt?: true
  }

  export type BottlePhotoMaxAggregateInputType = {
    id?: true
    snapshotItemId?: true
    imageUrl?: true
    estimatedPct?: true
    estimatedMl?: true
    modelVersion?: true
    createdAt?: true
  }

  export type BottlePhotoCountAggregateInputType = {
    id?: true
    snapshotItemId?: true
    imageUrl?: true
    estimatedPct?: true
    estimatedMl?: true
    modelVersion?: true
    createdAt?: true
    _all?: true
  }

  export type BottlePhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BottlePhoto to aggregate.
     */
    where?: BottlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottlePhotos to fetch.
     */
    orderBy?: BottlePhotoOrderByWithRelationInput | BottlePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BottlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottlePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BottlePhotos
    **/
    _count?: true | BottlePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BottlePhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BottlePhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BottlePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BottlePhotoMaxAggregateInputType
  }

  export type GetBottlePhotoAggregateType<T extends BottlePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateBottlePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBottlePhoto[P]>
      : GetScalarType<T[P], AggregateBottlePhoto[P]>
  }




  export type BottlePhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BottlePhotoWhereInput
    orderBy?: BottlePhotoOrderByWithAggregationInput | BottlePhotoOrderByWithAggregationInput[]
    by: BottlePhotoScalarFieldEnum[] | BottlePhotoScalarFieldEnum
    having?: BottlePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BottlePhotoCountAggregateInputType | true
    _avg?: BottlePhotoAvgAggregateInputType
    _sum?: BottlePhotoSumAggregateInputType
    _min?: BottlePhotoMinAggregateInputType
    _max?: BottlePhotoMaxAggregateInputType
  }

  export type BottlePhotoGroupByOutputType = {
    id: string
    snapshotItemId: string
    imageUrl: string
    estimatedPct: Decimal | null
    estimatedMl: Decimal | null
    modelVersion: string | null
    createdAt: Date
    _count: BottlePhotoCountAggregateOutputType | null
    _avg: BottlePhotoAvgAggregateOutputType | null
    _sum: BottlePhotoSumAggregateOutputType | null
    _min: BottlePhotoMinAggregateOutputType | null
    _max: BottlePhotoMaxAggregateOutputType | null
  }

  type GetBottlePhotoGroupByPayload<T extends BottlePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BottlePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BottlePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BottlePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], BottlePhotoGroupByOutputType[P]>
        }
      >
    >


  export type BottlePhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotItemId?: boolean
    imageUrl?: boolean
    estimatedPct?: boolean
    estimatedMl?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    snapshotItem?: boolean | InventorySnapshotItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bottlePhoto"]>

  export type BottlePhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotItemId?: boolean
    imageUrl?: boolean
    estimatedPct?: boolean
    estimatedMl?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    snapshotItem?: boolean | InventorySnapshotItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bottlePhoto"]>

  export type BottlePhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotItemId?: boolean
    imageUrl?: boolean
    estimatedPct?: boolean
    estimatedMl?: boolean
    modelVersion?: boolean
    createdAt?: boolean
    snapshotItem?: boolean | InventorySnapshotItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bottlePhoto"]>

  export type BottlePhotoSelectScalar = {
    id?: boolean
    snapshotItemId?: boolean
    imageUrl?: boolean
    estimatedPct?: boolean
    estimatedMl?: boolean
    modelVersion?: boolean
    createdAt?: boolean
  }

  export type BottlePhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "snapshotItemId" | "imageUrl" | "estimatedPct" | "estimatedMl" | "modelVersion" | "createdAt", ExtArgs["result"]["bottlePhoto"]>
  export type BottlePhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshotItem?: boolean | InventorySnapshotItemDefaultArgs<ExtArgs>
  }
  export type BottlePhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshotItem?: boolean | InventorySnapshotItemDefaultArgs<ExtArgs>
  }
  export type BottlePhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshotItem?: boolean | InventorySnapshotItemDefaultArgs<ExtArgs>
  }

  export type $BottlePhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BottlePhoto"
    objects: {
      snapshotItem: Prisma.$InventorySnapshotItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      snapshotItemId: string
      imageUrl: string
      estimatedPct: Prisma.Decimal | null
      estimatedMl: Prisma.Decimal | null
      modelVersion: string | null
      createdAt: Date
    }, ExtArgs["result"]["bottlePhoto"]>
    composites: {}
  }

  type BottlePhotoGetPayload<S extends boolean | null | undefined | BottlePhotoDefaultArgs> = $Result.GetResult<Prisma.$BottlePhotoPayload, S>

  type BottlePhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BottlePhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BottlePhotoCountAggregateInputType | true
    }

  export interface BottlePhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BottlePhoto'], meta: { name: 'BottlePhoto' } }
    /**
     * Find zero or one BottlePhoto that matches the filter.
     * @param {BottlePhotoFindUniqueArgs} args - Arguments to find a BottlePhoto
     * @example
     * // Get one BottlePhoto
     * const bottlePhoto = await prisma.bottlePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BottlePhotoFindUniqueArgs>(args: SelectSubset<T, BottlePhotoFindUniqueArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BottlePhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BottlePhotoFindUniqueOrThrowArgs} args - Arguments to find a BottlePhoto
     * @example
     * // Get one BottlePhoto
     * const bottlePhoto = await prisma.bottlePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BottlePhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, BottlePhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BottlePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoFindFirstArgs} args - Arguments to find a BottlePhoto
     * @example
     * // Get one BottlePhoto
     * const bottlePhoto = await prisma.bottlePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BottlePhotoFindFirstArgs>(args?: SelectSubset<T, BottlePhotoFindFirstArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BottlePhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoFindFirstOrThrowArgs} args - Arguments to find a BottlePhoto
     * @example
     * // Get one BottlePhoto
     * const bottlePhoto = await prisma.bottlePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BottlePhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, BottlePhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BottlePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BottlePhotos
     * const bottlePhotos = await prisma.bottlePhoto.findMany()
     * 
     * // Get first 10 BottlePhotos
     * const bottlePhotos = await prisma.bottlePhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bottlePhotoWithIdOnly = await prisma.bottlePhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BottlePhotoFindManyArgs>(args?: SelectSubset<T, BottlePhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BottlePhoto.
     * @param {BottlePhotoCreateArgs} args - Arguments to create a BottlePhoto.
     * @example
     * // Create one BottlePhoto
     * const BottlePhoto = await prisma.bottlePhoto.create({
     *   data: {
     *     // ... data to create a BottlePhoto
     *   }
     * })
     * 
     */
    create<T extends BottlePhotoCreateArgs>(args: SelectSubset<T, BottlePhotoCreateArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BottlePhotos.
     * @param {BottlePhotoCreateManyArgs} args - Arguments to create many BottlePhotos.
     * @example
     * // Create many BottlePhotos
     * const bottlePhoto = await prisma.bottlePhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BottlePhotoCreateManyArgs>(args?: SelectSubset<T, BottlePhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BottlePhotos and returns the data saved in the database.
     * @param {BottlePhotoCreateManyAndReturnArgs} args - Arguments to create many BottlePhotos.
     * @example
     * // Create many BottlePhotos
     * const bottlePhoto = await prisma.bottlePhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BottlePhotos and only return the `id`
     * const bottlePhotoWithIdOnly = await prisma.bottlePhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BottlePhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, BottlePhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BottlePhoto.
     * @param {BottlePhotoDeleteArgs} args - Arguments to delete one BottlePhoto.
     * @example
     * // Delete one BottlePhoto
     * const BottlePhoto = await prisma.bottlePhoto.delete({
     *   where: {
     *     // ... filter to delete one BottlePhoto
     *   }
     * })
     * 
     */
    delete<T extends BottlePhotoDeleteArgs>(args: SelectSubset<T, BottlePhotoDeleteArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BottlePhoto.
     * @param {BottlePhotoUpdateArgs} args - Arguments to update one BottlePhoto.
     * @example
     * // Update one BottlePhoto
     * const bottlePhoto = await prisma.bottlePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BottlePhotoUpdateArgs>(args: SelectSubset<T, BottlePhotoUpdateArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BottlePhotos.
     * @param {BottlePhotoDeleteManyArgs} args - Arguments to filter BottlePhotos to delete.
     * @example
     * // Delete a few BottlePhotos
     * const { count } = await prisma.bottlePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BottlePhotoDeleteManyArgs>(args?: SelectSubset<T, BottlePhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BottlePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BottlePhotos
     * const bottlePhoto = await prisma.bottlePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BottlePhotoUpdateManyArgs>(args: SelectSubset<T, BottlePhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BottlePhotos and returns the data updated in the database.
     * @param {BottlePhotoUpdateManyAndReturnArgs} args - Arguments to update many BottlePhotos.
     * @example
     * // Update many BottlePhotos
     * const bottlePhoto = await prisma.bottlePhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BottlePhotos and only return the `id`
     * const bottlePhotoWithIdOnly = await prisma.bottlePhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BottlePhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, BottlePhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BottlePhoto.
     * @param {BottlePhotoUpsertArgs} args - Arguments to update or create a BottlePhoto.
     * @example
     * // Update or create a BottlePhoto
     * const bottlePhoto = await prisma.bottlePhoto.upsert({
     *   create: {
     *     // ... data to create a BottlePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BottlePhoto we want to update
     *   }
     * })
     */
    upsert<T extends BottlePhotoUpsertArgs>(args: SelectSubset<T, BottlePhotoUpsertArgs<ExtArgs>>): Prisma__BottlePhotoClient<$Result.GetResult<Prisma.$BottlePhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BottlePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoCountArgs} args - Arguments to filter BottlePhotos to count.
     * @example
     * // Count the number of BottlePhotos
     * const count = await prisma.bottlePhoto.count({
     *   where: {
     *     // ... the filter for the BottlePhotos we want to count
     *   }
     * })
    **/
    count<T extends BottlePhotoCountArgs>(
      args?: Subset<T, BottlePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BottlePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BottlePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BottlePhotoAggregateArgs>(args: Subset<T, BottlePhotoAggregateArgs>): Prisma.PrismaPromise<GetBottlePhotoAggregateType<T>>

    /**
     * Group by BottlePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottlePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BottlePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BottlePhotoGroupByArgs['orderBy'] }
        : { orderBy?: BottlePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BottlePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBottlePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BottlePhoto model
   */
  readonly fields: BottlePhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BottlePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BottlePhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snapshotItem<T extends InventorySnapshotItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventorySnapshotItemDefaultArgs<ExtArgs>>): Prisma__InventorySnapshotItemClient<$Result.GetResult<Prisma.$InventorySnapshotItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BottlePhoto model
   */
  interface BottlePhotoFieldRefs {
    readonly id: FieldRef<"BottlePhoto", 'String'>
    readonly snapshotItemId: FieldRef<"BottlePhoto", 'String'>
    readonly imageUrl: FieldRef<"BottlePhoto", 'String'>
    readonly estimatedPct: FieldRef<"BottlePhoto", 'Decimal'>
    readonly estimatedMl: FieldRef<"BottlePhoto", 'Decimal'>
    readonly modelVersion: FieldRef<"BottlePhoto", 'String'>
    readonly createdAt: FieldRef<"BottlePhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BottlePhoto findUnique
   */
  export type BottlePhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * Filter, which BottlePhoto to fetch.
     */
    where: BottlePhotoWhereUniqueInput
  }

  /**
   * BottlePhoto findUniqueOrThrow
   */
  export type BottlePhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * Filter, which BottlePhoto to fetch.
     */
    where: BottlePhotoWhereUniqueInput
  }

  /**
   * BottlePhoto findFirst
   */
  export type BottlePhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * Filter, which BottlePhoto to fetch.
     */
    where?: BottlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottlePhotos to fetch.
     */
    orderBy?: BottlePhotoOrderByWithRelationInput | BottlePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BottlePhotos.
     */
    cursor?: BottlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottlePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BottlePhotos.
     */
    distinct?: BottlePhotoScalarFieldEnum | BottlePhotoScalarFieldEnum[]
  }

  /**
   * BottlePhoto findFirstOrThrow
   */
  export type BottlePhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * Filter, which BottlePhoto to fetch.
     */
    where?: BottlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottlePhotos to fetch.
     */
    orderBy?: BottlePhotoOrderByWithRelationInput | BottlePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BottlePhotos.
     */
    cursor?: BottlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottlePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BottlePhotos.
     */
    distinct?: BottlePhotoScalarFieldEnum | BottlePhotoScalarFieldEnum[]
  }

  /**
   * BottlePhoto findMany
   */
  export type BottlePhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * Filter, which BottlePhotos to fetch.
     */
    where?: BottlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottlePhotos to fetch.
     */
    orderBy?: BottlePhotoOrderByWithRelationInput | BottlePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BottlePhotos.
     */
    cursor?: BottlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottlePhotos.
     */
    skip?: number
    distinct?: BottlePhotoScalarFieldEnum | BottlePhotoScalarFieldEnum[]
  }

  /**
   * BottlePhoto create
   */
  export type BottlePhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a BottlePhoto.
     */
    data: XOR<BottlePhotoCreateInput, BottlePhotoUncheckedCreateInput>
  }

  /**
   * BottlePhoto createMany
   */
  export type BottlePhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BottlePhotos.
     */
    data: BottlePhotoCreateManyInput | BottlePhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BottlePhoto createManyAndReturn
   */
  export type BottlePhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * The data used to create many BottlePhotos.
     */
    data: BottlePhotoCreateManyInput | BottlePhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BottlePhoto update
   */
  export type BottlePhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a BottlePhoto.
     */
    data: XOR<BottlePhotoUpdateInput, BottlePhotoUncheckedUpdateInput>
    /**
     * Choose, which BottlePhoto to update.
     */
    where: BottlePhotoWhereUniqueInput
  }

  /**
   * BottlePhoto updateMany
   */
  export type BottlePhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BottlePhotos.
     */
    data: XOR<BottlePhotoUpdateManyMutationInput, BottlePhotoUncheckedUpdateManyInput>
    /**
     * Filter which BottlePhotos to update
     */
    where?: BottlePhotoWhereInput
    /**
     * Limit how many BottlePhotos to update.
     */
    limit?: number
  }

  /**
   * BottlePhoto updateManyAndReturn
   */
  export type BottlePhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * The data used to update BottlePhotos.
     */
    data: XOR<BottlePhotoUpdateManyMutationInput, BottlePhotoUncheckedUpdateManyInput>
    /**
     * Filter which BottlePhotos to update
     */
    where?: BottlePhotoWhereInput
    /**
     * Limit how many BottlePhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BottlePhoto upsert
   */
  export type BottlePhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the BottlePhoto to update in case it exists.
     */
    where: BottlePhotoWhereUniqueInput
    /**
     * In case the BottlePhoto found by the `where` argument doesn't exist, create a new BottlePhoto with this data.
     */
    create: XOR<BottlePhotoCreateInput, BottlePhotoUncheckedCreateInput>
    /**
     * In case the BottlePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BottlePhotoUpdateInput, BottlePhotoUncheckedUpdateInput>
  }

  /**
   * BottlePhoto delete
   */
  export type BottlePhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
    /**
     * Filter which BottlePhoto to delete.
     */
    where: BottlePhotoWhereUniqueInput
  }

  /**
   * BottlePhoto deleteMany
   */
  export type BottlePhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BottlePhotos to delete
     */
    where?: BottlePhotoWhereInput
    /**
     * Limit how many BottlePhotos to delete.
     */
    limit?: number
  }

  /**
   * BottlePhoto without action
   */
  export type BottlePhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottlePhoto
     */
    select?: BottlePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BottlePhoto
     */
    omit?: BottlePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BottlePhotoInclude<ExtArgs> | null
  }


  /**
   * Model CostingProfile
   */

  export type AggregateCostingProfile = {
    _count: CostingProfileCountAggregateOutputType | null
    _avg: CostingProfileAvgAggregateOutputType | null
    _sum: CostingProfileSumAggregateOutputType | null
    _min: CostingProfileMinAggregateOutputType | null
    _max: CostingProfileMaxAggregateOutputType | null
  }

  export type CostingProfileAvgAggregateOutputType = {
    pourSizeOz: Decimal | null
    menuPrice: Decimal | null
    costPerPour: Decimal | null
    marginPct: Decimal | null
    profitPerBottle: Decimal | null
  }

  export type CostingProfileSumAggregateOutputType = {
    pourSizeOz: Decimal | null
    menuPrice: Decimal | null
    costPerPour: Decimal | null
    marginPct: Decimal | null
    profitPerBottle: Decimal | null
  }

  export type CostingProfileMinAggregateOutputType = {
    id: string | null
    inventoryItemId: string | null
    pourSizeOz: Decimal | null
    menuPrice: Decimal | null
    costPerPour: Decimal | null
    marginPct: Decimal | null
    profitPerBottle: Decimal | null
    createdAt: Date | null
  }

  export type CostingProfileMaxAggregateOutputType = {
    id: string | null
    inventoryItemId: string | null
    pourSizeOz: Decimal | null
    menuPrice: Decimal | null
    costPerPour: Decimal | null
    marginPct: Decimal | null
    profitPerBottle: Decimal | null
    createdAt: Date | null
  }

  export type CostingProfileCountAggregateOutputType = {
    id: number
    inventoryItemId: number
    pourSizeOz: number
    menuPrice: number
    costPerPour: number
    marginPct: number
    profitPerBottle: number
    createdAt: number
    _all: number
  }


  export type CostingProfileAvgAggregateInputType = {
    pourSizeOz?: true
    menuPrice?: true
    costPerPour?: true
    marginPct?: true
    profitPerBottle?: true
  }

  export type CostingProfileSumAggregateInputType = {
    pourSizeOz?: true
    menuPrice?: true
    costPerPour?: true
    marginPct?: true
    profitPerBottle?: true
  }

  export type CostingProfileMinAggregateInputType = {
    id?: true
    inventoryItemId?: true
    pourSizeOz?: true
    menuPrice?: true
    costPerPour?: true
    marginPct?: true
    profitPerBottle?: true
    createdAt?: true
  }

  export type CostingProfileMaxAggregateInputType = {
    id?: true
    inventoryItemId?: true
    pourSizeOz?: true
    menuPrice?: true
    costPerPour?: true
    marginPct?: true
    profitPerBottle?: true
    createdAt?: true
  }

  export type CostingProfileCountAggregateInputType = {
    id?: true
    inventoryItemId?: true
    pourSizeOz?: true
    menuPrice?: true
    costPerPour?: true
    marginPct?: true
    profitPerBottle?: true
    createdAt?: true
    _all?: true
  }

  export type CostingProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostingProfile to aggregate.
     */
    where?: CostingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostingProfiles to fetch.
     */
    orderBy?: CostingProfileOrderByWithRelationInput | CostingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostingProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostingProfiles
    **/
    _count?: true | CostingProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostingProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostingProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostingProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostingProfileMaxAggregateInputType
  }

  export type GetCostingProfileAggregateType<T extends CostingProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCostingProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostingProfile[P]>
      : GetScalarType<T[P], AggregateCostingProfile[P]>
  }




  export type CostingProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostingProfileWhereInput
    orderBy?: CostingProfileOrderByWithAggregationInput | CostingProfileOrderByWithAggregationInput[]
    by: CostingProfileScalarFieldEnum[] | CostingProfileScalarFieldEnum
    having?: CostingProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostingProfileCountAggregateInputType | true
    _avg?: CostingProfileAvgAggregateInputType
    _sum?: CostingProfileSumAggregateInputType
    _min?: CostingProfileMinAggregateInputType
    _max?: CostingProfileMaxAggregateInputType
  }

  export type CostingProfileGroupByOutputType = {
    id: string
    inventoryItemId: string
    pourSizeOz: Decimal
    menuPrice: Decimal
    costPerPour: Decimal
    marginPct: Decimal
    profitPerBottle: Decimal
    createdAt: Date
    _count: CostingProfileCountAggregateOutputType | null
    _avg: CostingProfileAvgAggregateOutputType | null
    _sum: CostingProfileSumAggregateOutputType | null
    _min: CostingProfileMinAggregateOutputType | null
    _max: CostingProfileMaxAggregateOutputType | null
  }

  type GetCostingProfileGroupByPayload<T extends CostingProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostingProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostingProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostingProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CostingProfileGroupByOutputType[P]>
        }
      >
    >


  export type CostingProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryItemId?: boolean
    pourSizeOz?: boolean
    menuPrice?: boolean
    costPerPour?: boolean
    marginPct?: boolean
    profitPerBottle?: boolean
    createdAt?: boolean
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costingProfile"]>

  export type CostingProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryItemId?: boolean
    pourSizeOz?: boolean
    menuPrice?: boolean
    costPerPour?: boolean
    marginPct?: boolean
    profitPerBottle?: boolean
    createdAt?: boolean
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costingProfile"]>

  export type CostingProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryItemId?: boolean
    pourSizeOz?: boolean
    menuPrice?: boolean
    costPerPour?: boolean
    marginPct?: boolean
    profitPerBottle?: boolean
    createdAt?: boolean
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costingProfile"]>

  export type CostingProfileSelectScalar = {
    id?: boolean
    inventoryItemId?: boolean
    pourSizeOz?: boolean
    menuPrice?: boolean
    costPerPour?: boolean
    marginPct?: boolean
    profitPerBottle?: boolean
    createdAt?: boolean
  }

  export type CostingProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventoryItemId" | "pourSizeOz" | "menuPrice" | "costPerPour" | "marginPct" | "profitPerBottle" | "createdAt", ExtArgs["result"]["costingProfile"]>
  export type CostingProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type CostingProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type CostingProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $CostingProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostingProfile"
    objects: {
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventoryItemId: string
      pourSizeOz: Prisma.Decimal
      menuPrice: Prisma.Decimal
      costPerPour: Prisma.Decimal
      marginPct: Prisma.Decimal
      profitPerBottle: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["costingProfile"]>
    composites: {}
  }

  type CostingProfileGetPayload<S extends boolean | null | undefined | CostingProfileDefaultArgs> = $Result.GetResult<Prisma.$CostingProfilePayload, S>

  type CostingProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostingProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostingProfileCountAggregateInputType | true
    }

  export interface CostingProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostingProfile'], meta: { name: 'CostingProfile' } }
    /**
     * Find zero or one CostingProfile that matches the filter.
     * @param {CostingProfileFindUniqueArgs} args - Arguments to find a CostingProfile
     * @example
     * // Get one CostingProfile
     * const costingProfile = await prisma.costingProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostingProfileFindUniqueArgs>(args: SelectSubset<T, CostingProfileFindUniqueArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostingProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostingProfileFindUniqueOrThrowArgs} args - Arguments to find a CostingProfile
     * @example
     * // Get one CostingProfile
     * const costingProfile = await prisma.costingProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostingProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CostingProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostingProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileFindFirstArgs} args - Arguments to find a CostingProfile
     * @example
     * // Get one CostingProfile
     * const costingProfile = await prisma.costingProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostingProfileFindFirstArgs>(args?: SelectSubset<T, CostingProfileFindFirstArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostingProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileFindFirstOrThrowArgs} args - Arguments to find a CostingProfile
     * @example
     * // Get one CostingProfile
     * const costingProfile = await prisma.costingProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostingProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CostingProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostingProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostingProfiles
     * const costingProfiles = await prisma.costingProfile.findMany()
     * 
     * // Get first 10 CostingProfiles
     * const costingProfiles = await prisma.costingProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costingProfileWithIdOnly = await prisma.costingProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostingProfileFindManyArgs>(args?: SelectSubset<T, CostingProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostingProfile.
     * @param {CostingProfileCreateArgs} args - Arguments to create a CostingProfile.
     * @example
     * // Create one CostingProfile
     * const CostingProfile = await prisma.costingProfile.create({
     *   data: {
     *     // ... data to create a CostingProfile
     *   }
     * })
     * 
     */
    create<T extends CostingProfileCreateArgs>(args: SelectSubset<T, CostingProfileCreateArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostingProfiles.
     * @param {CostingProfileCreateManyArgs} args - Arguments to create many CostingProfiles.
     * @example
     * // Create many CostingProfiles
     * const costingProfile = await prisma.costingProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostingProfileCreateManyArgs>(args?: SelectSubset<T, CostingProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostingProfiles and returns the data saved in the database.
     * @param {CostingProfileCreateManyAndReturnArgs} args - Arguments to create many CostingProfiles.
     * @example
     * // Create many CostingProfiles
     * const costingProfile = await prisma.costingProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostingProfiles and only return the `id`
     * const costingProfileWithIdOnly = await prisma.costingProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostingProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CostingProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostingProfile.
     * @param {CostingProfileDeleteArgs} args - Arguments to delete one CostingProfile.
     * @example
     * // Delete one CostingProfile
     * const CostingProfile = await prisma.costingProfile.delete({
     *   where: {
     *     // ... filter to delete one CostingProfile
     *   }
     * })
     * 
     */
    delete<T extends CostingProfileDeleteArgs>(args: SelectSubset<T, CostingProfileDeleteArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostingProfile.
     * @param {CostingProfileUpdateArgs} args - Arguments to update one CostingProfile.
     * @example
     * // Update one CostingProfile
     * const costingProfile = await prisma.costingProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostingProfileUpdateArgs>(args: SelectSubset<T, CostingProfileUpdateArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostingProfiles.
     * @param {CostingProfileDeleteManyArgs} args - Arguments to filter CostingProfiles to delete.
     * @example
     * // Delete a few CostingProfiles
     * const { count } = await prisma.costingProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostingProfileDeleteManyArgs>(args?: SelectSubset<T, CostingProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostingProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostingProfiles
     * const costingProfile = await prisma.costingProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostingProfileUpdateManyArgs>(args: SelectSubset<T, CostingProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostingProfiles and returns the data updated in the database.
     * @param {CostingProfileUpdateManyAndReturnArgs} args - Arguments to update many CostingProfiles.
     * @example
     * // Update many CostingProfiles
     * const costingProfile = await prisma.costingProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostingProfiles and only return the `id`
     * const costingProfileWithIdOnly = await prisma.costingProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostingProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, CostingProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostingProfile.
     * @param {CostingProfileUpsertArgs} args - Arguments to update or create a CostingProfile.
     * @example
     * // Update or create a CostingProfile
     * const costingProfile = await prisma.costingProfile.upsert({
     *   create: {
     *     // ... data to create a CostingProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostingProfile we want to update
     *   }
     * })
     */
    upsert<T extends CostingProfileUpsertArgs>(args: SelectSubset<T, CostingProfileUpsertArgs<ExtArgs>>): Prisma__CostingProfileClient<$Result.GetResult<Prisma.$CostingProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostingProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileCountArgs} args - Arguments to filter CostingProfiles to count.
     * @example
     * // Count the number of CostingProfiles
     * const count = await prisma.costingProfile.count({
     *   where: {
     *     // ... the filter for the CostingProfiles we want to count
     *   }
     * })
    **/
    count<T extends CostingProfileCountArgs>(
      args?: Subset<T, CostingProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostingProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostingProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostingProfileAggregateArgs>(args: Subset<T, CostingProfileAggregateArgs>): Prisma.PrismaPromise<GetCostingProfileAggregateType<T>>

    /**
     * Group by CostingProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostingProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostingProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostingProfileGroupByArgs['orderBy'] }
        : { orderBy?: CostingProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostingProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostingProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostingProfile model
   */
  readonly fields: CostingProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostingProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostingProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostingProfile model
   */
  interface CostingProfileFieldRefs {
    readonly id: FieldRef<"CostingProfile", 'String'>
    readonly inventoryItemId: FieldRef<"CostingProfile", 'String'>
    readonly pourSizeOz: FieldRef<"CostingProfile", 'Decimal'>
    readonly menuPrice: FieldRef<"CostingProfile", 'Decimal'>
    readonly costPerPour: FieldRef<"CostingProfile", 'Decimal'>
    readonly marginPct: FieldRef<"CostingProfile", 'Decimal'>
    readonly profitPerBottle: FieldRef<"CostingProfile", 'Decimal'>
    readonly createdAt: FieldRef<"CostingProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostingProfile findUnique
   */
  export type CostingProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * Filter, which CostingProfile to fetch.
     */
    where: CostingProfileWhereUniqueInput
  }

  /**
   * CostingProfile findUniqueOrThrow
   */
  export type CostingProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * Filter, which CostingProfile to fetch.
     */
    where: CostingProfileWhereUniqueInput
  }

  /**
   * CostingProfile findFirst
   */
  export type CostingProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * Filter, which CostingProfile to fetch.
     */
    where?: CostingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostingProfiles to fetch.
     */
    orderBy?: CostingProfileOrderByWithRelationInput | CostingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostingProfiles.
     */
    cursor?: CostingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostingProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostingProfiles.
     */
    distinct?: CostingProfileScalarFieldEnum | CostingProfileScalarFieldEnum[]
  }

  /**
   * CostingProfile findFirstOrThrow
   */
  export type CostingProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * Filter, which CostingProfile to fetch.
     */
    where?: CostingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostingProfiles to fetch.
     */
    orderBy?: CostingProfileOrderByWithRelationInput | CostingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostingProfiles.
     */
    cursor?: CostingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostingProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostingProfiles.
     */
    distinct?: CostingProfileScalarFieldEnum | CostingProfileScalarFieldEnum[]
  }

  /**
   * CostingProfile findMany
   */
  export type CostingProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * Filter, which CostingProfiles to fetch.
     */
    where?: CostingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostingProfiles to fetch.
     */
    orderBy?: CostingProfileOrderByWithRelationInput | CostingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostingProfiles.
     */
    cursor?: CostingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostingProfiles.
     */
    skip?: number
    distinct?: CostingProfileScalarFieldEnum | CostingProfileScalarFieldEnum[]
  }

  /**
   * CostingProfile create
   */
  export type CostingProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CostingProfile.
     */
    data: XOR<CostingProfileCreateInput, CostingProfileUncheckedCreateInput>
  }

  /**
   * CostingProfile createMany
   */
  export type CostingProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostingProfiles.
     */
    data: CostingProfileCreateManyInput | CostingProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostingProfile createManyAndReturn
   */
  export type CostingProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * The data used to create many CostingProfiles.
     */
    data: CostingProfileCreateManyInput | CostingProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostingProfile update
   */
  export type CostingProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CostingProfile.
     */
    data: XOR<CostingProfileUpdateInput, CostingProfileUncheckedUpdateInput>
    /**
     * Choose, which CostingProfile to update.
     */
    where: CostingProfileWhereUniqueInput
  }

  /**
   * CostingProfile updateMany
   */
  export type CostingProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostingProfiles.
     */
    data: XOR<CostingProfileUpdateManyMutationInput, CostingProfileUncheckedUpdateManyInput>
    /**
     * Filter which CostingProfiles to update
     */
    where?: CostingProfileWhereInput
    /**
     * Limit how many CostingProfiles to update.
     */
    limit?: number
  }

  /**
   * CostingProfile updateManyAndReturn
   */
  export type CostingProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * The data used to update CostingProfiles.
     */
    data: XOR<CostingProfileUpdateManyMutationInput, CostingProfileUncheckedUpdateManyInput>
    /**
     * Filter which CostingProfiles to update
     */
    where?: CostingProfileWhereInput
    /**
     * Limit how many CostingProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostingProfile upsert
   */
  export type CostingProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CostingProfile to update in case it exists.
     */
    where: CostingProfileWhereUniqueInput
    /**
     * In case the CostingProfile found by the `where` argument doesn't exist, create a new CostingProfile with this data.
     */
    create: XOR<CostingProfileCreateInput, CostingProfileUncheckedCreateInput>
    /**
     * In case the CostingProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostingProfileUpdateInput, CostingProfileUncheckedUpdateInput>
  }

  /**
   * CostingProfile delete
   */
  export type CostingProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
    /**
     * Filter which CostingProfile to delete.
     */
    where: CostingProfileWhereUniqueInput
  }

  /**
   * CostingProfile deleteMany
   */
  export type CostingProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostingProfiles to delete
     */
    where?: CostingProfileWhereInput
    /**
     * Limit how many CostingProfiles to delete.
     */
    limit?: number
  }

  /**
   * CostingProfile without action
   */
  export type CostingProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostingProfile
     */
    select?: CostingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostingProfile
     */
    omit?: CostingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostingProfileInclude<ExtArgs> | null
  }


  /**
   * Model VarianceAlert
   */

  export type AggregateVarianceAlert = {
    _count: VarianceAlertCountAggregateOutputType | null
    _avg: VarianceAlertAvgAggregateOutputType | null
    _sum: VarianceAlertSumAggregateOutputType | null
    _min: VarianceAlertMinAggregateOutputType | null
    _max: VarianceAlertMaxAggregateOutputType | null
  }

  export type VarianceAlertAvgAggregateOutputType = {
    expectedMl: Decimal | null
    observedMl: Decimal | null
    varianceMl: Decimal | null
    variancePct: Decimal | null
  }

  export type VarianceAlertSumAggregateOutputType = {
    expectedMl: Decimal | null
    observedMl: Decimal | null
    varianceMl: Decimal | null
    variancePct: Decimal | null
  }

  export type VarianceAlertMinAggregateOutputType = {
    id: string | null
    barId: string | null
    inventoryItemId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    expectedMl: Decimal | null
    observedMl: Decimal | null
    varianceMl: Decimal | null
    variancePct: Decimal | null
    severity: string | null
    reasonHint: string | null
    createdAt: Date | null
  }

  export type VarianceAlertMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    inventoryItemId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    expectedMl: Decimal | null
    observedMl: Decimal | null
    varianceMl: Decimal | null
    variancePct: Decimal | null
    severity: string | null
    reasonHint: string | null
    createdAt: Date | null
  }

  export type VarianceAlertCountAggregateOutputType = {
    id: number
    barId: number
    inventoryItemId: number
    periodStart: number
    periodEnd: number
    expectedMl: number
    observedMl: number
    varianceMl: number
    variancePct: number
    severity: number
    reasonHint: number
    createdAt: number
    _all: number
  }


  export type VarianceAlertAvgAggregateInputType = {
    expectedMl?: true
    observedMl?: true
    varianceMl?: true
    variancePct?: true
  }

  export type VarianceAlertSumAggregateInputType = {
    expectedMl?: true
    observedMl?: true
    varianceMl?: true
    variancePct?: true
  }

  export type VarianceAlertMinAggregateInputType = {
    id?: true
    barId?: true
    inventoryItemId?: true
    periodStart?: true
    periodEnd?: true
    expectedMl?: true
    observedMl?: true
    varianceMl?: true
    variancePct?: true
    severity?: true
    reasonHint?: true
    createdAt?: true
  }

  export type VarianceAlertMaxAggregateInputType = {
    id?: true
    barId?: true
    inventoryItemId?: true
    periodStart?: true
    periodEnd?: true
    expectedMl?: true
    observedMl?: true
    varianceMl?: true
    variancePct?: true
    severity?: true
    reasonHint?: true
    createdAt?: true
  }

  export type VarianceAlertCountAggregateInputType = {
    id?: true
    barId?: true
    inventoryItemId?: true
    periodStart?: true
    periodEnd?: true
    expectedMl?: true
    observedMl?: true
    varianceMl?: true
    variancePct?: true
    severity?: true
    reasonHint?: true
    createdAt?: true
    _all?: true
  }

  export type VarianceAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VarianceAlert to aggregate.
     */
    where?: VarianceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceAlerts to fetch.
     */
    orderBy?: VarianceAlertOrderByWithRelationInput | VarianceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VarianceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VarianceAlerts
    **/
    _count?: true | VarianceAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VarianceAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VarianceAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VarianceAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VarianceAlertMaxAggregateInputType
  }

  export type GetVarianceAlertAggregateType<T extends VarianceAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateVarianceAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVarianceAlert[P]>
      : GetScalarType<T[P], AggregateVarianceAlert[P]>
  }




  export type VarianceAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianceAlertWhereInput
    orderBy?: VarianceAlertOrderByWithAggregationInput | VarianceAlertOrderByWithAggregationInput[]
    by: VarianceAlertScalarFieldEnum[] | VarianceAlertScalarFieldEnum
    having?: VarianceAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VarianceAlertCountAggregateInputType | true
    _avg?: VarianceAlertAvgAggregateInputType
    _sum?: VarianceAlertSumAggregateInputType
    _min?: VarianceAlertMinAggregateInputType
    _max?: VarianceAlertMaxAggregateInputType
  }

  export type VarianceAlertGroupByOutputType = {
    id: string
    barId: string
    inventoryItemId: string
    periodStart: Date
    periodEnd: Date
    expectedMl: Decimal
    observedMl: Decimal
    varianceMl: Decimal
    variancePct: Decimal
    severity: string
    reasonHint: string | null
    createdAt: Date
    _count: VarianceAlertCountAggregateOutputType | null
    _avg: VarianceAlertAvgAggregateOutputType | null
    _sum: VarianceAlertSumAggregateOutputType | null
    _min: VarianceAlertMinAggregateOutputType | null
    _max: VarianceAlertMaxAggregateOutputType | null
  }

  type GetVarianceAlertGroupByPayload<T extends VarianceAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VarianceAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VarianceAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VarianceAlertGroupByOutputType[P]>
            : GetScalarType<T[P], VarianceAlertGroupByOutputType[P]>
        }
      >
    >


  export type VarianceAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    inventoryItemId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    expectedMl?: boolean
    observedMl?: boolean
    varianceMl?: boolean
    variancePct?: boolean
    severity?: boolean
    reasonHint?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianceAlert"]>

  export type VarianceAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    inventoryItemId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    expectedMl?: boolean
    observedMl?: boolean
    varianceMl?: boolean
    variancePct?: boolean
    severity?: boolean
    reasonHint?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianceAlert"]>

  export type VarianceAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    inventoryItemId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    expectedMl?: boolean
    observedMl?: boolean
    varianceMl?: boolean
    variancePct?: boolean
    severity?: boolean
    reasonHint?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianceAlert"]>

  export type VarianceAlertSelectScalar = {
    id?: boolean
    barId?: boolean
    inventoryItemId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    expectedMl?: boolean
    observedMl?: boolean
    varianceMl?: boolean
    variancePct?: boolean
    severity?: boolean
    reasonHint?: boolean
    createdAt?: boolean
  }

  export type VarianceAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "inventoryItemId" | "periodStart" | "periodEnd" | "expectedMl" | "observedMl" | "varianceMl" | "variancePct" | "severity" | "reasonHint" | "createdAt", ExtArgs["result"]["varianceAlert"]>
  export type VarianceAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type VarianceAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type VarianceAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $VarianceAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VarianceAlert"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      inventoryItemId: string
      periodStart: Date
      periodEnd: Date
      expectedMl: Prisma.Decimal
      observedMl: Prisma.Decimal
      varianceMl: Prisma.Decimal
      variancePct: Prisma.Decimal
      severity: string
      reasonHint: string | null
      createdAt: Date
    }, ExtArgs["result"]["varianceAlert"]>
    composites: {}
  }

  type VarianceAlertGetPayload<S extends boolean | null | undefined | VarianceAlertDefaultArgs> = $Result.GetResult<Prisma.$VarianceAlertPayload, S>

  type VarianceAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VarianceAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VarianceAlertCountAggregateInputType | true
    }

  export interface VarianceAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VarianceAlert'], meta: { name: 'VarianceAlert' } }
    /**
     * Find zero or one VarianceAlert that matches the filter.
     * @param {VarianceAlertFindUniqueArgs} args - Arguments to find a VarianceAlert
     * @example
     * // Get one VarianceAlert
     * const varianceAlert = await prisma.varianceAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VarianceAlertFindUniqueArgs>(args: SelectSubset<T, VarianceAlertFindUniqueArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VarianceAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VarianceAlertFindUniqueOrThrowArgs} args - Arguments to find a VarianceAlert
     * @example
     * // Get one VarianceAlert
     * const varianceAlert = await prisma.varianceAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VarianceAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, VarianceAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VarianceAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertFindFirstArgs} args - Arguments to find a VarianceAlert
     * @example
     * // Get one VarianceAlert
     * const varianceAlert = await prisma.varianceAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VarianceAlertFindFirstArgs>(args?: SelectSubset<T, VarianceAlertFindFirstArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VarianceAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertFindFirstOrThrowArgs} args - Arguments to find a VarianceAlert
     * @example
     * // Get one VarianceAlert
     * const varianceAlert = await prisma.varianceAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VarianceAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, VarianceAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VarianceAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VarianceAlerts
     * const varianceAlerts = await prisma.varianceAlert.findMany()
     * 
     * // Get first 10 VarianceAlerts
     * const varianceAlerts = await prisma.varianceAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const varianceAlertWithIdOnly = await prisma.varianceAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VarianceAlertFindManyArgs>(args?: SelectSubset<T, VarianceAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VarianceAlert.
     * @param {VarianceAlertCreateArgs} args - Arguments to create a VarianceAlert.
     * @example
     * // Create one VarianceAlert
     * const VarianceAlert = await prisma.varianceAlert.create({
     *   data: {
     *     // ... data to create a VarianceAlert
     *   }
     * })
     * 
     */
    create<T extends VarianceAlertCreateArgs>(args: SelectSubset<T, VarianceAlertCreateArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VarianceAlerts.
     * @param {VarianceAlertCreateManyArgs} args - Arguments to create many VarianceAlerts.
     * @example
     * // Create many VarianceAlerts
     * const varianceAlert = await prisma.varianceAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VarianceAlertCreateManyArgs>(args?: SelectSubset<T, VarianceAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VarianceAlerts and returns the data saved in the database.
     * @param {VarianceAlertCreateManyAndReturnArgs} args - Arguments to create many VarianceAlerts.
     * @example
     * // Create many VarianceAlerts
     * const varianceAlert = await prisma.varianceAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VarianceAlerts and only return the `id`
     * const varianceAlertWithIdOnly = await prisma.varianceAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VarianceAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, VarianceAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VarianceAlert.
     * @param {VarianceAlertDeleteArgs} args - Arguments to delete one VarianceAlert.
     * @example
     * // Delete one VarianceAlert
     * const VarianceAlert = await prisma.varianceAlert.delete({
     *   where: {
     *     // ... filter to delete one VarianceAlert
     *   }
     * })
     * 
     */
    delete<T extends VarianceAlertDeleteArgs>(args: SelectSubset<T, VarianceAlertDeleteArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VarianceAlert.
     * @param {VarianceAlertUpdateArgs} args - Arguments to update one VarianceAlert.
     * @example
     * // Update one VarianceAlert
     * const varianceAlert = await prisma.varianceAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VarianceAlertUpdateArgs>(args: SelectSubset<T, VarianceAlertUpdateArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VarianceAlerts.
     * @param {VarianceAlertDeleteManyArgs} args - Arguments to filter VarianceAlerts to delete.
     * @example
     * // Delete a few VarianceAlerts
     * const { count } = await prisma.varianceAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VarianceAlertDeleteManyArgs>(args?: SelectSubset<T, VarianceAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VarianceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VarianceAlerts
     * const varianceAlert = await prisma.varianceAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VarianceAlertUpdateManyArgs>(args: SelectSubset<T, VarianceAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VarianceAlerts and returns the data updated in the database.
     * @param {VarianceAlertUpdateManyAndReturnArgs} args - Arguments to update many VarianceAlerts.
     * @example
     * // Update many VarianceAlerts
     * const varianceAlert = await prisma.varianceAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VarianceAlerts and only return the `id`
     * const varianceAlertWithIdOnly = await prisma.varianceAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VarianceAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, VarianceAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VarianceAlert.
     * @param {VarianceAlertUpsertArgs} args - Arguments to update or create a VarianceAlert.
     * @example
     * // Update or create a VarianceAlert
     * const varianceAlert = await prisma.varianceAlert.upsert({
     *   create: {
     *     // ... data to create a VarianceAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VarianceAlert we want to update
     *   }
     * })
     */
    upsert<T extends VarianceAlertUpsertArgs>(args: SelectSubset<T, VarianceAlertUpsertArgs<ExtArgs>>): Prisma__VarianceAlertClient<$Result.GetResult<Prisma.$VarianceAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VarianceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertCountArgs} args - Arguments to filter VarianceAlerts to count.
     * @example
     * // Count the number of VarianceAlerts
     * const count = await prisma.varianceAlert.count({
     *   where: {
     *     // ... the filter for the VarianceAlerts we want to count
     *   }
     * })
    **/
    count<T extends VarianceAlertCountArgs>(
      args?: Subset<T, VarianceAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VarianceAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VarianceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VarianceAlertAggregateArgs>(args: Subset<T, VarianceAlertAggregateArgs>): Prisma.PrismaPromise<GetVarianceAlertAggregateType<T>>

    /**
     * Group by VarianceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianceAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VarianceAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VarianceAlertGroupByArgs['orderBy'] }
        : { orderBy?: VarianceAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VarianceAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVarianceAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VarianceAlert model
   */
  readonly fields: VarianceAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VarianceAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VarianceAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VarianceAlert model
   */
  interface VarianceAlertFieldRefs {
    readonly id: FieldRef<"VarianceAlert", 'String'>
    readonly barId: FieldRef<"VarianceAlert", 'String'>
    readonly inventoryItemId: FieldRef<"VarianceAlert", 'String'>
    readonly periodStart: FieldRef<"VarianceAlert", 'DateTime'>
    readonly periodEnd: FieldRef<"VarianceAlert", 'DateTime'>
    readonly expectedMl: FieldRef<"VarianceAlert", 'Decimal'>
    readonly observedMl: FieldRef<"VarianceAlert", 'Decimal'>
    readonly varianceMl: FieldRef<"VarianceAlert", 'Decimal'>
    readonly variancePct: FieldRef<"VarianceAlert", 'Decimal'>
    readonly severity: FieldRef<"VarianceAlert", 'String'>
    readonly reasonHint: FieldRef<"VarianceAlert", 'String'>
    readonly createdAt: FieldRef<"VarianceAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VarianceAlert findUnique
   */
  export type VarianceAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * Filter, which VarianceAlert to fetch.
     */
    where: VarianceAlertWhereUniqueInput
  }

  /**
   * VarianceAlert findUniqueOrThrow
   */
  export type VarianceAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * Filter, which VarianceAlert to fetch.
     */
    where: VarianceAlertWhereUniqueInput
  }

  /**
   * VarianceAlert findFirst
   */
  export type VarianceAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * Filter, which VarianceAlert to fetch.
     */
    where?: VarianceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceAlerts to fetch.
     */
    orderBy?: VarianceAlertOrderByWithRelationInput | VarianceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VarianceAlerts.
     */
    cursor?: VarianceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VarianceAlerts.
     */
    distinct?: VarianceAlertScalarFieldEnum | VarianceAlertScalarFieldEnum[]
  }

  /**
   * VarianceAlert findFirstOrThrow
   */
  export type VarianceAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * Filter, which VarianceAlert to fetch.
     */
    where?: VarianceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceAlerts to fetch.
     */
    orderBy?: VarianceAlertOrderByWithRelationInput | VarianceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VarianceAlerts.
     */
    cursor?: VarianceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VarianceAlerts.
     */
    distinct?: VarianceAlertScalarFieldEnum | VarianceAlertScalarFieldEnum[]
  }

  /**
   * VarianceAlert findMany
   */
  export type VarianceAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * Filter, which VarianceAlerts to fetch.
     */
    where?: VarianceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianceAlerts to fetch.
     */
    orderBy?: VarianceAlertOrderByWithRelationInput | VarianceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VarianceAlerts.
     */
    cursor?: VarianceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianceAlerts.
     */
    skip?: number
    distinct?: VarianceAlertScalarFieldEnum | VarianceAlertScalarFieldEnum[]
  }

  /**
   * VarianceAlert create
   */
  export type VarianceAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a VarianceAlert.
     */
    data: XOR<VarianceAlertCreateInput, VarianceAlertUncheckedCreateInput>
  }

  /**
   * VarianceAlert createMany
   */
  export type VarianceAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VarianceAlerts.
     */
    data: VarianceAlertCreateManyInput | VarianceAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VarianceAlert createManyAndReturn
   */
  export type VarianceAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * The data used to create many VarianceAlerts.
     */
    data: VarianceAlertCreateManyInput | VarianceAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VarianceAlert update
   */
  export type VarianceAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a VarianceAlert.
     */
    data: XOR<VarianceAlertUpdateInput, VarianceAlertUncheckedUpdateInput>
    /**
     * Choose, which VarianceAlert to update.
     */
    where: VarianceAlertWhereUniqueInput
  }

  /**
   * VarianceAlert updateMany
   */
  export type VarianceAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VarianceAlerts.
     */
    data: XOR<VarianceAlertUpdateManyMutationInput, VarianceAlertUncheckedUpdateManyInput>
    /**
     * Filter which VarianceAlerts to update
     */
    where?: VarianceAlertWhereInput
    /**
     * Limit how many VarianceAlerts to update.
     */
    limit?: number
  }

  /**
   * VarianceAlert updateManyAndReturn
   */
  export type VarianceAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * The data used to update VarianceAlerts.
     */
    data: XOR<VarianceAlertUpdateManyMutationInput, VarianceAlertUncheckedUpdateManyInput>
    /**
     * Filter which VarianceAlerts to update
     */
    where?: VarianceAlertWhereInput
    /**
     * Limit how many VarianceAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VarianceAlert upsert
   */
  export type VarianceAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the VarianceAlert to update in case it exists.
     */
    where: VarianceAlertWhereUniqueInput
    /**
     * In case the VarianceAlert found by the `where` argument doesn't exist, create a new VarianceAlert with this data.
     */
    create: XOR<VarianceAlertCreateInput, VarianceAlertUncheckedCreateInput>
    /**
     * In case the VarianceAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VarianceAlertUpdateInput, VarianceAlertUncheckedUpdateInput>
  }

  /**
   * VarianceAlert delete
   */
  export type VarianceAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
    /**
     * Filter which VarianceAlert to delete.
     */
    where: VarianceAlertWhereUniqueInput
  }

  /**
   * VarianceAlert deleteMany
   */
  export type VarianceAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VarianceAlerts to delete
     */
    where?: VarianceAlertWhereInput
    /**
     * Limit how many VarianceAlerts to delete.
     */
    limit?: number
  }

  /**
   * VarianceAlert without action
   */
  export type VarianceAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianceAlert
     */
    select?: VarianceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianceAlert
     */
    omit?: VarianceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianceAlertInclude<ExtArgs> | null
  }


  /**
   * Model BarLicense
   */

  export type AggregateBarLicense = {
    _count: BarLicenseCountAggregateOutputType | null
    _avg: BarLicenseAvgAggregateOutputType | null
    _sum: BarLicenseSumAggregateOutputType | null
    _min: BarLicenseMinAggregateOutputType | null
    _max: BarLicenseMaxAggregateOutputType | null
  }

  export type BarLicenseAvgAggregateOutputType = {
    priceCents: number | null
  }

  export type BarLicenseSumAggregateOutputType = {
    priceCents: number | null
  }

  export type BarLicenseMinAggregateOutputType = {
    id: string | null
    barId: string | null
    ownerId: string | null
    status: string | null
    priceCents: number | null
    currency: string | null
    billingCycle: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarLicenseMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    ownerId: string | null
    status: string | null
    priceCents: number | null
    currency: string | null
    billingCycle: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarLicenseCountAggregateOutputType = {
    id: number
    barId: number
    ownerId: number
    status: number
    priceCents: number
    currency: number
    billingCycle: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BarLicenseAvgAggregateInputType = {
    priceCents?: true
  }

  export type BarLicenseSumAggregateInputType = {
    priceCents?: true
  }

  export type BarLicenseMinAggregateInputType = {
    id?: true
    barId?: true
    ownerId?: true
    status?: true
    priceCents?: true
    currency?: true
    billingCycle?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarLicenseMaxAggregateInputType = {
    id?: true
    barId?: true
    ownerId?: true
    status?: true
    priceCents?: true
    currency?: true
    billingCycle?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarLicenseCountAggregateInputType = {
    id?: true
    barId?: true
    ownerId?: true
    status?: true
    priceCents?: true
    currency?: true
    billingCycle?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BarLicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarLicense to aggregate.
     */
    where?: BarLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarLicenses to fetch.
     */
    orderBy?: BarLicenseOrderByWithRelationInput | BarLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarLicenses
    **/
    _count?: true | BarLicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarLicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarLicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarLicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarLicenseMaxAggregateInputType
  }

  export type GetBarLicenseAggregateType<T extends BarLicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateBarLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarLicense[P]>
      : GetScalarType<T[P], AggregateBarLicense[P]>
  }




  export type BarLicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarLicenseWhereInput
    orderBy?: BarLicenseOrderByWithAggregationInput | BarLicenseOrderByWithAggregationInput[]
    by: BarLicenseScalarFieldEnum[] | BarLicenseScalarFieldEnum
    having?: BarLicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarLicenseCountAggregateInputType | true
    _avg?: BarLicenseAvgAggregateInputType
    _sum?: BarLicenseSumAggregateInputType
    _min?: BarLicenseMinAggregateInputType
    _max?: BarLicenseMaxAggregateInputType
  }

  export type BarLicenseGroupByOutputType = {
    id: string
    barId: string
    ownerId: string
    status: string
    priceCents: number
    currency: string
    billingCycle: string
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BarLicenseCountAggregateOutputType | null
    _avg: BarLicenseAvgAggregateOutputType | null
    _sum: BarLicenseSumAggregateOutputType | null
    _min: BarLicenseMinAggregateOutputType | null
    _max: BarLicenseMaxAggregateOutputType | null
  }

  type GetBarLicenseGroupByPayload<T extends BarLicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarLicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarLicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarLicenseGroupByOutputType[P]>
            : GetScalarType<T[P], BarLicenseGroupByOutputType[P]>
        }
      >
    >


  export type BarLicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    status?: boolean
    priceCents?: boolean
    currency?: boolean
    billingCycle?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barLicense"]>

  export type BarLicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    status?: boolean
    priceCents?: boolean
    currency?: boolean
    billingCycle?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barLicense"]>

  export type BarLicenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    status?: boolean
    priceCents?: boolean
    currency?: boolean
    billingCycle?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barLicense"]>

  export type BarLicenseSelectScalar = {
    id?: boolean
    barId?: boolean
    ownerId?: boolean
    status?: boolean
    priceCents?: boolean
    currency?: boolean
    billingCycle?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BarLicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "ownerId" | "status" | "priceCents" | "currency" | "billingCycle" | "externalId" | "createdAt" | "updatedAt", ExtArgs["result"]["barLicense"]>
  export type BarLicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type BarLicenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type BarLicenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $BarLicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarLicense"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      ownerId: string
      status: string
      priceCents: number
      currency: string
      billingCycle: string
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["barLicense"]>
    composites: {}
  }

  type BarLicenseGetPayload<S extends boolean | null | undefined | BarLicenseDefaultArgs> = $Result.GetResult<Prisma.$BarLicensePayload, S>

  type BarLicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarLicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarLicenseCountAggregateInputType | true
    }

  export interface BarLicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarLicense'], meta: { name: 'BarLicense' } }
    /**
     * Find zero or one BarLicense that matches the filter.
     * @param {BarLicenseFindUniqueArgs} args - Arguments to find a BarLicense
     * @example
     * // Get one BarLicense
     * const barLicense = await prisma.barLicense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarLicenseFindUniqueArgs>(args: SelectSubset<T, BarLicenseFindUniqueArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarLicense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarLicenseFindUniqueOrThrowArgs} args - Arguments to find a BarLicense
     * @example
     * // Get one BarLicense
     * const barLicense = await prisma.barLicense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarLicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, BarLicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarLicense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseFindFirstArgs} args - Arguments to find a BarLicense
     * @example
     * // Get one BarLicense
     * const barLicense = await prisma.barLicense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarLicenseFindFirstArgs>(args?: SelectSubset<T, BarLicenseFindFirstArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarLicense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseFindFirstOrThrowArgs} args - Arguments to find a BarLicense
     * @example
     * // Get one BarLicense
     * const barLicense = await prisma.barLicense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarLicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, BarLicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarLicenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarLicenses
     * const barLicenses = await prisma.barLicense.findMany()
     * 
     * // Get first 10 BarLicenses
     * const barLicenses = await prisma.barLicense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barLicenseWithIdOnly = await prisma.barLicense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarLicenseFindManyArgs>(args?: SelectSubset<T, BarLicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarLicense.
     * @param {BarLicenseCreateArgs} args - Arguments to create a BarLicense.
     * @example
     * // Create one BarLicense
     * const BarLicense = await prisma.barLicense.create({
     *   data: {
     *     // ... data to create a BarLicense
     *   }
     * })
     * 
     */
    create<T extends BarLicenseCreateArgs>(args: SelectSubset<T, BarLicenseCreateArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarLicenses.
     * @param {BarLicenseCreateManyArgs} args - Arguments to create many BarLicenses.
     * @example
     * // Create many BarLicenses
     * const barLicense = await prisma.barLicense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarLicenseCreateManyArgs>(args?: SelectSubset<T, BarLicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarLicenses and returns the data saved in the database.
     * @param {BarLicenseCreateManyAndReturnArgs} args - Arguments to create many BarLicenses.
     * @example
     * // Create many BarLicenses
     * const barLicense = await prisma.barLicense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarLicenses and only return the `id`
     * const barLicenseWithIdOnly = await prisma.barLicense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarLicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, BarLicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarLicense.
     * @param {BarLicenseDeleteArgs} args - Arguments to delete one BarLicense.
     * @example
     * // Delete one BarLicense
     * const BarLicense = await prisma.barLicense.delete({
     *   where: {
     *     // ... filter to delete one BarLicense
     *   }
     * })
     * 
     */
    delete<T extends BarLicenseDeleteArgs>(args: SelectSubset<T, BarLicenseDeleteArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarLicense.
     * @param {BarLicenseUpdateArgs} args - Arguments to update one BarLicense.
     * @example
     * // Update one BarLicense
     * const barLicense = await prisma.barLicense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarLicenseUpdateArgs>(args: SelectSubset<T, BarLicenseUpdateArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarLicenses.
     * @param {BarLicenseDeleteManyArgs} args - Arguments to filter BarLicenses to delete.
     * @example
     * // Delete a few BarLicenses
     * const { count } = await prisma.barLicense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarLicenseDeleteManyArgs>(args?: SelectSubset<T, BarLicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarLicenses
     * const barLicense = await prisma.barLicense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarLicenseUpdateManyArgs>(args: SelectSubset<T, BarLicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarLicenses and returns the data updated in the database.
     * @param {BarLicenseUpdateManyAndReturnArgs} args - Arguments to update many BarLicenses.
     * @example
     * // Update many BarLicenses
     * const barLicense = await prisma.barLicense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarLicenses and only return the `id`
     * const barLicenseWithIdOnly = await prisma.barLicense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarLicenseUpdateManyAndReturnArgs>(args: SelectSubset<T, BarLicenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarLicense.
     * @param {BarLicenseUpsertArgs} args - Arguments to update or create a BarLicense.
     * @example
     * // Update or create a BarLicense
     * const barLicense = await prisma.barLicense.upsert({
     *   create: {
     *     // ... data to create a BarLicense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarLicense we want to update
     *   }
     * })
     */
    upsert<T extends BarLicenseUpsertArgs>(args: SelectSubset<T, BarLicenseUpsertArgs<ExtArgs>>): Prisma__BarLicenseClient<$Result.GetResult<Prisma.$BarLicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseCountArgs} args - Arguments to filter BarLicenses to count.
     * @example
     * // Count the number of BarLicenses
     * const count = await prisma.barLicense.count({
     *   where: {
     *     // ... the filter for the BarLicenses we want to count
     *   }
     * })
    **/
    count<T extends BarLicenseCountArgs>(
      args?: Subset<T, BarLicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarLicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarLicenseAggregateArgs>(args: Subset<T, BarLicenseAggregateArgs>): Prisma.PrismaPromise<GetBarLicenseAggregateType<T>>

    /**
     * Group by BarLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarLicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarLicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarLicenseGroupByArgs['orderBy'] }
        : { orderBy?: BarLicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarLicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarLicense model
   */
  readonly fields: BarLicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarLicense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarLicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarLicense model
   */
  interface BarLicenseFieldRefs {
    readonly id: FieldRef<"BarLicense", 'String'>
    readonly barId: FieldRef<"BarLicense", 'String'>
    readonly ownerId: FieldRef<"BarLicense", 'String'>
    readonly status: FieldRef<"BarLicense", 'String'>
    readonly priceCents: FieldRef<"BarLicense", 'Int'>
    readonly currency: FieldRef<"BarLicense", 'String'>
    readonly billingCycle: FieldRef<"BarLicense", 'String'>
    readonly externalId: FieldRef<"BarLicense", 'String'>
    readonly createdAt: FieldRef<"BarLicense", 'DateTime'>
    readonly updatedAt: FieldRef<"BarLicense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarLicense findUnique
   */
  export type BarLicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * Filter, which BarLicense to fetch.
     */
    where: BarLicenseWhereUniqueInput
  }

  /**
   * BarLicense findUniqueOrThrow
   */
  export type BarLicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * Filter, which BarLicense to fetch.
     */
    where: BarLicenseWhereUniqueInput
  }

  /**
   * BarLicense findFirst
   */
  export type BarLicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * Filter, which BarLicense to fetch.
     */
    where?: BarLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarLicenses to fetch.
     */
    orderBy?: BarLicenseOrderByWithRelationInput | BarLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarLicenses.
     */
    cursor?: BarLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarLicenses.
     */
    distinct?: BarLicenseScalarFieldEnum | BarLicenseScalarFieldEnum[]
  }

  /**
   * BarLicense findFirstOrThrow
   */
  export type BarLicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * Filter, which BarLicense to fetch.
     */
    where?: BarLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarLicenses to fetch.
     */
    orderBy?: BarLicenseOrderByWithRelationInput | BarLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarLicenses.
     */
    cursor?: BarLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarLicenses.
     */
    distinct?: BarLicenseScalarFieldEnum | BarLicenseScalarFieldEnum[]
  }

  /**
   * BarLicense findMany
   */
  export type BarLicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * Filter, which BarLicenses to fetch.
     */
    where?: BarLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarLicenses to fetch.
     */
    orderBy?: BarLicenseOrderByWithRelationInput | BarLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarLicenses.
     */
    cursor?: BarLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarLicenses.
     */
    skip?: number
    distinct?: BarLicenseScalarFieldEnum | BarLicenseScalarFieldEnum[]
  }

  /**
   * BarLicense create
   */
  export type BarLicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a BarLicense.
     */
    data: XOR<BarLicenseCreateInput, BarLicenseUncheckedCreateInput>
  }

  /**
   * BarLicense createMany
   */
  export type BarLicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarLicenses.
     */
    data: BarLicenseCreateManyInput | BarLicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarLicense createManyAndReturn
   */
  export type BarLicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * The data used to create many BarLicenses.
     */
    data: BarLicenseCreateManyInput | BarLicenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarLicense update
   */
  export type BarLicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a BarLicense.
     */
    data: XOR<BarLicenseUpdateInput, BarLicenseUncheckedUpdateInput>
    /**
     * Choose, which BarLicense to update.
     */
    where: BarLicenseWhereUniqueInput
  }

  /**
   * BarLicense updateMany
   */
  export type BarLicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarLicenses.
     */
    data: XOR<BarLicenseUpdateManyMutationInput, BarLicenseUncheckedUpdateManyInput>
    /**
     * Filter which BarLicenses to update
     */
    where?: BarLicenseWhereInput
    /**
     * Limit how many BarLicenses to update.
     */
    limit?: number
  }

  /**
   * BarLicense updateManyAndReturn
   */
  export type BarLicenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * The data used to update BarLicenses.
     */
    data: XOR<BarLicenseUpdateManyMutationInput, BarLicenseUncheckedUpdateManyInput>
    /**
     * Filter which BarLicenses to update
     */
    where?: BarLicenseWhereInput
    /**
     * Limit how many BarLicenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarLicense upsert
   */
  export type BarLicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the BarLicense to update in case it exists.
     */
    where: BarLicenseWhereUniqueInput
    /**
     * In case the BarLicense found by the `where` argument doesn't exist, create a new BarLicense with this data.
     */
    create: XOR<BarLicenseCreateInput, BarLicenseUncheckedCreateInput>
    /**
     * In case the BarLicense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarLicenseUpdateInput, BarLicenseUncheckedUpdateInput>
  }

  /**
   * BarLicense delete
   */
  export type BarLicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
    /**
     * Filter which BarLicense to delete.
     */
    where: BarLicenseWhereUniqueInput
  }

  /**
   * BarLicense deleteMany
   */
  export type BarLicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarLicenses to delete
     */
    where?: BarLicenseWhereInput
    /**
     * Limit how many BarLicenses to delete.
     */
    limit?: number
  }

  /**
   * BarLicense without action
   */
  export type BarLicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarLicense
     */
    select?: BarLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarLicense
     */
    omit?: BarLicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarLicenseInclude<ExtArgs> | null
  }


  /**
   * Model BarVisit
   */

  export type AggregateBarVisit = {
    _count: BarVisitCountAggregateOutputType | null
    _min: BarVisitMinAggregateOutputType | null
    _max: BarVisitMaxAggregateOutputType | null
  }

  export type BarVisitMinAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    source: string | null
    verificationMethod: string | null
    clickId: string | null
    promoCodeId: string | null
    visitedAt: Date | null
    createdAt: Date | null
  }

  export type BarVisitMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    source: string | null
    verificationMethod: string | null
    clickId: string | null
    promoCodeId: string | null
    visitedAt: Date | null
    createdAt: Date | null
  }

  export type BarVisitCountAggregateOutputType = {
    id: number
    barId: number
    userId: number
    source: number
    verificationMethod: number
    clickId: number
    promoCodeId: number
    metadata: number
    visitedAt: number
    createdAt: number
    _all: number
  }


  export type BarVisitMinAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    source?: true
    verificationMethod?: true
    clickId?: true
    promoCodeId?: true
    visitedAt?: true
    createdAt?: true
  }

  export type BarVisitMaxAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    source?: true
    verificationMethod?: true
    clickId?: true
    promoCodeId?: true
    visitedAt?: true
    createdAt?: true
  }

  export type BarVisitCountAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    source?: true
    verificationMethod?: true
    clickId?: true
    promoCodeId?: true
    metadata?: true
    visitedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BarVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarVisit to aggregate.
     */
    where?: BarVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarVisits to fetch.
     */
    orderBy?: BarVisitOrderByWithRelationInput | BarVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarVisits
    **/
    _count?: true | BarVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarVisitMaxAggregateInputType
  }

  export type GetBarVisitAggregateType<T extends BarVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateBarVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarVisit[P]>
      : GetScalarType<T[P], AggregateBarVisit[P]>
  }




  export type BarVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarVisitWhereInput
    orderBy?: BarVisitOrderByWithAggregationInput | BarVisitOrderByWithAggregationInput[]
    by: BarVisitScalarFieldEnum[] | BarVisitScalarFieldEnum
    having?: BarVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarVisitCountAggregateInputType | true
    _min?: BarVisitMinAggregateInputType
    _max?: BarVisitMaxAggregateInputType
  }

  export type BarVisitGroupByOutputType = {
    id: string
    barId: string
    userId: string | null
    source: string
    verificationMethod: string
    clickId: string | null
    promoCodeId: string | null
    metadata: JsonValue | null
    visitedAt: Date
    createdAt: Date
    _count: BarVisitCountAggregateOutputType | null
    _min: BarVisitMinAggregateOutputType | null
    _max: BarVisitMaxAggregateOutputType | null
  }

  type GetBarVisitGroupByPayload<T extends BarVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarVisitGroupByOutputType[P]>
            : GetScalarType<T[P], BarVisitGroupByOutputType[P]>
        }
      >
    >


  export type BarVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    source?: boolean
    verificationMethod?: boolean
    clickId?: boolean
    promoCodeId?: boolean
    metadata?: boolean
    visitedAt?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | BarVisit$userArgs<ExtArgs>
  }, ExtArgs["result"]["barVisit"]>

  export type BarVisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    source?: boolean
    verificationMethod?: boolean
    clickId?: boolean
    promoCodeId?: boolean
    metadata?: boolean
    visitedAt?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | BarVisit$userArgs<ExtArgs>
  }, ExtArgs["result"]["barVisit"]>

  export type BarVisitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    source?: boolean
    verificationMethod?: boolean
    clickId?: boolean
    promoCodeId?: boolean
    metadata?: boolean
    visitedAt?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | BarVisit$userArgs<ExtArgs>
  }, ExtArgs["result"]["barVisit"]>

  export type BarVisitSelectScalar = {
    id?: boolean
    barId?: boolean
    userId?: boolean
    source?: boolean
    verificationMethod?: boolean
    clickId?: boolean
    promoCodeId?: boolean
    metadata?: boolean
    visitedAt?: boolean
    createdAt?: boolean
  }

  export type BarVisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "userId" | "source" | "verificationMethod" | "clickId" | "promoCodeId" | "metadata" | "visitedAt" | "createdAt", ExtArgs["result"]["barVisit"]>
  export type BarVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | BarVisit$userArgs<ExtArgs>
  }
  export type BarVisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | BarVisit$userArgs<ExtArgs>
  }
  export type BarVisitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    user?: boolean | BarVisit$userArgs<ExtArgs>
  }

  export type $BarVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarVisit"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      userId: string | null
      source: string
      verificationMethod: string
      clickId: string | null
      promoCodeId: string | null
      metadata: Prisma.JsonValue | null
      visitedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["barVisit"]>
    composites: {}
  }

  type BarVisitGetPayload<S extends boolean | null | undefined | BarVisitDefaultArgs> = $Result.GetResult<Prisma.$BarVisitPayload, S>

  type BarVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarVisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarVisitCountAggregateInputType | true
    }

  export interface BarVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarVisit'], meta: { name: 'BarVisit' } }
    /**
     * Find zero or one BarVisit that matches the filter.
     * @param {BarVisitFindUniqueArgs} args - Arguments to find a BarVisit
     * @example
     * // Get one BarVisit
     * const barVisit = await prisma.barVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarVisitFindUniqueArgs>(args: SelectSubset<T, BarVisitFindUniqueArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarVisit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarVisitFindUniqueOrThrowArgs} args - Arguments to find a BarVisit
     * @example
     * // Get one BarVisit
     * const barVisit = await prisma.barVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, BarVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitFindFirstArgs} args - Arguments to find a BarVisit
     * @example
     * // Get one BarVisit
     * const barVisit = await prisma.barVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarVisitFindFirstArgs>(args?: SelectSubset<T, BarVisitFindFirstArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitFindFirstOrThrowArgs} args - Arguments to find a BarVisit
     * @example
     * // Get one BarVisit
     * const barVisit = await prisma.barVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, BarVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarVisits
     * const barVisits = await prisma.barVisit.findMany()
     * 
     * // Get first 10 BarVisits
     * const barVisits = await prisma.barVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barVisitWithIdOnly = await prisma.barVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarVisitFindManyArgs>(args?: SelectSubset<T, BarVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarVisit.
     * @param {BarVisitCreateArgs} args - Arguments to create a BarVisit.
     * @example
     * // Create one BarVisit
     * const BarVisit = await prisma.barVisit.create({
     *   data: {
     *     // ... data to create a BarVisit
     *   }
     * })
     * 
     */
    create<T extends BarVisitCreateArgs>(args: SelectSubset<T, BarVisitCreateArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarVisits.
     * @param {BarVisitCreateManyArgs} args - Arguments to create many BarVisits.
     * @example
     * // Create many BarVisits
     * const barVisit = await prisma.barVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarVisitCreateManyArgs>(args?: SelectSubset<T, BarVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarVisits and returns the data saved in the database.
     * @param {BarVisitCreateManyAndReturnArgs} args - Arguments to create many BarVisits.
     * @example
     * // Create many BarVisits
     * const barVisit = await prisma.barVisit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarVisits and only return the `id`
     * const barVisitWithIdOnly = await prisma.barVisit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarVisitCreateManyAndReturnArgs>(args?: SelectSubset<T, BarVisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarVisit.
     * @param {BarVisitDeleteArgs} args - Arguments to delete one BarVisit.
     * @example
     * // Delete one BarVisit
     * const BarVisit = await prisma.barVisit.delete({
     *   where: {
     *     // ... filter to delete one BarVisit
     *   }
     * })
     * 
     */
    delete<T extends BarVisitDeleteArgs>(args: SelectSubset<T, BarVisitDeleteArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarVisit.
     * @param {BarVisitUpdateArgs} args - Arguments to update one BarVisit.
     * @example
     * // Update one BarVisit
     * const barVisit = await prisma.barVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarVisitUpdateArgs>(args: SelectSubset<T, BarVisitUpdateArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarVisits.
     * @param {BarVisitDeleteManyArgs} args - Arguments to filter BarVisits to delete.
     * @example
     * // Delete a few BarVisits
     * const { count } = await prisma.barVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarVisitDeleteManyArgs>(args?: SelectSubset<T, BarVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarVisits
     * const barVisit = await prisma.barVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarVisitUpdateManyArgs>(args: SelectSubset<T, BarVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarVisits and returns the data updated in the database.
     * @param {BarVisitUpdateManyAndReturnArgs} args - Arguments to update many BarVisits.
     * @example
     * // Update many BarVisits
     * const barVisit = await prisma.barVisit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarVisits and only return the `id`
     * const barVisitWithIdOnly = await prisma.barVisit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarVisitUpdateManyAndReturnArgs>(args: SelectSubset<T, BarVisitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarVisit.
     * @param {BarVisitUpsertArgs} args - Arguments to update or create a BarVisit.
     * @example
     * // Update or create a BarVisit
     * const barVisit = await prisma.barVisit.upsert({
     *   create: {
     *     // ... data to create a BarVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarVisit we want to update
     *   }
     * })
     */
    upsert<T extends BarVisitUpsertArgs>(args: SelectSubset<T, BarVisitUpsertArgs<ExtArgs>>): Prisma__BarVisitClient<$Result.GetResult<Prisma.$BarVisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitCountArgs} args - Arguments to filter BarVisits to count.
     * @example
     * // Count the number of BarVisits
     * const count = await prisma.barVisit.count({
     *   where: {
     *     // ... the filter for the BarVisits we want to count
     *   }
     * })
    **/
    count<T extends BarVisitCountArgs>(
      args?: Subset<T, BarVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarVisitAggregateArgs>(args: Subset<T, BarVisitAggregateArgs>): Prisma.PrismaPromise<GetBarVisitAggregateType<T>>

    /**
     * Group by BarVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarVisitGroupByArgs['orderBy'] }
        : { orderBy?: BarVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarVisit model
   */
  readonly fields: BarVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends BarVisit$userArgs<ExtArgs> = {}>(args?: Subset<T, BarVisit$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarVisit model
   */
  interface BarVisitFieldRefs {
    readonly id: FieldRef<"BarVisit", 'String'>
    readonly barId: FieldRef<"BarVisit", 'String'>
    readonly userId: FieldRef<"BarVisit", 'String'>
    readonly source: FieldRef<"BarVisit", 'String'>
    readonly verificationMethod: FieldRef<"BarVisit", 'String'>
    readonly clickId: FieldRef<"BarVisit", 'String'>
    readonly promoCodeId: FieldRef<"BarVisit", 'String'>
    readonly metadata: FieldRef<"BarVisit", 'Json'>
    readonly visitedAt: FieldRef<"BarVisit", 'DateTime'>
    readonly createdAt: FieldRef<"BarVisit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarVisit findUnique
   */
  export type BarVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * Filter, which BarVisit to fetch.
     */
    where: BarVisitWhereUniqueInput
  }

  /**
   * BarVisit findUniqueOrThrow
   */
  export type BarVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * Filter, which BarVisit to fetch.
     */
    where: BarVisitWhereUniqueInput
  }

  /**
   * BarVisit findFirst
   */
  export type BarVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * Filter, which BarVisit to fetch.
     */
    where?: BarVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarVisits to fetch.
     */
    orderBy?: BarVisitOrderByWithRelationInput | BarVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarVisits.
     */
    cursor?: BarVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarVisits.
     */
    distinct?: BarVisitScalarFieldEnum | BarVisitScalarFieldEnum[]
  }

  /**
   * BarVisit findFirstOrThrow
   */
  export type BarVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * Filter, which BarVisit to fetch.
     */
    where?: BarVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarVisits to fetch.
     */
    orderBy?: BarVisitOrderByWithRelationInput | BarVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarVisits.
     */
    cursor?: BarVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarVisits.
     */
    distinct?: BarVisitScalarFieldEnum | BarVisitScalarFieldEnum[]
  }

  /**
   * BarVisit findMany
   */
  export type BarVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * Filter, which BarVisits to fetch.
     */
    where?: BarVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarVisits to fetch.
     */
    orderBy?: BarVisitOrderByWithRelationInput | BarVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarVisits.
     */
    cursor?: BarVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarVisits.
     */
    skip?: number
    distinct?: BarVisitScalarFieldEnum | BarVisitScalarFieldEnum[]
  }

  /**
   * BarVisit create
   */
  export type BarVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a BarVisit.
     */
    data: XOR<BarVisitCreateInput, BarVisitUncheckedCreateInput>
  }

  /**
   * BarVisit createMany
   */
  export type BarVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarVisits.
     */
    data: BarVisitCreateManyInput | BarVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarVisit createManyAndReturn
   */
  export type BarVisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * The data used to create many BarVisits.
     */
    data: BarVisitCreateManyInput | BarVisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarVisit update
   */
  export type BarVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a BarVisit.
     */
    data: XOR<BarVisitUpdateInput, BarVisitUncheckedUpdateInput>
    /**
     * Choose, which BarVisit to update.
     */
    where: BarVisitWhereUniqueInput
  }

  /**
   * BarVisit updateMany
   */
  export type BarVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarVisits.
     */
    data: XOR<BarVisitUpdateManyMutationInput, BarVisitUncheckedUpdateManyInput>
    /**
     * Filter which BarVisits to update
     */
    where?: BarVisitWhereInput
    /**
     * Limit how many BarVisits to update.
     */
    limit?: number
  }

  /**
   * BarVisit updateManyAndReturn
   */
  export type BarVisitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * The data used to update BarVisits.
     */
    data: XOR<BarVisitUpdateManyMutationInput, BarVisitUncheckedUpdateManyInput>
    /**
     * Filter which BarVisits to update
     */
    where?: BarVisitWhereInput
    /**
     * Limit how many BarVisits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarVisit upsert
   */
  export type BarVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the BarVisit to update in case it exists.
     */
    where: BarVisitWhereUniqueInput
    /**
     * In case the BarVisit found by the `where` argument doesn't exist, create a new BarVisit with this data.
     */
    create: XOR<BarVisitCreateInput, BarVisitUncheckedCreateInput>
    /**
     * In case the BarVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarVisitUpdateInput, BarVisitUncheckedUpdateInput>
  }

  /**
   * BarVisit delete
   */
  export type BarVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
    /**
     * Filter which BarVisit to delete.
     */
    where: BarVisitWhereUniqueInput
  }

  /**
   * BarVisit deleteMany
   */
  export type BarVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarVisits to delete
     */
    where?: BarVisitWhereInput
    /**
     * Limit how many BarVisits to delete.
     */
    limit?: number
  }

  /**
   * BarVisit.user
   */
  export type BarVisit$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BarVisit without action
   */
  export type BarVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarVisit
     */
    select?: BarVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarVisit
     */
    omit?: BarVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarVisitInclude<ExtArgs> | null
  }


  /**
   * Model BarMembership
   */

  export type AggregateBarMembership = {
    _count: BarMembershipCountAggregateOutputType | null
    _min: BarMembershipMinAggregateOutputType | null
    _max: BarMembershipMaxAggregateOutputType | null
  }

  export type BarMembershipMinAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    role: $Enums.BarMemberRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarMembershipMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    userId: string | null
    role: $Enums.BarMemberRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarMembershipCountAggregateOutputType = {
    id: number
    barId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BarMembershipMinAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarMembershipMaxAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarMembershipCountAggregateInputType = {
    id?: true
    barId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BarMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarMembership to aggregate.
     */
    where?: BarMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarMemberships to fetch.
     */
    orderBy?: BarMembershipOrderByWithRelationInput | BarMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarMemberships
    **/
    _count?: true | BarMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarMembershipMaxAggregateInputType
  }

  export type GetBarMembershipAggregateType<T extends BarMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateBarMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarMembership[P]>
      : GetScalarType<T[P], AggregateBarMembership[P]>
  }




  export type BarMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarMembershipWhereInput
    orderBy?: BarMembershipOrderByWithAggregationInput | BarMembershipOrderByWithAggregationInput[]
    by: BarMembershipScalarFieldEnum[] | BarMembershipScalarFieldEnum
    having?: BarMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarMembershipCountAggregateInputType | true
    _min?: BarMembershipMinAggregateInputType
    _max?: BarMembershipMaxAggregateInputType
  }

  export type BarMembershipGroupByOutputType = {
    id: string
    barId: string
    userId: string
    role: $Enums.BarMemberRole
    createdAt: Date
    updatedAt: Date
    _count: BarMembershipCountAggregateOutputType | null
    _min: BarMembershipMinAggregateOutputType | null
    _max: BarMembershipMaxAggregateOutputType | null
  }

  type GetBarMembershipGroupByPayload<T extends BarMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], BarMembershipGroupByOutputType[P]>
        }
      >
    >


  export type BarMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barMembership"]>

  export type BarMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barMembership"]>

  export type BarMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barMembership"]>

  export type BarMembershipSelectScalar = {
    id?: boolean
    barId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BarMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["barMembership"]>
  export type BarMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $BarMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarMembership"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      userId: string
      role: $Enums.BarMemberRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["barMembership"]>
    composites: {}
  }

  type BarMembershipGetPayload<S extends boolean | null | undefined | BarMembershipDefaultArgs> = $Result.GetResult<Prisma.$BarMembershipPayload, S>

  type BarMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarMembershipCountAggregateInputType | true
    }

  export interface BarMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarMembership'], meta: { name: 'BarMembership' } }
    /**
     * Find zero or one BarMembership that matches the filter.
     * @param {BarMembershipFindUniqueArgs} args - Arguments to find a BarMembership
     * @example
     * // Get one BarMembership
     * const barMembership = await prisma.barMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarMembershipFindUniqueArgs>(args: SelectSubset<T, BarMembershipFindUniqueArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarMembershipFindUniqueOrThrowArgs} args - Arguments to find a BarMembership
     * @example
     * // Get one BarMembership
     * const barMembership = await prisma.barMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, BarMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipFindFirstArgs} args - Arguments to find a BarMembership
     * @example
     * // Get one BarMembership
     * const barMembership = await prisma.barMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarMembershipFindFirstArgs>(args?: SelectSubset<T, BarMembershipFindFirstArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipFindFirstOrThrowArgs} args - Arguments to find a BarMembership
     * @example
     * // Get one BarMembership
     * const barMembership = await prisma.barMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, BarMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarMemberships
     * const barMemberships = await prisma.barMembership.findMany()
     * 
     * // Get first 10 BarMemberships
     * const barMemberships = await prisma.barMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barMembershipWithIdOnly = await prisma.barMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarMembershipFindManyArgs>(args?: SelectSubset<T, BarMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarMembership.
     * @param {BarMembershipCreateArgs} args - Arguments to create a BarMembership.
     * @example
     * // Create one BarMembership
     * const BarMembership = await prisma.barMembership.create({
     *   data: {
     *     // ... data to create a BarMembership
     *   }
     * })
     * 
     */
    create<T extends BarMembershipCreateArgs>(args: SelectSubset<T, BarMembershipCreateArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarMemberships.
     * @param {BarMembershipCreateManyArgs} args - Arguments to create many BarMemberships.
     * @example
     * // Create many BarMemberships
     * const barMembership = await prisma.barMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarMembershipCreateManyArgs>(args?: SelectSubset<T, BarMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarMemberships and returns the data saved in the database.
     * @param {BarMembershipCreateManyAndReturnArgs} args - Arguments to create many BarMemberships.
     * @example
     * // Create many BarMemberships
     * const barMembership = await prisma.barMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarMemberships and only return the `id`
     * const barMembershipWithIdOnly = await prisma.barMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, BarMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarMembership.
     * @param {BarMembershipDeleteArgs} args - Arguments to delete one BarMembership.
     * @example
     * // Delete one BarMembership
     * const BarMembership = await prisma.barMembership.delete({
     *   where: {
     *     // ... filter to delete one BarMembership
     *   }
     * })
     * 
     */
    delete<T extends BarMembershipDeleteArgs>(args: SelectSubset<T, BarMembershipDeleteArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarMembership.
     * @param {BarMembershipUpdateArgs} args - Arguments to update one BarMembership.
     * @example
     * // Update one BarMembership
     * const barMembership = await prisma.barMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarMembershipUpdateArgs>(args: SelectSubset<T, BarMembershipUpdateArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarMemberships.
     * @param {BarMembershipDeleteManyArgs} args - Arguments to filter BarMemberships to delete.
     * @example
     * // Delete a few BarMemberships
     * const { count } = await prisma.barMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarMembershipDeleteManyArgs>(args?: SelectSubset<T, BarMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarMemberships
     * const barMembership = await prisma.barMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarMembershipUpdateManyArgs>(args: SelectSubset<T, BarMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarMemberships and returns the data updated in the database.
     * @param {BarMembershipUpdateManyAndReturnArgs} args - Arguments to update many BarMemberships.
     * @example
     * // Update many BarMemberships
     * const barMembership = await prisma.barMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarMemberships and only return the `id`
     * const barMembershipWithIdOnly = await prisma.barMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, BarMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarMembership.
     * @param {BarMembershipUpsertArgs} args - Arguments to update or create a BarMembership.
     * @example
     * // Update or create a BarMembership
     * const barMembership = await prisma.barMembership.upsert({
     *   create: {
     *     // ... data to create a BarMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarMembership we want to update
     *   }
     * })
     */
    upsert<T extends BarMembershipUpsertArgs>(args: SelectSubset<T, BarMembershipUpsertArgs<ExtArgs>>): Prisma__BarMembershipClient<$Result.GetResult<Prisma.$BarMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipCountArgs} args - Arguments to filter BarMemberships to count.
     * @example
     * // Count the number of BarMemberships
     * const count = await prisma.barMembership.count({
     *   where: {
     *     // ... the filter for the BarMemberships we want to count
     *   }
     * })
    **/
    count<T extends BarMembershipCountArgs>(
      args?: Subset<T, BarMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarMembershipAggregateArgs>(args: Subset<T, BarMembershipAggregateArgs>): Prisma.PrismaPromise<GetBarMembershipAggregateType<T>>

    /**
     * Group by BarMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarMembershipGroupByArgs['orderBy'] }
        : { orderBy?: BarMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarMembership model
   */
  readonly fields: BarMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarMembership model
   */
  interface BarMembershipFieldRefs {
    readonly id: FieldRef<"BarMembership", 'String'>
    readonly barId: FieldRef<"BarMembership", 'String'>
    readonly userId: FieldRef<"BarMembership", 'String'>
    readonly role: FieldRef<"BarMembership", 'BarMemberRole'>
    readonly createdAt: FieldRef<"BarMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"BarMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarMembership findUnique
   */
  export type BarMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * Filter, which BarMembership to fetch.
     */
    where: BarMembershipWhereUniqueInput
  }

  /**
   * BarMembership findUniqueOrThrow
   */
  export type BarMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * Filter, which BarMembership to fetch.
     */
    where: BarMembershipWhereUniqueInput
  }

  /**
   * BarMembership findFirst
   */
  export type BarMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * Filter, which BarMembership to fetch.
     */
    where?: BarMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarMemberships to fetch.
     */
    orderBy?: BarMembershipOrderByWithRelationInput | BarMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarMemberships.
     */
    cursor?: BarMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarMemberships.
     */
    distinct?: BarMembershipScalarFieldEnum | BarMembershipScalarFieldEnum[]
  }

  /**
   * BarMembership findFirstOrThrow
   */
  export type BarMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * Filter, which BarMembership to fetch.
     */
    where?: BarMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarMemberships to fetch.
     */
    orderBy?: BarMembershipOrderByWithRelationInput | BarMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarMemberships.
     */
    cursor?: BarMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarMemberships.
     */
    distinct?: BarMembershipScalarFieldEnum | BarMembershipScalarFieldEnum[]
  }

  /**
   * BarMembership findMany
   */
  export type BarMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * Filter, which BarMemberships to fetch.
     */
    where?: BarMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarMemberships to fetch.
     */
    orderBy?: BarMembershipOrderByWithRelationInput | BarMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarMemberships.
     */
    cursor?: BarMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarMemberships.
     */
    skip?: number
    distinct?: BarMembershipScalarFieldEnum | BarMembershipScalarFieldEnum[]
  }

  /**
   * BarMembership create
   */
  export type BarMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a BarMembership.
     */
    data: XOR<BarMembershipCreateInput, BarMembershipUncheckedCreateInput>
  }

  /**
   * BarMembership createMany
   */
  export type BarMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarMemberships.
     */
    data: BarMembershipCreateManyInput | BarMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarMembership createManyAndReturn
   */
  export type BarMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many BarMemberships.
     */
    data: BarMembershipCreateManyInput | BarMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarMembership update
   */
  export type BarMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a BarMembership.
     */
    data: XOR<BarMembershipUpdateInput, BarMembershipUncheckedUpdateInput>
    /**
     * Choose, which BarMembership to update.
     */
    where: BarMembershipWhereUniqueInput
  }

  /**
   * BarMembership updateMany
   */
  export type BarMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarMemberships.
     */
    data: XOR<BarMembershipUpdateManyMutationInput, BarMembershipUncheckedUpdateManyInput>
    /**
     * Filter which BarMemberships to update
     */
    where?: BarMembershipWhereInput
    /**
     * Limit how many BarMemberships to update.
     */
    limit?: number
  }

  /**
   * BarMembership updateManyAndReturn
   */
  export type BarMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * The data used to update BarMemberships.
     */
    data: XOR<BarMembershipUpdateManyMutationInput, BarMembershipUncheckedUpdateManyInput>
    /**
     * Filter which BarMemberships to update
     */
    where?: BarMembershipWhereInput
    /**
     * Limit how many BarMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarMembership upsert
   */
  export type BarMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the BarMembership to update in case it exists.
     */
    where: BarMembershipWhereUniqueInput
    /**
     * In case the BarMembership found by the `where` argument doesn't exist, create a new BarMembership with this data.
     */
    create: XOR<BarMembershipCreateInput, BarMembershipUncheckedCreateInput>
    /**
     * In case the BarMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarMembershipUpdateInput, BarMembershipUncheckedUpdateInput>
  }

  /**
   * BarMembership delete
   */
  export type BarMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
    /**
     * Filter which BarMembership to delete.
     */
    where: BarMembershipWhereUniqueInput
  }

  /**
   * BarMembership deleteMany
   */
  export type BarMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarMemberships to delete
     */
    where?: BarMembershipWhereInput
    /**
     * Limit how many BarMemberships to delete.
     */
    limit?: number
  }

  /**
   * BarMembership without action
   */
  export type BarMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarMembership
     */
    select?: BarMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarMembership
     */
    omit?: BarMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarMembershipInclude<ExtArgs> | null
  }


  /**
   * Model PatronSearchEvent
   */

  export type AggregatePatronSearchEvent = {
    _count: PatronSearchEventCountAggregateOutputType | null
    _min: PatronSearchEventMinAggregateOutputType | null
    _max: PatronSearchEventMaxAggregateOutputType | null
  }

  export type PatronSearchEventMinAggregateOutputType = {
    id: string | null
    barId: string | null
    query: string | null
    category: string | null
    city: string | null
    createdAt: Date | null
  }

  export type PatronSearchEventMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    query: string | null
    category: string | null
    city: string | null
    createdAt: Date | null
  }

  export type PatronSearchEventCountAggregateOutputType = {
    id: number
    barId: number
    query: number
    category: number
    city: number
    createdAt: number
    _all: number
  }


  export type PatronSearchEventMinAggregateInputType = {
    id?: true
    barId?: true
    query?: true
    category?: true
    city?: true
    createdAt?: true
  }

  export type PatronSearchEventMaxAggregateInputType = {
    id?: true
    barId?: true
    query?: true
    category?: true
    city?: true
    createdAt?: true
  }

  export type PatronSearchEventCountAggregateInputType = {
    id?: true
    barId?: true
    query?: true
    category?: true
    city?: true
    createdAt?: true
    _all?: true
  }

  export type PatronSearchEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatronSearchEvent to aggregate.
     */
    where?: PatronSearchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatronSearchEvents to fetch.
     */
    orderBy?: PatronSearchEventOrderByWithRelationInput | PatronSearchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatronSearchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatronSearchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatronSearchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatronSearchEvents
    **/
    _count?: true | PatronSearchEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatronSearchEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatronSearchEventMaxAggregateInputType
  }

  export type GetPatronSearchEventAggregateType<T extends PatronSearchEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePatronSearchEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatronSearchEvent[P]>
      : GetScalarType<T[P], AggregatePatronSearchEvent[P]>
  }




  export type PatronSearchEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatronSearchEventWhereInput
    orderBy?: PatronSearchEventOrderByWithAggregationInput | PatronSearchEventOrderByWithAggregationInput[]
    by: PatronSearchEventScalarFieldEnum[] | PatronSearchEventScalarFieldEnum
    having?: PatronSearchEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatronSearchEventCountAggregateInputType | true
    _min?: PatronSearchEventMinAggregateInputType
    _max?: PatronSearchEventMaxAggregateInputType
  }

  export type PatronSearchEventGroupByOutputType = {
    id: string
    barId: string | null
    query: string | null
    category: string | null
    city: string | null
    createdAt: Date
    _count: PatronSearchEventCountAggregateOutputType | null
    _min: PatronSearchEventMinAggregateOutputType | null
    _max: PatronSearchEventMaxAggregateOutputType | null
  }

  type GetPatronSearchEventGroupByPayload<T extends PatronSearchEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatronSearchEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatronSearchEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatronSearchEventGroupByOutputType[P]>
            : GetScalarType<T[P], PatronSearchEventGroupByOutputType[P]>
        }
      >
    >


  export type PatronSearchEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    query?: boolean
    category?: boolean
    city?: boolean
    createdAt?: boolean
    bar?: boolean | PatronSearchEvent$barArgs<ExtArgs>
  }, ExtArgs["result"]["patronSearchEvent"]>

  export type PatronSearchEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    query?: boolean
    category?: boolean
    city?: boolean
    createdAt?: boolean
    bar?: boolean | PatronSearchEvent$barArgs<ExtArgs>
  }, ExtArgs["result"]["patronSearchEvent"]>

  export type PatronSearchEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    query?: boolean
    category?: boolean
    city?: boolean
    createdAt?: boolean
    bar?: boolean | PatronSearchEvent$barArgs<ExtArgs>
  }, ExtArgs["result"]["patronSearchEvent"]>

  export type PatronSearchEventSelectScalar = {
    id?: boolean
    barId?: boolean
    query?: boolean
    category?: boolean
    city?: boolean
    createdAt?: boolean
  }

  export type PatronSearchEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "query" | "category" | "city" | "createdAt", ExtArgs["result"]["patronSearchEvent"]>
  export type PatronSearchEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | PatronSearchEvent$barArgs<ExtArgs>
  }
  export type PatronSearchEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | PatronSearchEvent$barArgs<ExtArgs>
  }
  export type PatronSearchEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | PatronSearchEvent$barArgs<ExtArgs>
  }

  export type $PatronSearchEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatronSearchEvent"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string | null
      query: string | null
      category: string | null
      city: string | null
      createdAt: Date
    }, ExtArgs["result"]["patronSearchEvent"]>
    composites: {}
  }

  type PatronSearchEventGetPayload<S extends boolean | null | undefined | PatronSearchEventDefaultArgs> = $Result.GetResult<Prisma.$PatronSearchEventPayload, S>

  type PatronSearchEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatronSearchEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatronSearchEventCountAggregateInputType | true
    }

  export interface PatronSearchEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatronSearchEvent'], meta: { name: 'PatronSearchEvent' } }
    /**
     * Find zero or one PatronSearchEvent that matches the filter.
     * @param {PatronSearchEventFindUniqueArgs} args - Arguments to find a PatronSearchEvent
     * @example
     * // Get one PatronSearchEvent
     * const patronSearchEvent = await prisma.patronSearchEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatronSearchEventFindUniqueArgs>(args: SelectSubset<T, PatronSearchEventFindUniqueArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatronSearchEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatronSearchEventFindUniqueOrThrowArgs} args - Arguments to find a PatronSearchEvent
     * @example
     * // Get one PatronSearchEvent
     * const patronSearchEvent = await prisma.patronSearchEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatronSearchEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PatronSearchEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatronSearchEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventFindFirstArgs} args - Arguments to find a PatronSearchEvent
     * @example
     * // Get one PatronSearchEvent
     * const patronSearchEvent = await prisma.patronSearchEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatronSearchEventFindFirstArgs>(args?: SelectSubset<T, PatronSearchEventFindFirstArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatronSearchEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventFindFirstOrThrowArgs} args - Arguments to find a PatronSearchEvent
     * @example
     * // Get one PatronSearchEvent
     * const patronSearchEvent = await prisma.patronSearchEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatronSearchEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PatronSearchEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatronSearchEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatronSearchEvents
     * const patronSearchEvents = await prisma.patronSearchEvent.findMany()
     * 
     * // Get first 10 PatronSearchEvents
     * const patronSearchEvents = await prisma.patronSearchEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patronSearchEventWithIdOnly = await prisma.patronSearchEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatronSearchEventFindManyArgs>(args?: SelectSubset<T, PatronSearchEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatronSearchEvent.
     * @param {PatronSearchEventCreateArgs} args - Arguments to create a PatronSearchEvent.
     * @example
     * // Create one PatronSearchEvent
     * const PatronSearchEvent = await prisma.patronSearchEvent.create({
     *   data: {
     *     // ... data to create a PatronSearchEvent
     *   }
     * })
     * 
     */
    create<T extends PatronSearchEventCreateArgs>(args: SelectSubset<T, PatronSearchEventCreateArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatronSearchEvents.
     * @param {PatronSearchEventCreateManyArgs} args - Arguments to create many PatronSearchEvents.
     * @example
     * // Create many PatronSearchEvents
     * const patronSearchEvent = await prisma.patronSearchEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatronSearchEventCreateManyArgs>(args?: SelectSubset<T, PatronSearchEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatronSearchEvents and returns the data saved in the database.
     * @param {PatronSearchEventCreateManyAndReturnArgs} args - Arguments to create many PatronSearchEvents.
     * @example
     * // Create many PatronSearchEvents
     * const patronSearchEvent = await prisma.patronSearchEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatronSearchEvents and only return the `id`
     * const patronSearchEventWithIdOnly = await prisma.patronSearchEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatronSearchEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PatronSearchEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatronSearchEvent.
     * @param {PatronSearchEventDeleteArgs} args - Arguments to delete one PatronSearchEvent.
     * @example
     * // Delete one PatronSearchEvent
     * const PatronSearchEvent = await prisma.patronSearchEvent.delete({
     *   where: {
     *     // ... filter to delete one PatronSearchEvent
     *   }
     * })
     * 
     */
    delete<T extends PatronSearchEventDeleteArgs>(args: SelectSubset<T, PatronSearchEventDeleteArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatronSearchEvent.
     * @param {PatronSearchEventUpdateArgs} args - Arguments to update one PatronSearchEvent.
     * @example
     * // Update one PatronSearchEvent
     * const patronSearchEvent = await prisma.patronSearchEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatronSearchEventUpdateArgs>(args: SelectSubset<T, PatronSearchEventUpdateArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatronSearchEvents.
     * @param {PatronSearchEventDeleteManyArgs} args - Arguments to filter PatronSearchEvents to delete.
     * @example
     * // Delete a few PatronSearchEvents
     * const { count } = await prisma.patronSearchEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatronSearchEventDeleteManyArgs>(args?: SelectSubset<T, PatronSearchEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatronSearchEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatronSearchEvents
     * const patronSearchEvent = await prisma.patronSearchEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatronSearchEventUpdateManyArgs>(args: SelectSubset<T, PatronSearchEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatronSearchEvents and returns the data updated in the database.
     * @param {PatronSearchEventUpdateManyAndReturnArgs} args - Arguments to update many PatronSearchEvents.
     * @example
     * // Update many PatronSearchEvents
     * const patronSearchEvent = await prisma.patronSearchEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatronSearchEvents and only return the `id`
     * const patronSearchEventWithIdOnly = await prisma.patronSearchEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatronSearchEventUpdateManyAndReturnArgs>(args: SelectSubset<T, PatronSearchEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatronSearchEvent.
     * @param {PatronSearchEventUpsertArgs} args - Arguments to update or create a PatronSearchEvent.
     * @example
     * // Update or create a PatronSearchEvent
     * const patronSearchEvent = await prisma.patronSearchEvent.upsert({
     *   create: {
     *     // ... data to create a PatronSearchEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatronSearchEvent we want to update
     *   }
     * })
     */
    upsert<T extends PatronSearchEventUpsertArgs>(args: SelectSubset<T, PatronSearchEventUpsertArgs<ExtArgs>>): Prisma__PatronSearchEventClient<$Result.GetResult<Prisma.$PatronSearchEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatronSearchEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventCountArgs} args - Arguments to filter PatronSearchEvents to count.
     * @example
     * // Count the number of PatronSearchEvents
     * const count = await prisma.patronSearchEvent.count({
     *   where: {
     *     // ... the filter for the PatronSearchEvents we want to count
     *   }
     * })
    **/
    count<T extends PatronSearchEventCountArgs>(
      args?: Subset<T, PatronSearchEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatronSearchEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatronSearchEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatronSearchEventAggregateArgs>(args: Subset<T, PatronSearchEventAggregateArgs>): Prisma.PrismaPromise<GetPatronSearchEventAggregateType<T>>

    /**
     * Group by PatronSearchEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronSearchEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatronSearchEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatronSearchEventGroupByArgs['orderBy'] }
        : { orderBy?: PatronSearchEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatronSearchEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatronSearchEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatronSearchEvent model
   */
  readonly fields: PatronSearchEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatronSearchEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatronSearchEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends PatronSearchEvent$barArgs<ExtArgs> = {}>(args?: Subset<T, PatronSearchEvent$barArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatronSearchEvent model
   */
  interface PatronSearchEventFieldRefs {
    readonly id: FieldRef<"PatronSearchEvent", 'String'>
    readonly barId: FieldRef<"PatronSearchEvent", 'String'>
    readonly query: FieldRef<"PatronSearchEvent", 'String'>
    readonly category: FieldRef<"PatronSearchEvent", 'String'>
    readonly city: FieldRef<"PatronSearchEvent", 'String'>
    readonly createdAt: FieldRef<"PatronSearchEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatronSearchEvent findUnique
   */
  export type PatronSearchEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * Filter, which PatronSearchEvent to fetch.
     */
    where: PatronSearchEventWhereUniqueInput
  }

  /**
   * PatronSearchEvent findUniqueOrThrow
   */
  export type PatronSearchEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * Filter, which PatronSearchEvent to fetch.
     */
    where: PatronSearchEventWhereUniqueInput
  }

  /**
   * PatronSearchEvent findFirst
   */
  export type PatronSearchEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * Filter, which PatronSearchEvent to fetch.
     */
    where?: PatronSearchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatronSearchEvents to fetch.
     */
    orderBy?: PatronSearchEventOrderByWithRelationInput | PatronSearchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatronSearchEvents.
     */
    cursor?: PatronSearchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatronSearchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatronSearchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatronSearchEvents.
     */
    distinct?: PatronSearchEventScalarFieldEnum | PatronSearchEventScalarFieldEnum[]
  }

  /**
   * PatronSearchEvent findFirstOrThrow
   */
  export type PatronSearchEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * Filter, which PatronSearchEvent to fetch.
     */
    where?: PatronSearchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatronSearchEvents to fetch.
     */
    orderBy?: PatronSearchEventOrderByWithRelationInput | PatronSearchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatronSearchEvents.
     */
    cursor?: PatronSearchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatronSearchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatronSearchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatronSearchEvents.
     */
    distinct?: PatronSearchEventScalarFieldEnum | PatronSearchEventScalarFieldEnum[]
  }

  /**
   * PatronSearchEvent findMany
   */
  export type PatronSearchEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * Filter, which PatronSearchEvents to fetch.
     */
    where?: PatronSearchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatronSearchEvents to fetch.
     */
    orderBy?: PatronSearchEventOrderByWithRelationInput | PatronSearchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatronSearchEvents.
     */
    cursor?: PatronSearchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatronSearchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatronSearchEvents.
     */
    skip?: number
    distinct?: PatronSearchEventScalarFieldEnum | PatronSearchEventScalarFieldEnum[]
  }

  /**
   * PatronSearchEvent create
   */
  export type PatronSearchEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PatronSearchEvent.
     */
    data?: XOR<PatronSearchEventCreateInput, PatronSearchEventUncheckedCreateInput>
  }

  /**
   * PatronSearchEvent createMany
   */
  export type PatronSearchEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatronSearchEvents.
     */
    data: PatronSearchEventCreateManyInput | PatronSearchEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatronSearchEvent createManyAndReturn
   */
  export type PatronSearchEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * The data used to create many PatronSearchEvents.
     */
    data: PatronSearchEventCreateManyInput | PatronSearchEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatronSearchEvent update
   */
  export type PatronSearchEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PatronSearchEvent.
     */
    data: XOR<PatronSearchEventUpdateInput, PatronSearchEventUncheckedUpdateInput>
    /**
     * Choose, which PatronSearchEvent to update.
     */
    where: PatronSearchEventWhereUniqueInput
  }

  /**
   * PatronSearchEvent updateMany
   */
  export type PatronSearchEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatronSearchEvents.
     */
    data: XOR<PatronSearchEventUpdateManyMutationInput, PatronSearchEventUncheckedUpdateManyInput>
    /**
     * Filter which PatronSearchEvents to update
     */
    where?: PatronSearchEventWhereInput
    /**
     * Limit how many PatronSearchEvents to update.
     */
    limit?: number
  }

  /**
   * PatronSearchEvent updateManyAndReturn
   */
  export type PatronSearchEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * The data used to update PatronSearchEvents.
     */
    data: XOR<PatronSearchEventUpdateManyMutationInput, PatronSearchEventUncheckedUpdateManyInput>
    /**
     * Filter which PatronSearchEvents to update
     */
    where?: PatronSearchEventWhereInput
    /**
     * Limit how many PatronSearchEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatronSearchEvent upsert
   */
  export type PatronSearchEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PatronSearchEvent to update in case it exists.
     */
    where: PatronSearchEventWhereUniqueInput
    /**
     * In case the PatronSearchEvent found by the `where` argument doesn't exist, create a new PatronSearchEvent with this data.
     */
    create: XOR<PatronSearchEventCreateInput, PatronSearchEventUncheckedCreateInput>
    /**
     * In case the PatronSearchEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatronSearchEventUpdateInput, PatronSearchEventUncheckedUpdateInput>
  }

  /**
   * PatronSearchEvent delete
   */
  export type PatronSearchEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
    /**
     * Filter which PatronSearchEvent to delete.
     */
    where: PatronSearchEventWhereUniqueInput
  }

  /**
   * PatronSearchEvent deleteMany
   */
  export type PatronSearchEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatronSearchEvents to delete
     */
    where?: PatronSearchEventWhereInput
    /**
     * Limit how many PatronSearchEvents to delete.
     */
    limit?: number
  }

  /**
   * PatronSearchEvent.bar
   */
  export type PatronSearchEvent$barArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    where?: BarWhereInput
  }

  /**
   * PatronSearchEvent without action
   */
  export type PatronSearchEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatronSearchEvent
     */
    select?: PatronSearchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatronSearchEvent
     */
    omit?: PatronSearchEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatronSearchEventInclude<ExtArgs> | null
  }


  /**
   * Model BarAction
   */

  export type AggregateBarAction = {
    _count: BarActionCountAggregateOutputType | null
    _min: BarActionMinAggregateOutputType | null
    _max: BarActionMaxAggregateOutputType | null
  }

  export type BarActionMinAggregateOutputType = {
    id: string | null
    barId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type BarActionMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type BarActionCountAggregateOutputType = {
    id: number
    barId: number
    action: number
    createdAt: number
    _all: number
  }


  export type BarActionMinAggregateInputType = {
    id?: true
    barId?: true
    action?: true
    createdAt?: true
  }

  export type BarActionMaxAggregateInputType = {
    id?: true
    barId?: true
    action?: true
    createdAt?: true
  }

  export type BarActionCountAggregateInputType = {
    id?: true
    barId?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type BarActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarAction to aggregate.
     */
    where?: BarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarActions to fetch.
     */
    orderBy?: BarActionOrderByWithRelationInput | BarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarActions
    **/
    _count?: true | BarActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarActionMaxAggregateInputType
  }

  export type GetBarActionAggregateType<T extends BarActionAggregateArgs> = {
        [P in keyof T & keyof AggregateBarAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarAction[P]>
      : GetScalarType<T[P], AggregateBarAction[P]>
  }




  export type BarActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarActionWhereInput
    orderBy?: BarActionOrderByWithAggregationInput | BarActionOrderByWithAggregationInput[]
    by: BarActionScalarFieldEnum[] | BarActionScalarFieldEnum
    having?: BarActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarActionCountAggregateInputType | true
    _min?: BarActionMinAggregateInputType
    _max?: BarActionMaxAggregateInputType
  }

  export type BarActionGroupByOutputType = {
    id: string
    barId: string
    action: string
    createdAt: Date
    _count: BarActionCountAggregateOutputType | null
    _min: BarActionMinAggregateOutputType | null
    _max: BarActionMaxAggregateOutputType | null
  }

  type GetBarActionGroupByPayload<T extends BarActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarActionGroupByOutputType[P]>
            : GetScalarType<T[P], BarActionGroupByOutputType[P]>
        }
      >
    >


  export type BarActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    action?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barAction"]>

  export type BarActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    action?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barAction"]>

  export type BarActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    action?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barAction"]>

  export type BarActionSelectScalar = {
    id?: boolean
    barId?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type BarActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "action" | "createdAt", ExtArgs["result"]["barAction"]>
  export type BarActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $BarActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarAction"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      action: string
      createdAt: Date
    }, ExtArgs["result"]["barAction"]>
    composites: {}
  }

  type BarActionGetPayload<S extends boolean | null | undefined | BarActionDefaultArgs> = $Result.GetResult<Prisma.$BarActionPayload, S>

  type BarActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarActionCountAggregateInputType | true
    }

  export interface BarActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarAction'], meta: { name: 'BarAction' } }
    /**
     * Find zero or one BarAction that matches the filter.
     * @param {BarActionFindUniqueArgs} args - Arguments to find a BarAction
     * @example
     * // Get one BarAction
     * const barAction = await prisma.barAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarActionFindUniqueArgs>(args: SelectSubset<T, BarActionFindUniqueArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarActionFindUniqueOrThrowArgs} args - Arguments to find a BarAction
     * @example
     * // Get one BarAction
     * const barAction = await prisma.barAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarActionFindUniqueOrThrowArgs>(args: SelectSubset<T, BarActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionFindFirstArgs} args - Arguments to find a BarAction
     * @example
     * // Get one BarAction
     * const barAction = await prisma.barAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarActionFindFirstArgs>(args?: SelectSubset<T, BarActionFindFirstArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionFindFirstOrThrowArgs} args - Arguments to find a BarAction
     * @example
     * // Get one BarAction
     * const barAction = await prisma.barAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarActionFindFirstOrThrowArgs>(args?: SelectSubset<T, BarActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarActions
     * const barActions = await prisma.barAction.findMany()
     * 
     * // Get first 10 BarActions
     * const barActions = await prisma.barAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barActionWithIdOnly = await prisma.barAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarActionFindManyArgs>(args?: SelectSubset<T, BarActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarAction.
     * @param {BarActionCreateArgs} args - Arguments to create a BarAction.
     * @example
     * // Create one BarAction
     * const BarAction = await prisma.barAction.create({
     *   data: {
     *     // ... data to create a BarAction
     *   }
     * })
     * 
     */
    create<T extends BarActionCreateArgs>(args: SelectSubset<T, BarActionCreateArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarActions.
     * @param {BarActionCreateManyArgs} args - Arguments to create many BarActions.
     * @example
     * // Create many BarActions
     * const barAction = await prisma.barAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarActionCreateManyArgs>(args?: SelectSubset<T, BarActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarActions and returns the data saved in the database.
     * @param {BarActionCreateManyAndReturnArgs} args - Arguments to create many BarActions.
     * @example
     * // Create many BarActions
     * const barAction = await prisma.barAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarActions and only return the `id`
     * const barActionWithIdOnly = await prisma.barAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarActionCreateManyAndReturnArgs>(args?: SelectSubset<T, BarActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarAction.
     * @param {BarActionDeleteArgs} args - Arguments to delete one BarAction.
     * @example
     * // Delete one BarAction
     * const BarAction = await prisma.barAction.delete({
     *   where: {
     *     // ... filter to delete one BarAction
     *   }
     * })
     * 
     */
    delete<T extends BarActionDeleteArgs>(args: SelectSubset<T, BarActionDeleteArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarAction.
     * @param {BarActionUpdateArgs} args - Arguments to update one BarAction.
     * @example
     * // Update one BarAction
     * const barAction = await prisma.barAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarActionUpdateArgs>(args: SelectSubset<T, BarActionUpdateArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarActions.
     * @param {BarActionDeleteManyArgs} args - Arguments to filter BarActions to delete.
     * @example
     * // Delete a few BarActions
     * const { count } = await prisma.barAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarActionDeleteManyArgs>(args?: SelectSubset<T, BarActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarActions
     * const barAction = await prisma.barAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarActionUpdateManyArgs>(args: SelectSubset<T, BarActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarActions and returns the data updated in the database.
     * @param {BarActionUpdateManyAndReturnArgs} args - Arguments to update many BarActions.
     * @example
     * // Update many BarActions
     * const barAction = await prisma.barAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarActions and only return the `id`
     * const barActionWithIdOnly = await prisma.barAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarActionUpdateManyAndReturnArgs>(args: SelectSubset<T, BarActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarAction.
     * @param {BarActionUpsertArgs} args - Arguments to update or create a BarAction.
     * @example
     * // Update or create a BarAction
     * const barAction = await prisma.barAction.upsert({
     *   create: {
     *     // ... data to create a BarAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarAction we want to update
     *   }
     * })
     */
    upsert<T extends BarActionUpsertArgs>(args: SelectSubset<T, BarActionUpsertArgs<ExtArgs>>): Prisma__BarActionClient<$Result.GetResult<Prisma.$BarActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionCountArgs} args - Arguments to filter BarActions to count.
     * @example
     * // Count the number of BarActions
     * const count = await prisma.barAction.count({
     *   where: {
     *     // ... the filter for the BarActions we want to count
     *   }
     * })
    **/
    count<T extends BarActionCountArgs>(
      args?: Subset<T, BarActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarActionAggregateArgs>(args: Subset<T, BarActionAggregateArgs>): Prisma.PrismaPromise<GetBarActionAggregateType<T>>

    /**
     * Group by BarAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarActionGroupByArgs['orderBy'] }
        : { orderBy?: BarActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarAction model
   */
  readonly fields: BarActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarAction model
   */
  interface BarActionFieldRefs {
    readonly id: FieldRef<"BarAction", 'String'>
    readonly barId: FieldRef<"BarAction", 'String'>
    readonly action: FieldRef<"BarAction", 'String'>
    readonly createdAt: FieldRef<"BarAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarAction findUnique
   */
  export type BarActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * Filter, which BarAction to fetch.
     */
    where: BarActionWhereUniqueInput
  }

  /**
   * BarAction findUniqueOrThrow
   */
  export type BarActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * Filter, which BarAction to fetch.
     */
    where: BarActionWhereUniqueInput
  }

  /**
   * BarAction findFirst
   */
  export type BarActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * Filter, which BarAction to fetch.
     */
    where?: BarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarActions to fetch.
     */
    orderBy?: BarActionOrderByWithRelationInput | BarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarActions.
     */
    cursor?: BarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarActions.
     */
    distinct?: BarActionScalarFieldEnum | BarActionScalarFieldEnum[]
  }

  /**
   * BarAction findFirstOrThrow
   */
  export type BarActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * Filter, which BarAction to fetch.
     */
    where?: BarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarActions to fetch.
     */
    orderBy?: BarActionOrderByWithRelationInput | BarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarActions.
     */
    cursor?: BarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarActions.
     */
    distinct?: BarActionScalarFieldEnum | BarActionScalarFieldEnum[]
  }

  /**
   * BarAction findMany
   */
  export type BarActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * Filter, which BarActions to fetch.
     */
    where?: BarActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarActions to fetch.
     */
    orderBy?: BarActionOrderByWithRelationInput | BarActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarActions.
     */
    cursor?: BarActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarActions.
     */
    skip?: number
    distinct?: BarActionScalarFieldEnum | BarActionScalarFieldEnum[]
  }

  /**
   * BarAction create
   */
  export type BarActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * The data needed to create a BarAction.
     */
    data: XOR<BarActionCreateInput, BarActionUncheckedCreateInput>
  }

  /**
   * BarAction createMany
   */
  export type BarActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarActions.
     */
    data: BarActionCreateManyInput | BarActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarAction createManyAndReturn
   */
  export type BarActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * The data used to create many BarActions.
     */
    data: BarActionCreateManyInput | BarActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarAction update
   */
  export type BarActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * The data needed to update a BarAction.
     */
    data: XOR<BarActionUpdateInput, BarActionUncheckedUpdateInput>
    /**
     * Choose, which BarAction to update.
     */
    where: BarActionWhereUniqueInput
  }

  /**
   * BarAction updateMany
   */
  export type BarActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarActions.
     */
    data: XOR<BarActionUpdateManyMutationInput, BarActionUncheckedUpdateManyInput>
    /**
     * Filter which BarActions to update
     */
    where?: BarActionWhereInput
    /**
     * Limit how many BarActions to update.
     */
    limit?: number
  }

  /**
   * BarAction updateManyAndReturn
   */
  export type BarActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * The data used to update BarActions.
     */
    data: XOR<BarActionUpdateManyMutationInput, BarActionUncheckedUpdateManyInput>
    /**
     * Filter which BarActions to update
     */
    where?: BarActionWhereInput
    /**
     * Limit how many BarActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarAction upsert
   */
  export type BarActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * The filter to search for the BarAction to update in case it exists.
     */
    where: BarActionWhereUniqueInput
    /**
     * In case the BarAction found by the `where` argument doesn't exist, create a new BarAction with this data.
     */
    create: XOR<BarActionCreateInput, BarActionUncheckedCreateInput>
    /**
     * In case the BarAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarActionUpdateInput, BarActionUncheckedUpdateInput>
  }

  /**
   * BarAction delete
   */
  export type BarActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
    /**
     * Filter which BarAction to delete.
     */
    where: BarActionWhereUniqueInput
  }

  /**
   * BarAction deleteMany
   */
  export type BarActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarActions to delete
     */
    where?: BarActionWhereInput
    /**
     * Limit how many BarActions to delete.
     */
    limit?: number
  }

  /**
   * BarAction without action
   */
  export type BarActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarAction
     */
    select?: BarActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarAction
     */
    omit?: BarActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarActionInclude<ExtArgs> | null
  }


  /**
   * Model BarFollower
   */

  export type AggregateBarFollower = {
    _count: BarFollowerCountAggregateOutputType | null
    _min: BarFollowerMinAggregateOutputType | null
    _max: BarFollowerMaxAggregateOutputType | null
  }

  export type BarFollowerMinAggregateOutputType = {
    id: string | null
    barId: string | null
    patronEmail: string | null
    createdAt: Date | null
  }

  export type BarFollowerMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    patronEmail: string | null
    createdAt: Date | null
  }

  export type BarFollowerCountAggregateOutputType = {
    id: number
    barId: number
    patronEmail: number
    createdAt: number
    _all: number
  }


  export type BarFollowerMinAggregateInputType = {
    id?: true
    barId?: true
    patronEmail?: true
    createdAt?: true
  }

  export type BarFollowerMaxAggregateInputType = {
    id?: true
    barId?: true
    patronEmail?: true
    createdAt?: true
  }

  export type BarFollowerCountAggregateInputType = {
    id?: true
    barId?: true
    patronEmail?: true
    createdAt?: true
    _all?: true
  }

  export type BarFollowerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarFollower to aggregate.
     */
    where?: BarFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarFollowers to fetch.
     */
    orderBy?: BarFollowerOrderByWithRelationInput | BarFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarFollowers
    **/
    _count?: true | BarFollowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarFollowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarFollowerMaxAggregateInputType
  }

  export type GetBarFollowerAggregateType<T extends BarFollowerAggregateArgs> = {
        [P in keyof T & keyof AggregateBarFollower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarFollower[P]>
      : GetScalarType<T[P], AggregateBarFollower[P]>
  }




  export type BarFollowerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarFollowerWhereInput
    orderBy?: BarFollowerOrderByWithAggregationInput | BarFollowerOrderByWithAggregationInput[]
    by: BarFollowerScalarFieldEnum[] | BarFollowerScalarFieldEnum
    having?: BarFollowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarFollowerCountAggregateInputType | true
    _min?: BarFollowerMinAggregateInputType
    _max?: BarFollowerMaxAggregateInputType
  }

  export type BarFollowerGroupByOutputType = {
    id: string
    barId: string
    patronEmail: string
    createdAt: Date
    _count: BarFollowerCountAggregateOutputType | null
    _min: BarFollowerMinAggregateOutputType | null
    _max: BarFollowerMaxAggregateOutputType | null
  }

  type GetBarFollowerGroupByPayload<T extends BarFollowerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarFollowerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarFollowerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarFollowerGroupByOutputType[P]>
            : GetScalarType<T[P], BarFollowerGroupByOutputType[P]>
        }
      >
    >


  export type BarFollowerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    patronEmail?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barFollower"]>

  export type BarFollowerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    patronEmail?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barFollower"]>

  export type BarFollowerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    patronEmail?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barFollower"]>

  export type BarFollowerSelectScalar = {
    id?: boolean
    barId?: boolean
    patronEmail?: boolean
    createdAt?: boolean
  }

  export type BarFollowerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "patronEmail" | "createdAt", ExtArgs["result"]["barFollower"]>
  export type BarFollowerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarFollowerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BarFollowerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $BarFollowerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarFollower"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      patronEmail: string
      createdAt: Date
    }, ExtArgs["result"]["barFollower"]>
    composites: {}
  }

  type BarFollowerGetPayload<S extends boolean | null | undefined | BarFollowerDefaultArgs> = $Result.GetResult<Prisma.$BarFollowerPayload, S>

  type BarFollowerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarFollowerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarFollowerCountAggregateInputType | true
    }

  export interface BarFollowerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarFollower'], meta: { name: 'BarFollower' } }
    /**
     * Find zero or one BarFollower that matches the filter.
     * @param {BarFollowerFindUniqueArgs} args - Arguments to find a BarFollower
     * @example
     * // Get one BarFollower
     * const barFollower = await prisma.barFollower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarFollowerFindUniqueArgs>(args: SelectSubset<T, BarFollowerFindUniqueArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarFollower that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarFollowerFindUniqueOrThrowArgs} args - Arguments to find a BarFollower
     * @example
     * // Get one BarFollower
     * const barFollower = await prisma.barFollower.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarFollowerFindUniqueOrThrowArgs>(args: SelectSubset<T, BarFollowerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarFollower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerFindFirstArgs} args - Arguments to find a BarFollower
     * @example
     * // Get one BarFollower
     * const barFollower = await prisma.barFollower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarFollowerFindFirstArgs>(args?: SelectSubset<T, BarFollowerFindFirstArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarFollower that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerFindFirstOrThrowArgs} args - Arguments to find a BarFollower
     * @example
     * // Get one BarFollower
     * const barFollower = await prisma.barFollower.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarFollowerFindFirstOrThrowArgs>(args?: SelectSubset<T, BarFollowerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarFollowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarFollowers
     * const barFollowers = await prisma.barFollower.findMany()
     * 
     * // Get first 10 BarFollowers
     * const barFollowers = await prisma.barFollower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barFollowerWithIdOnly = await prisma.barFollower.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarFollowerFindManyArgs>(args?: SelectSubset<T, BarFollowerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarFollower.
     * @param {BarFollowerCreateArgs} args - Arguments to create a BarFollower.
     * @example
     * // Create one BarFollower
     * const BarFollower = await prisma.barFollower.create({
     *   data: {
     *     // ... data to create a BarFollower
     *   }
     * })
     * 
     */
    create<T extends BarFollowerCreateArgs>(args: SelectSubset<T, BarFollowerCreateArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarFollowers.
     * @param {BarFollowerCreateManyArgs} args - Arguments to create many BarFollowers.
     * @example
     * // Create many BarFollowers
     * const barFollower = await prisma.barFollower.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarFollowerCreateManyArgs>(args?: SelectSubset<T, BarFollowerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarFollowers and returns the data saved in the database.
     * @param {BarFollowerCreateManyAndReturnArgs} args - Arguments to create many BarFollowers.
     * @example
     * // Create many BarFollowers
     * const barFollower = await prisma.barFollower.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarFollowers and only return the `id`
     * const barFollowerWithIdOnly = await prisma.barFollower.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarFollowerCreateManyAndReturnArgs>(args?: SelectSubset<T, BarFollowerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarFollower.
     * @param {BarFollowerDeleteArgs} args - Arguments to delete one BarFollower.
     * @example
     * // Delete one BarFollower
     * const BarFollower = await prisma.barFollower.delete({
     *   where: {
     *     // ... filter to delete one BarFollower
     *   }
     * })
     * 
     */
    delete<T extends BarFollowerDeleteArgs>(args: SelectSubset<T, BarFollowerDeleteArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarFollower.
     * @param {BarFollowerUpdateArgs} args - Arguments to update one BarFollower.
     * @example
     * // Update one BarFollower
     * const barFollower = await prisma.barFollower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarFollowerUpdateArgs>(args: SelectSubset<T, BarFollowerUpdateArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarFollowers.
     * @param {BarFollowerDeleteManyArgs} args - Arguments to filter BarFollowers to delete.
     * @example
     * // Delete a few BarFollowers
     * const { count } = await prisma.barFollower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarFollowerDeleteManyArgs>(args?: SelectSubset<T, BarFollowerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarFollowers
     * const barFollower = await prisma.barFollower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarFollowerUpdateManyArgs>(args: SelectSubset<T, BarFollowerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarFollowers and returns the data updated in the database.
     * @param {BarFollowerUpdateManyAndReturnArgs} args - Arguments to update many BarFollowers.
     * @example
     * // Update many BarFollowers
     * const barFollower = await prisma.barFollower.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarFollowers and only return the `id`
     * const barFollowerWithIdOnly = await prisma.barFollower.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarFollowerUpdateManyAndReturnArgs>(args: SelectSubset<T, BarFollowerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarFollower.
     * @param {BarFollowerUpsertArgs} args - Arguments to update or create a BarFollower.
     * @example
     * // Update or create a BarFollower
     * const barFollower = await prisma.barFollower.upsert({
     *   create: {
     *     // ... data to create a BarFollower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarFollower we want to update
     *   }
     * })
     */
    upsert<T extends BarFollowerUpsertArgs>(args: SelectSubset<T, BarFollowerUpsertArgs<ExtArgs>>): Prisma__BarFollowerClient<$Result.GetResult<Prisma.$BarFollowerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerCountArgs} args - Arguments to filter BarFollowers to count.
     * @example
     * // Count the number of BarFollowers
     * const count = await prisma.barFollower.count({
     *   where: {
     *     // ... the filter for the BarFollowers we want to count
     *   }
     * })
    **/
    count<T extends BarFollowerCountArgs>(
      args?: Subset<T, BarFollowerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarFollowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarFollowerAggregateArgs>(args: Subset<T, BarFollowerAggregateArgs>): Prisma.PrismaPromise<GetBarFollowerAggregateType<T>>

    /**
     * Group by BarFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarFollowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarFollowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarFollowerGroupByArgs['orderBy'] }
        : { orderBy?: BarFollowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarFollowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarFollowerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarFollower model
   */
  readonly fields: BarFollowerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarFollower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarFollowerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarFollower model
   */
  interface BarFollowerFieldRefs {
    readonly id: FieldRef<"BarFollower", 'String'>
    readonly barId: FieldRef<"BarFollower", 'String'>
    readonly patronEmail: FieldRef<"BarFollower", 'String'>
    readonly createdAt: FieldRef<"BarFollower", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarFollower findUnique
   */
  export type BarFollowerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * Filter, which BarFollower to fetch.
     */
    where: BarFollowerWhereUniqueInput
  }

  /**
   * BarFollower findUniqueOrThrow
   */
  export type BarFollowerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * Filter, which BarFollower to fetch.
     */
    where: BarFollowerWhereUniqueInput
  }

  /**
   * BarFollower findFirst
   */
  export type BarFollowerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * Filter, which BarFollower to fetch.
     */
    where?: BarFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarFollowers to fetch.
     */
    orderBy?: BarFollowerOrderByWithRelationInput | BarFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarFollowers.
     */
    cursor?: BarFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarFollowers.
     */
    distinct?: BarFollowerScalarFieldEnum | BarFollowerScalarFieldEnum[]
  }

  /**
   * BarFollower findFirstOrThrow
   */
  export type BarFollowerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * Filter, which BarFollower to fetch.
     */
    where?: BarFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarFollowers to fetch.
     */
    orderBy?: BarFollowerOrderByWithRelationInput | BarFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarFollowers.
     */
    cursor?: BarFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarFollowers.
     */
    distinct?: BarFollowerScalarFieldEnum | BarFollowerScalarFieldEnum[]
  }

  /**
   * BarFollower findMany
   */
  export type BarFollowerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * Filter, which BarFollowers to fetch.
     */
    where?: BarFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarFollowers to fetch.
     */
    orderBy?: BarFollowerOrderByWithRelationInput | BarFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarFollowers.
     */
    cursor?: BarFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarFollowers.
     */
    skip?: number
    distinct?: BarFollowerScalarFieldEnum | BarFollowerScalarFieldEnum[]
  }

  /**
   * BarFollower create
   */
  export type BarFollowerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * The data needed to create a BarFollower.
     */
    data: XOR<BarFollowerCreateInput, BarFollowerUncheckedCreateInput>
  }

  /**
   * BarFollower createMany
   */
  export type BarFollowerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarFollowers.
     */
    data: BarFollowerCreateManyInput | BarFollowerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarFollower createManyAndReturn
   */
  export type BarFollowerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * The data used to create many BarFollowers.
     */
    data: BarFollowerCreateManyInput | BarFollowerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarFollower update
   */
  export type BarFollowerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * The data needed to update a BarFollower.
     */
    data: XOR<BarFollowerUpdateInput, BarFollowerUncheckedUpdateInput>
    /**
     * Choose, which BarFollower to update.
     */
    where: BarFollowerWhereUniqueInput
  }

  /**
   * BarFollower updateMany
   */
  export type BarFollowerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarFollowers.
     */
    data: XOR<BarFollowerUpdateManyMutationInput, BarFollowerUncheckedUpdateManyInput>
    /**
     * Filter which BarFollowers to update
     */
    where?: BarFollowerWhereInput
    /**
     * Limit how many BarFollowers to update.
     */
    limit?: number
  }

  /**
   * BarFollower updateManyAndReturn
   */
  export type BarFollowerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * The data used to update BarFollowers.
     */
    data: XOR<BarFollowerUpdateManyMutationInput, BarFollowerUncheckedUpdateManyInput>
    /**
     * Filter which BarFollowers to update
     */
    where?: BarFollowerWhereInput
    /**
     * Limit how many BarFollowers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarFollower upsert
   */
  export type BarFollowerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * The filter to search for the BarFollower to update in case it exists.
     */
    where: BarFollowerWhereUniqueInput
    /**
     * In case the BarFollower found by the `where` argument doesn't exist, create a new BarFollower with this data.
     */
    create: XOR<BarFollowerCreateInput, BarFollowerUncheckedCreateInput>
    /**
     * In case the BarFollower was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarFollowerUpdateInput, BarFollowerUncheckedUpdateInput>
  }

  /**
   * BarFollower delete
   */
  export type BarFollowerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
    /**
     * Filter which BarFollower to delete.
     */
    where: BarFollowerWhereUniqueInput
  }

  /**
   * BarFollower deleteMany
   */
  export type BarFollowerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarFollowers to delete
     */
    where?: BarFollowerWhereInput
    /**
     * Limit how many BarFollowers to delete.
     */
    limit?: number
  }

  /**
   * BarFollower without action
   */
  export type BarFollowerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarFollower
     */
    select?: BarFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarFollower
     */
    omit?: BarFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarFollowerInclude<ExtArgs> | null
  }


  /**
   * Model Boost
   */

  export type AggregateBoost = {
    _count: BoostCountAggregateOutputType | null
    _avg: BoostAvgAggregateOutputType | null
    _sum: BoostSumAggregateOutputType | null
    _min: BoostMinAggregateOutputType | null
    _max: BoostMaxAggregateOutputType | null
  }

  export type BoostAvgAggregateOutputType = {
    budgetCents: number | null
  }

  export type BoostSumAggregateOutputType = {
    budgetCents: number | null
  }

  export type BoostMinAggregateOutputType = {
    id: string | null
    barId: string | null
    eventId: string | null
    startAt: Date | null
    endAt: Date | null
    budgetCents: number | null
    status: string | null
    createdAt: Date | null
  }

  export type BoostMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    eventId: string | null
    startAt: Date | null
    endAt: Date | null
    budgetCents: number | null
    status: string | null
    createdAt: Date | null
  }

  export type BoostCountAggregateOutputType = {
    id: number
    barId: number
    eventId: number
    startAt: number
    endAt: number
    budgetCents: number
    status: number
    createdAt: number
    _all: number
  }


  export type BoostAvgAggregateInputType = {
    budgetCents?: true
  }

  export type BoostSumAggregateInputType = {
    budgetCents?: true
  }

  export type BoostMinAggregateInputType = {
    id?: true
    barId?: true
    eventId?: true
    startAt?: true
    endAt?: true
    budgetCents?: true
    status?: true
    createdAt?: true
  }

  export type BoostMaxAggregateInputType = {
    id?: true
    barId?: true
    eventId?: true
    startAt?: true
    endAt?: true
    budgetCents?: true
    status?: true
    createdAt?: true
  }

  export type BoostCountAggregateInputType = {
    id?: true
    barId?: true
    eventId?: true
    startAt?: true
    endAt?: true
    budgetCents?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type BoostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boost to aggregate.
     */
    where?: BoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boosts to fetch.
     */
    orderBy?: BoostOrderByWithRelationInput | BoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boosts
    **/
    _count?: true | BoostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoostMaxAggregateInputType
  }

  export type GetBoostAggregateType<T extends BoostAggregateArgs> = {
        [P in keyof T & keyof AggregateBoost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoost[P]>
      : GetScalarType<T[P], AggregateBoost[P]>
  }




  export type BoostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoostWhereInput
    orderBy?: BoostOrderByWithAggregationInput | BoostOrderByWithAggregationInput[]
    by: BoostScalarFieldEnum[] | BoostScalarFieldEnum
    having?: BoostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoostCountAggregateInputType | true
    _avg?: BoostAvgAggregateInputType
    _sum?: BoostSumAggregateInputType
    _min?: BoostMinAggregateInputType
    _max?: BoostMaxAggregateInputType
  }

  export type BoostGroupByOutputType = {
    id: string
    barId: string
    eventId: string | null
    startAt: Date
    endAt: Date
    budgetCents: number
    status: string
    createdAt: Date
    _count: BoostCountAggregateOutputType | null
    _avg: BoostAvgAggregateOutputType | null
    _sum: BoostSumAggregateOutputType | null
    _min: BoostMinAggregateOutputType | null
    _max: BoostMaxAggregateOutputType | null
  }

  type GetBoostGroupByPayload<T extends BoostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoostGroupByOutputType[P]>
            : GetScalarType<T[P], BoostGroupByOutputType[P]>
        }
      >
    >


  export type BoostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    eventId?: boolean
    startAt?: boolean
    endAt?: boolean
    budgetCents?: boolean
    status?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    metrics?: boolean | Boost$metricsArgs<ExtArgs>
    _count?: boolean | BoostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boost"]>

  export type BoostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    eventId?: boolean
    startAt?: boolean
    endAt?: boolean
    budgetCents?: boolean
    status?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boost"]>

  export type BoostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    eventId?: boolean
    startAt?: boolean
    endAt?: boolean
    budgetCents?: boolean
    status?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boost"]>

  export type BoostSelectScalar = {
    id?: boolean
    barId?: boolean
    eventId?: boolean
    startAt?: boolean
    endAt?: boolean
    budgetCents?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type BoostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "eventId" | "startAt" | "endAt" | "budgetCents" | "status" | "createdAt", ExtArgs["result"]["boost"]>
  export type BoostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    metrics?: boolean | Boost$metricsArgs<ExtArgs>
    _count?: boolean | BoostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type BoostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $BoostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Boost"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      metrics: Prisma.$BoostMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      eventId: string | null
      startAt: Date
      endAt: Date
      budgetCents: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["boost"]>
    composites: {}
  }

  type BoostGetPayload<S extends boolean | null | undefined | BoostDefaultArgs> = $Result.GetResult<Prisma.$BoostPayload, S>

  type BoostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoostCountAggregateInputType | true
    }

  export interface BoostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Boost'], meta: { name: 'Boost' } }
    /**
     * Find zero or one Boost that matches the filter.
     * @param {BoostFindUniqueArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoostFindUniqueArgs>(args: SelectSubset<T, BoostFindUniqueArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoostFindUniqueOrThrowArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoostFindUniqueOrThrowArgs>(args: SelectSubset<T, BoostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostFindFirstArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoostFindFirstArgs>(args?: SelectSubset<T, BoostFindFirstArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostFindFirstOrThrowArgs} args - Arguments to find a Boost
     * @example
     * // Get one Boost
     * const boost = await prisma.boost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoostFindFirstOrThrowArgs>(args?: SelectSubset<T, BoostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boosts
     * const boosts = await prisma.boost.findMany()
     * 
     * // Get first 10 Boosts
     * const boosts = await prisma.boost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boostWithIdOnly = await prisma.boost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoostFindManyArgs>(args?: SelectSubset<T, BoostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boost.
     * @param {BoostCreateArgs} args - Arguments to create a Boost.
     * @example
     * // Create one Boost
     * const Boost = await prisma.boost.create({
     *   data: {
     *     // ... data to create a Boost
     *   }
     * })
     * 
     */
    create<T extends BoostCreateArgs>(args: SelectSubset<T, BoostCreateArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boosts.
     * @param {BoostCreateManyArgs} args - Arguments to create many Boosts.
     * @example
     * // Create many Boosts
     * const boost = await prisma.boost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoostCreateManyArgs>(args?: SelectSubset<T, BoostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boosts and returns the data saved in the database.
     * @param {BoostCreateManyAndReturnArgs} args - Arguments to create many Boosts.
     * @example
     * // Create many Boosts
     * const boost = await prisma.boost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boosts and only return the `id`
     * const boostWithIdOnly = await prisma.boost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoostCreateManyAndReturnArgs>(args?: SelectSubset<T, BoostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Boost.
     * @param {BoostDeleteArgs} args - Arguments to delete one Boost.
     * @example
     * // Delete one Boost
     * const Boost = await prisma.boost.delete({
     *   where: {
     *     // ... filter to delete one Boost
     *   }
     * })
     * 
     */
    delete<T extends BoostDeleteArgs>(args: SelectSubset<T, BoostDeleteArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boost.
     * @param {BoostUpdateArgs} args - Arguments to update one Boost.
     * @example
     * // Update one Boost
     * const boost = await prisma.boost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoostUpdateArgs>(args: SelectSubset<T, BoostUpdateArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boosts.
     * @param {BoostDeleteManyArgs} args - Arguments to filter Boosts to delete.
     * @example
     * // Delete a few Boosts
     * const { count } = await prisma.boost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoostDeleteManyArgs>(args?: SelectSubset<T, BoostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boosts
     * const boost = await prisma.boost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoostUpdateManyArgs>(args: SelectSubset<T, BoostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boosts and returns the data updated in the database.
     * @param {BoostUpdateManyAndReturnArgs} args - Arguments to update many Boosts.
     * @example
     * // Update many Boosts
     * const boost = await prisma.boost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boosts and only return the `id`
     * const boostWithIdOnly = await prisma.boost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoostUpdateManyAndReturnArgs>(args: SelectSubset<T, BoostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Boost.
     * @param {BoostUpsertArgs} args - Arguments to update or create a Boost.
     * @example
     * // Update or create a Boost
     * const boost = await prisma.boost.upsert({
     *   create: {
     *     // ... data to create a Boost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boost we want to update
     *   }
     * })
     */
    upsert<T extends BoostUpsertArgs>(args: SelectSubset<T, BoostUpsertArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostCountArgs} args - Arguments to filter Boosts to count.
     * @example
     * // Count the number of Boosts
     * const count = await prisma.boost.count({
     *   where: {
     *     // ... the filter for the Boosts we want to count
     *   }
     * })
    **/
    count<T extends BoostCountArgs>(
      args?: Subset<T, BoostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoostAggregateArgs>(args: Subset<T, BoostAggregateArgs>): Prisma.PrismaPromise<GetBoostAggregateType<T>>

    /**
     * Group by Boost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoostGroupByArgs['orderBy'] }
        : { orderBy?: BoostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Boost model
   */
  readonly fields: BoostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Boost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metrics<T extends Boost$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Boost$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Boost model
   */
  interface BoostFieldRefs {
    readonly id: FieldRef<"Boost", 'String'>
    readonly barId: FieldRef<"Boost", 'String'>
    readonly eventId: FieldRef<"Boost", 'String'>
    readonly startAt: FieldRef<"Boost", 'DateTime'>
    readonly endAt: FieldRef<"Boost", 'DateTime'>
    readonly budgetCents: FieldRef<"Boost", 'Int'>
    readonly status: FieldRef<"Boost", 'String'>
    readonly createdAt: FieldRef<"Boost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Boost findUnique
   */
  export type BoostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * Filter, which Boost to fetch.
     */
    where: BoostWhereUniqueInput
  }

  /**
   * Boost findUniqueOrThrow
   */
  export type BoostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * Filter, which Boost to fetch.
     */
    where: BoostWhereUniqueInput
  }

  /**
   * Boost findFirst
   */
  export type BoostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * Filter, which Boost to fetch.
     */
    where?: BoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boosts to fetch.
     */
    orderBy?: BoostOrderByWithRelationInput | BoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boosts.
     */
    cursor?: BoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boosts.
     */
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * Boost findFirstOrThrow
   */
  export type BoostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * Filter, which Boost to fetch.
     */
    where?: BoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boosts to fetch.
     */
    orderBy?: BoostOrderByWithRelationInput | BoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boosts.
     */
    cursor?: BoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boosts.
     */
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * Boost findMany
   */
  export type BoostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * Filter, which Boosts to fetch.
     */
    where?: BoostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boosts to fetch.
     */
    orderBy?: BoostOrderByWithRelationInput | BoostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boosts.
     */
    cursor?: BoostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boosts.
     */
    skip?: number
    distinct?: BoostScalarFieldEnum | BoostScalarFieldEnum[]
  }

  /**
   * Boost create
   */
  export type BoostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * The data needed to create a Boost.
     */
    data: XOR<BoostCreateInput, BoostUncheckedCreateInput>
  }

  /**
   * Boost createMany
   */
  export type BoostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boosts.
     */
    data: BoostCreateManyInput | BoostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Boost createManyAndReturn
   */
  export type BoostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * The data used to create many Boosts.
     */
    data: BoostCreateManyInput | BoostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Boost update
   */
  export type BoostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * The data needed to update a Boost.
     */
    data: XOR<BoostUpdateInput, BoostUncheckedUpdateInput>
    /**
     * Choose, which Boost to update.
     */
    where: BoostWhereUniqueInput
  }

  /**
   * Boost updateMany
   */
  export type BoostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boosts.
     */
    data: XOR<BoostUpdateManyMutationInput, BoostUncheckedUpdateManyInput>
    /**
     * Filter which Boosts to update
     */
    where?: BoostWhereInput
    /**
     * Limit how many Boosts to update.
     */
    limit?: number
  }

  /**
   * Boost updateManyAndReturn
   */
  export type BoostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * The data used to update Boosts.
     */
    data: XOR<BoostUpdateManyMutationInput, BoostUncheckedUpdateManyInput>
    /**
     * Filter which Boosts to update
     */
    where?: BoostWhereInput
    /**
     * Limit how many Boosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Boost upsert
   */
  export type BoostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * The filter to search for the Boost to update in case it exists.
     */
    where: BoostWhereUniqueInput
    /**
     * In case the Boost found by the `where` argument doesn't exist, create a new Boost with this data.
     */
    create: XOR<BoostCreateInput, BoostUncheckedCreateInput>
    /**
     * In case the Boost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoostUpdateInput, BoostUncheckedUpdateInput>
  }

  /**
   * Boost delete
   */
  export type BoostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
    /**
     * Filter which Boost to delete.
     */
    where: BoostWhereUniqueInput
  }

  /**
   * Boost deleteMany
   */
  export type BoostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boosts to delete
     */
    where?: BoostWhereInput
    /**
     * Limit how many Boosts to delete.
     */
    limit?: number
  }

  /**
   * Boost.metrics
   */
  export type Boost$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    where?: BoostMetricWhereInput
    orderBy?: BoostMetricOrderByWithRelationInput | BoostMetricOrderByWithRelationInput[]
    cursor?: BoostMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoostMetricScalarFieldEnum | BoostMetricScalarFieldEnum[]
  }

  /**
   * Boost without action
   */
  export type BoostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boost
     */
    select?: BoostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boost
     */
    omit?: BoostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostInclude<ExtArgs> | null
  }


  /**
   * Model BoostMetric
   */

  export type AggregateBoostMetric = {
    _count: BoostMetricCountAggregateOutputType | null
    _avg: BoostMetricAvgAggregateOutputType | null
    _sum: BoostMetricSumAggregateOutputType | null
    _min: BoostMetricMinAggregateOutputType | null
    _max: BoostMetricMaxAggregateOutputType | null
  }

  export type BoostMetricAvgAggregateOutputType = {
    impressions: number | null
    clicks: number | null
  }

  export type BoostMetricSumAggregateOutputType = {
    impressions: number | null
    clicks: number | null
  }

  export type BoostMetricMinAggregateOutputType = {
    id: string | null
    boostId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
  }

  export type BoostMetricMaxAggregateOutputType = {
    id: string | null
    boostId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
  }

  export type BoostMetricCountAggregateOutputType = {
    id: number
    boostId: number
    date: number
    impressions: number
    clicks: number
    _all: number
  }


  export type BoostMetricAvgAggregateInputType = {
    impressions?: true
    clicks?: true
  }

  export type BoostMetricSumAggregateInputType = {
    impressions?: true
    clicks?: true
  }

  export type BoostMetricMinAggregateInputType = {
    id?: true
    boostId?: true
    date?: true
    impressions?: true
    clicks?: true
  }

  export type BoostMetricMaxAggregateInputType = {
    id?: true
    boostId?: true
    date?: true
    impressions?: true
    clicks?: true
  }

  export type BoostMetricCountAggregateInputType = {
    id?: true
    boostId?: true
    date?: true
    impressions?: true
    clicks?: true
    _all?: true
  }

  export type BoostMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoostMetric to aggregate.
     */
    where?: BoostMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoostMetrics to fetch.
     */
    orderBy?: BoostMetricOrderByWithRelationInput | BoostMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoostMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoostMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoostMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoostMetrics
    **/
    _count?: true | BoostMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoostMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoostMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoostMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoostMetricMaxAggregateInputType
  }

  export type GetBoostMetricAggregateType<T extends BoostMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateBoostMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoostMetric[P]>
      : GetScalarType<T[P], AggregateBoostMetric[P]>
  }




  export type BoostMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoostMetricWhereInput
    orderBy?: BoostMetricOrderByWithAggregationInput | BoostMetricOrderByWithAggregationInput[]
    by: BoostMetricScalarFieldEnum[] | BoostMetricScalarFieldEnum
    having?: BoostMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoostMetricCountAggregateInputType | true
    _avg?: BoostMetricAvgAggregateInputType
    _sum?: BoostMetricSumAggregateInputType
    _min?: BoostMetricMinAggregateInputType
    _max?: BoostMetricMaxAggregateInputType
  }

  export type BoostMetricGroupByOutputType = {
    id: string
    boostId: string
    date: Date
    impressions: number
    clicks: number
    _count: BoostMetricCountAggregateOutputType | null
    _avg: BoostMetricAvgAggregateOutputType | null
    _sum: BoostMetricSumAggregateOutputType | null
    _min: BoostMetricMinAggregateOutputType | null
    _max: BoostMetricMaxAggregateOutputType | null
  }

  type GetBoostMetricGroupByPayload<T extends BoostMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoostMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoostMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoostMetricGroupByOutputType[P]>
            : GetScalarType<T[P], BoostMetricGroupByOutputType[P]>
        }
      >
    >


  export type BoostMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boostId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    boost?: boolean | BoostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boostMetric"]>

  export type BoostMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boostId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    boost?: boolean | BoostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boostMetric"]>

  export type BoostMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boostId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    boost?: boolean | BoostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boostMetric"]>

  export type BoostMetricSelectScalar = {
    id?: boolean
    boostId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
  }

  export type BoostMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boostId" | "date" | "impressions" | "clicks", ExtArgs["result"]["boostMetric"]>
  export type BoostMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boost?: boolean | BoostDefaultArgs<ExtArgs>
  }
  export type BoostMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boost?: boolean | BoostDefaultArgs<ExtArgs>
  }
  export type BoostMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boost?: boolean | BoostDefaultArgs<ExtArgs>
  }

  export type $BoostMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoostMetric"
    objects: {
      boost: Prisma.$BoostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      boostId: string
      date: Date
      impressions: number
      clicks: number
    }, ExtArgs["result"]["boostMetric"]>
    composites: {}
  }

  type BoostMetricGetPayload<S extends boolean | null | undefined | BoostMetricDefaultArgs> = $Result.GetResult<Prisma.$BoostMetricPayload, S>

  type BoostMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoostMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoostMetricCountAggregateInputType | true
    }

  export interface BoostMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoostMetric'], meta: { name: 'BoostMetric' } }
    /**
     * Find zero or one BoostMetric that matches the filter.
     * @param {BoostMetricFindUniqueArgs} args - Arguments to find a BoostMetric
     * @example
     * // Get one BoostMetric
     * const boostMetric = await prisma.boostMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoostMetricFindUniqueArgs>(args: SelectSubset<T, BoostMetricFindUniqueArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BoostMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoostMetricFindUniqueOrThrowArgs} args - Arguments to find a BoostMetric
     * @example
     * // Get one BoostMetric
     * const boostMetric = await prisma.boostMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoostMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, BoostMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoostMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricFindFirstArgs} args - Arguments to find a BoostMetric
     * @example
     * // Get one BoostMetric
     * const boostMetric = await prisma.boostMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoostMetricFindFirstArgs>(args?: SelectSubset<T, BoostMetricFindFirstArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoostMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricFindFirstOrThrowArgs} args - Arguments to find a BoostMetric
     * @example
     * // Get one BoostMetric
     * const boostMetric = await prisma.boostMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoostMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, BoostMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BoostMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoostMetrics
     * const boostMetrics = await prisma.boostMetric.findMany()
     * 
     * // Get first 10 BoostMetrics
     * const boostMetrics = await prisma.boostMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boostMetricWithIdOnly = await prisma.boostMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoostMetricFindManyArgs>(args?: SelectSubset<T, BoostMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BoostMetric.
     * @param {BoostMetricCreateArgs} args - Arguments to create a BoostMetric.
     * @example
     * // Create one BoostMetric
     * const BoostMetric = await prisma.boostMetric.create({
     *   data: {
     *     // ... data to create a BoostMetric
     *   }
     * })
     * 
     */
    create<T extends BoostMetricCreateArgs>(args: SelectSubset<T, BoostMetricCreateArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BoostMetrics.
     * @param {BoostMetricCreateManyArgs} args - Arguments to create many BoostMetrics.
     * @example
     * // Create many BoostMetrics
     * const boostMetric = await prisma.boostMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoostMetricCreateManyArgs>(args?: SelectSubset<T, BoostMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BoostMetrics and returns the data saved in the database.
     * @param {BoostMetricCreateManyAndReturnArgs} args - Arguments to create many BoostMetrics.
     * @example
     * // Create many BoostMetrics
     * const boostMetric = await prisma.boostMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BoostMetrics and only return the `id`
     * const boostMetricWithIdOnly = await prisma.boostMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoostMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, BoostMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BoostMetric.
     * @param {BoostMetricDeleteArgs} args - Arguments to delete one BoostMetric.
     * @example
     * // Delete one BoostMetric
     * const BoostMetric = await prisma.boostMetric.delete({
     *   where: {
     *     // ... filter to delete one BoostMetric
     *   }
     * })
     * 
     */
    delete<T extends BoostMetricDeleteArgs>(args: SelectSubset<T, BoostMetricDeleteArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BoostMetric.
     * @param {BoostMetricUpdateArgs} args - Arguments to update one BoostMetric.
     * @example
     * // Update one BoostMetric
     * const boostMetric = await prisma.boostMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoostMetricUpdateArgs>(args: SelectSubset<T, BoostMetricUpdateArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BoostMetrics.
     * @param {BoostMetricDeleteManyArgs} args - Arguments to filter BoostMetrics to delete.
     * @example
     * // Delete a few BoostMetrics
     * const { count } = await prisma.boostMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoostMetricDeleteManyArgs>(args?: SelectSubset<T, BoostMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoostMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoostMetrics
     * const boostMetric = await prisma.boostMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoostMetricUpdateManyArgs>(args: SelectSubset<T, BoostMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoostMetrics and returns the data updated in the database.
     * @param {BoostMetricUpdateManyAndReturnArgs} args - Arguments to update many BoostMetrics.
     * @example
     * // Update many BoostMetrics
     * const boostMetric = await prisma.boostMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BoostMetrics and only return the `id`
     * const boostMetricWithIdOnly = await prisma.boostMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoostMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, BoostMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BoostMetric.
     * @param {BoostMetricUpsertArgs} args - Arguments to update or create a BoostMetric.
     * @example
     * // Update or create a BoostMetric
     * const boostMetric = await prisma.boostMetric.upsert({
     *   create: {
     *     // ... data to create a BoostMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoostMetric we want to update
     *   }
     * })
     */
    upsert<T extends BoostMetricUpsertArgs>(args: SelectSubset<T, BoostMetricUpsertArgs<ExtArgs>>): Prisma__BoostMetricClient<$Result.GetResult<Prisma.$BoostMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BoostMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricCountArgs} args - Arguments to filter BoostMetrics to count.
     * @example
     * // Count the number of BoostMetrics
     * const count = await prisma.boostMetric.count({
     *   where: {
     *     // ... the filter for the BoostMetrics we want to count
     *   }
     * })
    **/
    count<T extends BoostMetricCountArgs>(
      args?: Subset<T, BoostMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoostMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoostMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoostMetricAggregateArgs>(args: Subset<T, BoostMetricAggregateArgs>): Prisma.PrismaPromise<GetBoostMetricAggregateType<T>>

    /**
     * Group by BoostMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoostMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoostMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoostMetricGroupByArgs['orderBy'] }
        : { orderBy?: BoostMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoostMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoostMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoostMetric model
   */
  readonly fields: BoostMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoostMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoostMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boost<T extends BoostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoostDefaultArgs<ExtArgs>>): Prisma__BoostClient<$Result.GetResult<Prisma.$BoostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoostMetric model
   */
  interface BoostMetricFieldRefs {
    readonly id: FieldRef<"BoostMetric", 'String'>
    readonly boostId: FieldRef<"BoostMetric", 'String'>
    readonly date: FieldRef<"BoostMetric", 'DateTime'>
    readonly impressions: FieldRef<"BoostMetric", 'Int'>
    readonly clicks: FieldRef<"BoostMetric", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BoostMetric findUnique
   */
  export type BoostMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * Filter, which BoostMetric to fetch.
     */
    where: BoostMetricWhereUniqueInput
  }

  /**
   * BoostMetric findUniqueOrThrow
   */
  export type BoostMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * Filter, which BoostMetric to fetch.
     */
    where: BoostMetricWhereUniqueInput
  }

  /**
   * BoostMetric findFirst
   */
  export type BoostMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * Filter, which BoostMetric to fetch.
     */
    where?: BoostMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoostMetrics to fetch.
     */
    orderBy?: BoostMetricOrderByWithRelationInput | BoostMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoostMetrics.
     */
    cursor?: BoostMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoostMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoostMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoostMetrics.
     */
    distinct?: BoostMetricScalarFieldEnum | BoostMetricScalarFieldEnum[]
  }

  /**
   * BoostMetric findFirstOrThrow
   */
  export type BoostMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * Filter, which BoostMetric to fetch.
     */
    where?: BoostMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoostMetrics to fetch.
     */
    orderBy?: BoostMetricOrderByWithRelationInput | BoostMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoostMetrics.
     */
    cursor?: BoostMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoostMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoostMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoostMetrics.
     */
    distinct?: BoostMetricScalarFieldEnum | BoostMetricScalarFieldEnum[]
  }

  /**
   * BoostMetric findMany
   */
  export type BoostMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * Filter, which BoostMetrics to fetch.
     */
    where?: BoostMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoostMetrics to fetch.
     */
    orderBy?: BoostMetricOrderByWithRelationInput | BoostMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoostMetrics.
     */
    cursor?: BoostMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoostMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoostMetrics.
     */
    skip?: number
    distinct?: BoostMetricScalarFieldEnum | BoostMetricScalarFieldEnum[]
  }

  /**
   * BoostMetric create
   */
  export type BoostMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a BoostMetric.
     */
    data: XOR<BoostMetricCreateInput, BoostMetricUncheckedCreateInput>
  }

  /**
   * BoostMetric createMany
   */
  export type BoostMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoostMetrics.
     */
    data: BoostMetricCreateManyInput | BoostMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoostMetric createManyAndReturn
   */
  export type BoostMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * The data used to create many BoostMetrics.
     */
    data: BoostMetricCreateManyInput | BoostMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoostMetric update
   */
  export type BoostMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a BoostMetric.
     */
    data: XOR<BoostMetricUpdateInput, BoostMetricUncheckedUpdateInput>
    /**
     * Choose, which BoostMetric to update.
     */
    where: BoostMetricWhereUniqueInput
  }

  /**
   * BoostMetric updateMany
   */
  export type BoostMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoostMetrics.
     */
    data: XOR<BoostMetricUpdateManyMutationInput, BoostMetricUncheckedUpdateManyInput>
    /**
     * Filter which BoostMetrics to update
     */
    where?: BoostMetricWhereInput
    /**
     * Limit how many BoostMetrics to update.
     */
    limit?: number
  }

  /**
   * BoostMetric updateManyAndReturn
   */
  export type BoostMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * The data used to update BoostMetrics.
     */
    data: XOR<BoostMetricUpdateManyMutationInput, BoostMetricUncheckedUpdateManyInput>
    /**
     * Filter which BoostMetrics to update
     */
    where?: BoostMetricWhereInput
    /**
     * Limit how many BoostMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoostMetric upsert
   */
  export type BoostMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the BoostMetric to update in case it exists.
     */
    where: BoostMetricWhereUniqueInput
    /**
     * In case the BoostMetric found by the `where` argument doesn't exist, create a new BoostMetric with this data.
     */
    create: XOR<BoostMetricCreateInput, BoostMetricUncheckedCreateInput>
    /**
     * In case the BoostMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoostMetricUpdateInput, BoostMetricUncheckedUpdateInput>
  }

  /**
   * BoostMetric delete
   */
  export type BoostMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
    /**
     * Filter which BoostMetric to delete.
     */
    where: BoostMetricWhereUniqueInput
  }

  /**
   * BoostMetric deleteMany
   */
  export type BoostMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoostMetrics to delete
     */
    where?: BoostMetricWhereInput
    /**
     * Limit how many BoostMetrics to delete.
     */
    limit?: number
  }

  /**
   * BoostMetric without action
   */
  export type BoostMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoostMetric
     */
    select?: BoostMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoostMetric
     */
    omit?: BoostMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoostMetricInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    sizeMl: number | null
  }

  export type ProductSumAggregateOutputType = {
    sizeMl: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    unitType: string | null
    sizeMl: number | null
    upc: string | null
    isActive: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    unitType: string | null
    sizeMl: number | null
    upc: string | null
    isActive: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    category: number
    unitType: number
    sizeMl: number
    upc: number
    isActive: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    sizeMl?: true
  }

  export type ProductSumAggregateInputType = {
    sizeMl?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unitType?: true
    sizeMl?: true
    upc?: true
    isActive?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unitType?: true
    sizeMl?: true
    upc?: true
    isActive?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unitType?: true
    sizeMl?: true
    upc?: true
    isActive?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    category: string
    unitType: string
    sizeMl: number | null
    upc: string | null
    isActive: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unitType?: boolean
    sizeMl?: boolean
    upc?: boolean
    isActive?: boolean
    barProducts?: boolean | Product$barProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unitType?: boolean
    sizeMl?: boolean
    upc?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unitType?: boolean
    sizeMl?: boolean
    upc?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    unitType?: boolean
    sizeMl?: boolean
    upc?: boolean
    isActive?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "unitType" | "sizeMl" | "upc" | "isActive", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barProducts?: boolean | Product$barProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      barProducts: Prisma.$BarProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      unitType: string
      sizeMl: number | null
      upc: string | null
      isActive: boolean
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barProducts<T extends Product$barProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$barProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly unitType: FieldRef<"Product", 'String'>
    readonly sizeMl: FieldRef<"Product", 'Int'>
    readonly upc: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.barProducts
   */
  export type Product$barProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    where?: BarProductWhereInput
    orderBy?: BarProductOrderByWithRelationInput | BarProductOrderByWithRelationInput[]
    cursor?: BarProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarProductScalarFieldEnum | BarProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model BarProduct
   */

  export type AggregateBarProduct = {
    _count: BarProductCountAggregateOutputType | null
    _avg: BarProductAvgAggregateOutputType | null
    _sum: BarProductSumAggregateOutputType | null
    _min: BarProductMinAggregateOutputType | null
    _max: BarProductMaxAggregateOutputType | null
  }

  export type BarProductAvgAggregateOutputType = {
    parLevel: number | null
    reorderThreshold: number | null
  }

  export type BarProductSumAggregateOutputType = {
    parLevel: number | null
    reorderThreshold: number | null
  }

  export type BarProductMinAggregateOutputType = {
    id: string | null
    barId: string | null
    productId: string | null
    customName: string | null
    parLevel: number | null
    reorderThreshold: number | null
    preferredVendor: string | null
    isActive: boolean | null
  }

  export type BarProductMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    productId: string | null
    customName: string | null
    parLevel: number | null
    reorderThreshold: number | null
    preferredVendor: string | null
    isActive: boolean | null
  }

  export type BarProductCountAggregateOutputType = {
    id: number
    barId: number
    productId: number
    customName: number
    parLevel: number
    reorderThreshold: number
    preferredVendor: number
    isActive: number
    _all: number
  }


  export type BarProductAvgAggregateInputType = {
    parLevel?: true
    reorderThreshold?: true
  }

  export type BarProductSumAggregateInputType = {
    parLevel?: true
    reorderThreshold?: true
  }

  export type BarProductMinAggregateInputType = {
    id?: true
    barId?: true
    productId?: true
    customName?: true
    parLevel?: true
    reorderThreshold?: true
    preferredVendor?: true
    isActive?: true
  }

  export type BarProductMaxAggregateInputType = {
    id?: true
    barId?: true
    productId?: true
    customName?: true
    parLevel?: true
    reorderThreshold?: true
    preferredVendor?: true
    isActive?: true
  }

  export type BarProductCountAggregateInputType = {
    id?: true
    barId?: true
    productId?: true
    customName?: true
    parLevel?: true
    reorderThreshold?: true
    preferredVendor?: true
    isActive?: true
    _all?: true
  }

  export type BarProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarProduct to aggregate.
     */
    where?: BarProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarProducts to fetch.
     */
    orderBy?: BarProductOrderByWithRelationInput | BarProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarProducts
    **/
    _count?: true | BarProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarProductMaxAggregateInputType
  }

  export type GetBarProductAggregateType<T extends BarProductAggregateArgs> = {
        [P in keyof T & keyof AggregateBarProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarProduct[P]>
      : GetScalarType<T[P], AggregateBarProduct[P]>
  }




  export type BarProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarProductWhereInput
    orderBy?: BarProductOrderByWithAggregationInput | BarProductOrderByWithAggregationInput[]
    by: BarProductScalarFieldEnum[] | BarProductScalarFieldEnum
    having?: BarProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarProductCountAggregateInputType | true
    _avg?: BarProductAvgAggregateInputType
    _sum?: BarProductSumAggregateInputType
    _min?: BarProductMinAggregateInputType
    _max?: BarProductMaxAggregateInputType
  }

  export type BarProductGroupByOutputType = {
    id: string
    barId: string
    productId: string | null
    customName: string | null
    parLevel: number | null
    reorderThreshold: number | null
    preferredVendor: string | null
    isActive: boolean
    _count: BarProductCountAggregateOutputType | null
    _avg: BarProductAvgAggregateOutputType | null
    _sum: BarProductSumAggregateOutputType | null
    _min: BarProductMinAggregateOutputType | null
    _max: BarProductMaxAggregateOutputType | null
  }

  type GetBarProductGroupByPayload<T extends BarProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarProductGroupByOutputType[P]>
            : GetScalarType<T[P], BarProductGroupByOutputType[P]>
        }
      >
    >


  export type BarProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    productId?: boolean
    customName?: boolean
    parLevel?: boolean
    reorderThreshold?: boolean
    preferredVendor?: boolean
    isActive?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProduct$productArgs<ExtArgs>
    counts?: boolean | BarProduct$countsArgs<ExtArgs>
    detections?: boolean | BarProduct$detectionsArgs<ExtArgs>
    _count?: boolean | BarProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barProduct"]>

  export type BarProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    productId?: boolean
    customName?: boolean
    parLevel?: boolean
    reorderThreshold?: boolean
    preferredVendor?: boolean
    isActive?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProduct$productArgs<ExtArgs>
  }, ExtArgs["result"]["barProduct"]>

  export type BarProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    productId?: boolean
    customName?: boolean
    parLevel?: boolean
    reorderThreshold?: boolean
    preferredVendor?: boolean
    isActive?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProduct$productArgs<ExtArgs>
  }, ExtArgs["result"]["barProduct"]>

  export type BarProductSelectScalar = {
    id?: boolean
    barId?: boolean
    productId?: boolean
    customName?: boolean
    parLevel?: boolean
    reorderThreshold?: boolean
    preferredVendor?: boolean
    isActive?: boolean
  }

  export type BarProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "productId" | "customName" | "parLevel" | "reorderThreshold" | "preferredVendor" | "isActive", ExtArgs["result"]["barProduct"]>
  export type BarProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProduct$productArgs<ExtArgs>
    counts?: boolean | BarProduct$countsArgs<ExtArgs>
    detections?: boolean | BarProduct$detectionsArgs<ExtArgs>
    _count?: boolean | BarProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BarProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProduct$productArgs<ExtArgs>
  }
  export type BarProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProduct$productArgs<ExtArgs>
  }

  export type $BarProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarProduct"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      counts: Prisma.$InventoryCountPayload<ExtArgs>[]
      detections: Prisma.$InventoryScanDetectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      productId: string | null
      customName: string | null
      parLevel: number | null
      reorderThreshold: number | null
      preferredVendor: string | null
      isActive: boolean
    }, ExtArgs["result"]["barProduct"]>
    composites: {}
  }

  type BarProductGetPayload<S extends boolean | null | undefined | BarProductDefaultArgs> = $Result.GetResult<Prisma.$BarProductPayload, S>

  type BarProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarProductCountAggregateInputType | true
    }

  export interface BarProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarProduct'], meta: { name: 'BarProduct' } }
    /**
     * Find zero or one BarProduct that matches the filter.
     * @param {BarProductFindUniqueArgs} args - Arguments to find a BarProduct
     * @example
     * // Get one BarProduct
     * const barProduct = await prisma.barProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarProductFindUniqueArgs>(args: SelectSubset<T, BarProductFindUniqueArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarProductFindUniqueOrThrowArgs} args - Arguments to find a BarProduct
     * @example
     * // Get one BarProduct
     * const barProduct = await prisma.barProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarProductFindUniqueOrThrowArgs>(args: SelectSubset<T, BarProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductFindFirstArgs} args - Arguments to find a BarProduct
     * @example
     * // Get one BarProduct
     * const barProduct = await prisma.barProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarProductFindFirstArgs>(args?: SelectSubset<T, BarProductFindFirstArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductFindFirstOrThrowArgs} args - Arguments to find a BarProduct
     * @example
     * // Get one BarProduct
     * const barProduct = await prisma.barProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarProductFindFirstOrThrowArgs>(args?: SelectSubset<T, BarProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarProducts
     * const barProducts = await prisma.barProduct.findMany()
     * 
     * // Get first 10 BarProducts
     * const barProducts = await prisma.barProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barProductWithIdOnly = await prisma.barProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarProductFindManyArgs>(args?: SelectSubset<T, BarProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarProduct.
     * @param {BarProductCreateArgs} args - Arguments to create a BarProduct.
     * @example
     * // Create one BarProduct
     * const BarProduct = await prisma.barProduct.create({
     *   data: {
     *     // ... data to create a BarProduct
     *   }
     * })
     * 
     */
    create<T extends BarProductCreateArgs>(args: SelectSubset<T, BarProductCreateArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarProducts.
     * @param {BarProductCreateManyArgs} args - Arguments to create many BarProducts.
     * @example
     * // Create many BarProducts
     * const barProduct = await prisma.barProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarProductCreateManyArgs>(args?: SelectSubset<T, BarProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarProducts and returns the data saved in the database.
     * @param {BarProductCreateManyAndReturnArgs} args - Arguments to create many BarProducts.
     * @example
     * // Create many BarProducts
     * const barProduct = await prisma.barProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarProducts and only return the `id`
     * const barProductWithIdOnly = await prisma.barProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarProductCreateManyAndReturnArgs>(args?: SelectSubset<T, BarProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarProduct.
     * @param {BarProductDeleteArgs} args - Arguments to delete one BarProduct.
     * @example
     * // Delete one BarProduct
     * const BarProduct = await prisma.barProduct.delete({
     *   where: {
     *     // ... filter to delete one BarProduct
     *   }
     * })
     * 
     */
    delete<T extends BarProductDeleteArgs>(args: SelectSubset<T, BarProductDeleteArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarProduct.
     * @param {BarProductUpdateArgs} args - Arguments to update one BarProduct.
     * @example
     * // Update one BarProduct
     * const barProduct = await prisma.barProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarProductUpdateArgs>(args: SelectSubset<T, BarProductUpdateArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarProducts.
     * @param {BarProductDeleteManyArgs} args - Arguments to filter BarProducts to delete.
     * @example
     * // Delete a few BarProducts
     * const { count } = await prisma.barProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarProductDeleteManyArgs>(args?: SelectSubset<T, BarProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarProducts
     * const barProduct = await prisma.barProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarProductUpdateManyArgs>(args: SelectSubset<T, BarProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarProducts and returns the data updated in the database.
     * @param {BarProductUpdateManyAndReturnArgs} args - Arguments to update many BarProducts.
     * @example
     * // Update many BarProducts
     * const barProduct = await prisma.barProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarProducts and only return the `id`
     * const barProductWithIdOnly = await prisma.barProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarProductUpdateManyAndReturnArgs>(args: SelectSubset<T, BarProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarProduct.
     * @param {BarProductUpsertArgs} args - Arguments to update or create a BarProduct.
     * @example
     * // Update or create a BarProduct
     * const barProduct = await prisma.barProduct.upsert({
     *   create: {
     *     // ... data to create a BarProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarProduct we want to update
     *   }
     * })
     */
    upsert<T extends BarProductUpsertArgs>(args: SelectSubset<T, BarProductUpsertArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductCountArgs} args - Arguments to filter BarProducts to count.
     * @example
     * // Count the number of BarProducts
     * const count = await prisma.barProduct.count({
     *   where: {
     *     // ... the filter for the BarProducts we want to count
     *   }
     * })
    **/
    count<T extends BarProductCountArgs>(
      args?: Subset<T, BarProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarProductAggregateArgs>(args: Subset<T, BarProductAggregateArgs>): Prisma.PrismaPromise<GetBarProductAggregateType<T>>

    /**
     * Group by BarProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarProductGroupByArgs['orderBy'] }
        : { orderBy?: BarProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarProduct model
   */
  readonly fields: BarProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends BarProduct$productArgs<ExtArgs> = {}>(args?: Subset<T, BarProduct$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    counts<T extends BarProduct$countsArgs<ExtArgs> = {}>(args?: Subset<T, BarProduct$countsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    detections<T extends BarProduct$detectionsArgs<ExtArgs> = {}>(args?: Subset<T, BarProduct$detectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarProduct model
   */
  interface BarProductFieldRefs {
    readonly id: FieldRef<"BarProduct", 'String'>
    readonly barId: FieldRef<"BarProduct", 'String'>
    readonly productId: FieldRef<"BarProduct", 'String'>
    readonly customName: FieldRef<"BarProduct", 'String'>
    readonly parLevel: FieldRef<"BarProduct", 'Int'>
    readonly reorderThreshold: FieldRef<"BarProduct", 'Int'>
    readonly preferredVendor: FieldRef<"BarProduct", 'String'>
    readonly isActive: FieldRef<"BarProduct", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BarProduct findUnique
   */
  export type BarProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * Filter, which BarProduct to fetch.
     */
    where: BarProductWhereUniqueInput
  }

  /**
   * BarProduct findUniqueOrThrow
   */
  export type BarProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * Filter, which BarProduct to fetch.
     */
    where: BarProductWhereUniqueInput
  }

  /**
   * BarProduct findFirst
   */
  export type BarProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * Filter, which BarProduct to fetch.
     */
    where?: BarProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarProducts to fetch.
     */
    orderBy?: BarProductOrderByWithRelationInput | BarProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarProducts.
     */
    cursor?: BarProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarProducts.
     */
    distinct?: BarProductScalarFieldEnum | BarProductScalarFieldEnum[]
  }

  /**
   * BarProduct findFirstOrThrow
   */
  export type BarProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * Filter, which BarProduct to fetch.
     */
    where?: BarProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarProducts to fetch.
     */
    orderBy?: BarProductOrderByWithRelationInput | BarProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarProducts.
     */
    cursor?: BarProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarProducts.
     */
    distinct?: BarProductScalarFieldEnum | BarProductScalarFieldEnum[]
  }

  /**
   * BarProduct findMany
   */
  export type BarProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * Filter, which BarProducts to fetch.
     */
    where?: BarProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarProducts to fetch.
     */
    orderBy?: BarProductOrderByWithRelationInput | BarProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarProducts.
     */
    cursor?: BarProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarProducts.
     */
    skip?: number
    distinct?: BarProductScalarFieldEnum | BarProductScalarFieldEnum[]
  }

  /**
   * BarProduct create
   */
  export type BarProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * The data needed to create a BarProduct.
     */
    data: XOR<BarProductCreateInput, BarProductUncheckedCreateInput>
  }

  /**
   * BarProduct createMany
   */
  export type BarProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarProducts.
     */
    data: BarProductCreateManyInput | BarProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarProduct createManyAndReturn
   */
  export type BarProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * The data used to create many BarProducts.
     */
    data: BarProductCreateManyInput | BarProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarProduct update
   */
  export type BarProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * The data needed to update a BarProduct.
     */
    data: XOR<BarProductUpdateInput, BarProductUncheckedUpdateInput>
    /**
     * Choose, which BarProduct to update.
     */
    where: BarProductWhereUniqueInput
  }

  /**
   * BarProduct updateMany
   */
  export type BarProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarProducts.
     */
    data: XOR<BarProductUpdateManyMutationInput, BarProductUncheckedUpdateManyInput>
    /**
     * Filter which BarProducts to update
     */
    where?: BarProductWhereInput
    /**
     * Limit how many BarProducts to update.
     */
    limit?: number
  }

  /**
   * BarProduct updateManyAndReturn
   */
  export type BarProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * The data used to update BarProducts.
     */
    data: XOR<BarProductUpdateManyMutationInput, BarProductUncheckedUpdateManyInput>
    /**
     * Filter which BarProducts to update
     */
    where?: BarProductWhereInput
    /**
     * Limit how many BarProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarProduct upsert
   */
  export type BarProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * The filter to search for the BarProduct to update in case it exists.
     */
    where: BarProductWhereUniqueInput
    /**
     * In case the BarProduct found by the `where` argument doesn't exist, create a new BarProduct with this data.
     */
    create: XOR<BarProductCreateInput, BarProductUncheckedCreateInput>
    /**
     * In case the BarProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarProductUpdateInput, BarProductUncheckedUpdateInput>
  }

  /**
   * BarProduct delete
   */
  export type BarProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    /**
     * Filter which BarProduct to delete.
     */
    where: BarProductWhereUniqueInput
  }

  /**
   * BarProduct deleteMany
   */
  export type BarProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarProducts to delete
     */
    where?: BarProductWhereInput
    /**
     * Limit how many BarProducts to delete.
     */
    limit?: number
  }

  /**
   * BarProduct.product
   */
  export type BarProduct$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * BarProduct.counts
   */
  export type BarProduct$countsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    where?: InventoryCountWhereInput
    orderBy?: InventoryCountOrderByWithRelationInput | InventoryCountOrderByWithRelationInput[]
    cursor?: InventoryCountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryCountScalarFieldEnum | InventoryCountScalarFieldEnum[]
  }

  /**
   * BarProduct.detections
   */
  export type BarProduct$detectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    where?: InventoryScanDetectionWhereInput
    orderBy?: InventoryScanDetectionOrderByWithRelationInput | InventoryScanDetectionOrderByWithRelationInput[]
    cursor?: InventoryScanDetectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScanDetectionScalarFieldEnum | InventoryScanDetectionScalarFieldEnum[]
  }

  /**
   * BarProduct without action
   */
  export type BarProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
  }


  /**
   * Model InventoryScanSession
   */

  export type AggregateInventoryScanSession = {
    _count: InventoryScanSessionCountAggregateOutputType | null
    _min: InventoryScanSessionMinAggregateOutputType | null
    _max: InventoryScanSessionMaxAggregateOutputType | null
  }

  export type InventoryScanSessionMinAggregateOutputType = {
    id: string | null
    barId: string | null
    createdByUserId: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type InventoryScanSessionMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    createdByUserId: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type InventoryScanSessionCountAggregateOutputType = {
    id: number
    barId: number
    createdByUserId: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type InventoryScanSessionMinAggregateInputType = {
    id?: true
    barId?: true
    createdByUserId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type InventoryScanSessionMaxAggregateInputType = {
    id?: true
    barId?: true
    createdByUserId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type InventoryScanSessionCountAggregateInputType = {
    id?: true
    barId?: true
    createdByUserId?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryScanSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryScanSession to aggregate.
     */
    where?: InventoryScanSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanSessions to fetch.
     */
    orderBy?: InventoryScanSessionOrderByWithRelationInput | InventoryScanSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryScanSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryScanSessions
    **/
    _count?: true | InventoryScanSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryScanSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryScanSessionMaxAggregateInputType
  }

  export type GetInventoryScanSessionAggregateType<T extends InventoryScanSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryScanSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryScanSession[P]>
      : GetScalarType<T[P], AggregateInventoryScanSession[P]>
  }




  export type InventoryScanSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryScanSessionWhereInput
    orderBy?: InventoryScanSessionOrderByWithAggregationInput | InventoryScanSessionOrderByWithAggregationInput[]
    by: InventoryScanSessionScalarFieldEnum[] | InventoryScanSessionScalarFieldEnum
    having?: InventoryScanSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryScanSessionCountAggregateInputType | true
    _min?: InventoryScanSessionMinAggregateInputType
    _max?: InventoryScanSessionMaxAggregateInputType
  }

  export type InventoryScanSessionGroupByOutputType = {
    id: string
    barId: string
    createdByUserId: string | null
    imageUrl: string | null
    createdAt: Date
    _count: InventoryScanSessionCountAggregateOutputType | null
    _min: InventoryScanSessionMinAggregateOutputType | null
    _max: InventoryScanSessionMaxAggregateOutputType | null
  }

  type GetInventoryScanSessionGroupByPayload<T extends InventoryScanSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryScanSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryScanSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryScanSessionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryScanSessionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryScanSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    createdByUserId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    detections?: boolean | InventoryScanSession$detectionsArgs<ExtArgs>
    _count?: boolean | InventoryScanSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryScanSession"]>

  export type InventoryScanSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    createdByUserId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryScanSession"]>

  export type InventoryScanSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    createdByUserId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryScanSession"]>

  export type InventoryScanSessionSelectScalar = {
    id?: boolean
    barId?: boolean
    createdByUserId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type InventoryScanSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "createdByUserId" | "imageUrl" | "createdAt", ExtArgs["result"]["inventoryScanSession"]>
  export type InventoryScanSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    detections?: boolean | InventoryScanSession$detectionsArgs<ExtArgs>
    _count?: boolean | InventoryScanSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryScanSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type InventoryScanSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $InventoryScanSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryScanSession"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      detections: Prisma.$InventoryScanDetectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      createdByUserId: string | null
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryScanSession"]>
    composites: {}
  }

  type InventoryScanSessionGetPayload<S extends boolean | null | undefined | InventoryScanSessionDefaultArgs> = $Result.GetResult<Prisma.$InventoryScanSessionPayload, S>

  type InventoryScanSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryScanSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryScanSessionCountAggregateInputType | true
    }

  export interface InventoryScanSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryScanSession'], meta: { name: 'InventoryScanSession' } }
    /**
     * Find zero or one InventoryScanSession that matches the filter.
     * @param {InventoryScanSessionFindUniqueArgs} args - Arguments to find a InventoryScanSession
     * @example
     * // Get one InventoryScanSession
     * const inventoryScanSession = await prisma.inventoryScanSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryScanSessionFindUniqueArgs>(args: SelectSubset<T, InventoryScanSessionFindUniqueArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryScanSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryScanSessionFindUniqueOrThrowArgs} args - Arguments to find a InventoryScanSession
     * @example
     * // Get one InventoryScanSession
     * const inventoryScanSession = await prisma.inventoryScanSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryScanSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryScanSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryScanSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionFindFirstArgs} args - Arguments to find a InventoryScanSession
     * @example
     * // Get one InventoryScanSession
     * const inventoryScanSession = await prisma.inventoryScanSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryScanSessionFindFirstArgs>(args?: SelectSubset<T, InventoryScanSessionFindFirstArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryScanSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionFindFirstOrThrowArgs} args - Arguments to find a InventoryScanSession
     * @example
     * // Get one InventoryScanSession
     * const inventoryScanSession = await prisma.inventoryScanSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryScanSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryScanSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryScanSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryScanSessions
     * const inventoryScanSessions = await prisma.inventoryScanSession.findMany()
     * 
     * // Get first 10 InventoryScanSessions
     * const inventoryScanSessions = await prisma.inventoryScanSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryScanSessionWithIdOnly = await prisma.inventoryScanSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryScanSessionFindManyArgs>(args?: SelectSubset<T, InventoryScanSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryScanSession.
     * @param {InventoryScanSessionCreateArgs} args - Arguments to create a InventoryScanSession.
     * @example
     * // Create one InventoryScanSession
     * const InventoryScanSession = await prisma.inventoryScanSession.create({
     *   data: {
     *     // ... data to create a InventoryScanSession
     *   }
     * })
     * 
     */
    create<T extends InventoryScanSessionCreateArgs>(args: SelectSubset<T, InventoryScanSessionCreateArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryScanSessions.
     * @param {InventoryScanSessionCreateManyArgs} args - Arguments to create many InventoryScanSessions.
     * @example
     * // Create many InventoryScanSessions
     * const inventoryScanSession = await prisma.inventoryScanSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryScanSessionCreateManyArgs>(args?: SelectSubset<T, InventoryScanSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryScanSessions and returns the data saved in the database.
     * @param {InventoryScanSessionCreateManyAndReturnArgs} args - Arguments to create many InventoryScanSessions.
     * @example
     * // Create many InventoryScanSessions
     * const inventoryScanSession = await prisma.inventoryScanSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryScanSessions and only return the `id`
     * const inventoryScanSessionWithIdOnly = await prisma.inventoryScanSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryScanSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryScanSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryScanSession.
     * @param {InventoryScanSessionDeleteArgs} args - Arguments to delete one InventoryScanSession.
     * @example
     * // Delete one InventoryScanSession
     * const InventoryScanSession = await prisma.inventoryScanSession.delete({
     *   where: {
     *     // ... filter to delete one InventoryScanSession
     *   }
     * })
     * 
     */
    delete<T extends InventoryScanSessionDeleteArgs>(args: SelectSubset<T, InventoryScanSessionDeleteArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryScanSession.
     * @param {InventoryScanSessionUpdateArgs} args - Arguments to update one InventoryScanSession.
     * @example
     * // Update one InventoryScanSession
     * const inventoryScanSession = await prisma.inventoryScanSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryScanSessionUpdateArgs>(args: SelectSubset<T, InventoryScanSessionUpdateArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryScanSessions.
     * @param {InventoryScanSessionDeleteManyArgs} args - Arguments to filter InventoryScanSessions to delete.
     * @example
     * // Delete a few InventoryScanSessions
     * const { count } = await prisma.inventoryScanSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryScanSessionDeleteManyArgs>(args?: SelectSubset<T, InventoryScanSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryScanSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryScanSessions
     * const inventoryScanSession = await prisma.inventoryScanSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryScanSessionUpdateManyArgs>(args: SelectSubset<T, InventoryScanSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryScanSessions and returns the data updated in the database.
     * @param {InventoryScanSessionUpdateManyAndReturnArgs} args - Arguments to update many InventoryScanSessions.
     * @example
     * // Update many InventoryScanSessions
     * const inventoryScanSession = await prisma.inventoryScanSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryScanSessions and only return the `id`
     * const inventoryScanSessionWithIdOnly = await prisma.inventoryScanSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryScanSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryScanSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryScanSession.
     * @param {InventoryScanSessionUpsertArgs} args - Arguments to update or create a InventoryScanSession.
     * @example
     * // Update or create a InventoryScanSession
     * const inventoryScanSession = await prisma.inventoryScanSession.upsert({
     *   create: {
     *     // ... data to create a InventoryScanSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryScanSession we want to update
     *   }
     * })
     */
    upsert<T extends InventoryScanSessionUpsertArgs>(args: SelectSubset<T, InventoryScanSessionUpsertArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryScanSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionCountArgs} args - Arguments to filter InventoryScanSessions to count.
     * @example
     * // Count the number of InventoryScanSessions
     * const count = await prisma.inventoryScanSession.count({
     *   where: {
     *     // ... the filter for the InventoryScanSessions we want to count
     *   }
     * })
    **/
    count<T extends InventoryScanSessionCountArgs>(
      args?: Subset<T, InventoryScanSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryScanSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryScanSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryScanSessionAggregateArgs>(args: Subset<T, InventoryScanSessionAggregateArgs>): Prisma.PrismaPromise<GetInventoryScanSessionAggregateType<T>>

    /**
     * Group by InventoryScanSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryScanSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryScanSessionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryScanSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryScanSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryScanSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryScanSession model
   */
  readonly fields: InventoryScanSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryScanSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryScanSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detections<T extends InventoryScanSession$detectionsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryScanSession$detectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryScanSession model
   */
  interface InventoryScanSessionFieldRefs {
    readonly id: FieldRef<"InventoryScanSession", 'String'>
    readonly barId: FieldRef<"InventoryScanSession", 'String'>
    readonly createdByUserId: FieldRef<"InventoryScanSession", 'String'>
    readonly imageUrl: FieldRef<"InventoryScanSession", 'String'>
    readonly createdAt: FieldRef<"InventoryScanSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryScanSession findUnique
   */
  export type InventoryScanSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanSession to fetch.
     */
    where: InventoryScanSessionWhereUniqueInput
  }

  /**
   * InventoryScanSession findUniqueOrThrow
   */
  export type InventoryScanSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanSession to fetch.
     */
    where: InventoryScanSessionWhereUniqueInput
  }

  /**
   * InventoryScanSession findFirst
   */
  export type InventoryScanSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanSession to fetch.
     */
    where?: InventoryScanSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanSessions to fetch.
     */
    orderBy?: InventoryScanSessionOrderByWithRelationInput | InventoryScanSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryScanSessions.
     */
    cursor?: InventoryScanSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryScanSessions.
     */
    distinct?: InventoryScanSessionScalarFieldEnum | InventoryScanSessionScalarFieldEnum[]
  }

  /**
   * InventoryScanSession findFirstOrThrow
   */
  export type InventoryScanSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanSession to fetch.
     */
    where?: InventoryScanSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanSessions to fetch.
     */
    orderBy?: InventoryScanSessionOrderByWithRelationInput | InventoryScanSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryScanSessions.
     */
    cursor?: InventoryScanSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryScanSessions.
     */
    distinct?: InventoryScanSessionScalarFieldEnum | InventoryScanSessionScalarFieldEnum[]
  }

  /**
   * InventoryScanSession findMany
   */
  export type InventoryScanSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanSessions to fetch.
     */
    where?: InventoryScanSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanSessions to fetch.
     */
    orderBy?: InventoryScanSessionOrderByWithRelationInput | InventoryScanSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryScanSessions.
     */
    cursor?: InventoryScanSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanSessions.
     */
    skip?: number
    distinct?: InventoryScanSessionScalarFieldEnum | InventoryScanSessionScalarFieldEnum[]
  }

  /**
   * InventoryScanSession create
   */
  export type InventoryScanSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryScanSession.
     */
    data: XOR<InventoryScanSessionCreateInput, InventoryScanSessionUncheckedCreateInput>
  }

  /**
   * InventoryScanSession createMany
   */
  export type InventoryScanSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryScanSessions.
     */
    data: InventoryScanSessionCreateManyInput | InventoryScanSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryScanSession createManyAndReturn
   */
  export type InventoryScanSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryScanSessions.
     */
    data: InventoryScanSessionCreateManyInput | InventoryScanSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryScanSession update
   */
  export type InventoryScanSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryScanSession.
     */
    data: XOR<InventoryScanSessionUpdateInput, InventoryScanSessionUncheckedUpdateInput>
    /**
     * Choose, which InventoryScanSession to update.
     */
    where: InventoryScanSessionWhereUniqueInput
  }

  /**
   * InventoryScanSession updateMany
   */
  export type InventoryScanSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryScanSessions.
     */
    data: XOR<InventoryScanSessionUpdateManyMutationInput, InventoryScanSessionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryScanSessions to update
     */
    where?: InventoryScanSessionWhereInput
    /**
     * Limit how many InventoryScanSessions to update.
     */
    limit?: number
  }

  /**
   * InventoryScanSession updateManyAndReturn
   */
  export type InventoryScanSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * The data used to update InventoryScanSessions.
     */
    data: XOR<InventoryScanSessionUpdateManyMutationInput, InventoryScanSessionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryScanSessions to update
     */
    where?: InventoryScanSessionWhereInput
    /**
     * Limit how many InventoryScanSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryScanSession upsert
   */
  export type InventoryScanSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryScanSession to update in case it exists.
     */
    where: InventoryScanSessionWhereUniqueInput
    /**
     * In case the InventoryScanSession found by the `where` argument doesn't exist, create a new InventoryScanSession with this data.
     */
    create: XOR<InventoryScanSessionCreateInput, InventoryScanSessionUncheckedCreateInput>
    /**
     * In case the InventoryScanSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryScanSessionUpdateInput, InventoryScanSessionUncheckedUpdateInput>
  }

  /**
   * InventoryScanSession delete
   */
  export type InventoryScanSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
    /**
     * Filter which InventoryScanSession to delete.
     */
    where: InventoryScanSessionWhereUniqueInput
  }

  /**
   * InventoryScanSession deleteMany
   */
  export type InventoryScanSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryScanSessions to delete
     */
    where?: InventoryScanSessionWhereInput
    /**
     * Limit how many InventoryScanSessions to delete.
     */
    limit?: number
  }

  /**
   * InventoryScanSession.detections
   */
  export type InventoryScanSession$detectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    where?: InventoryScanDetectionWhereInput
    orderBy?: InventoryScanDetectionOrderByWithRelationInput | InventoryScanDetectionOrderByWithRelationInput[]
    cursor?: InventoryScanDetectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScanDetectionScalarFieldEnum | InventoryScanDetectionScalarFieldEnum[]
  }

  /**
   * InventoryScanSession without action
   */
  export type InventoryScanSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanSession
     */
    select?: InventoryScanSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanSession
     */
    omit?: InventoryScanSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanSessionInclude<ExtArgs> | null
  }


  /**
   * Model InventoryScanDetection
   */

  export type AggregateInventoryScanDetection = {
    _count: InventoryScanDetectionCountAggregateOutputType | null
    _avg: InventoryScanDetectionAvgAggregateOutputType | null
    _sum: InventoryScanDetectionSumAggregateOutputType | null
    _min: InventoryScanDetectionMinAggregateOutputType | null
    _max: InventoryScanDetectionMaxAggregateOutputType | null
  }

  export type InventoryScanDetectionAvgAggregateOutputType = {
    confidence: number | null
    sizeMlGuess: number | null
  }

  export type InventoryScanDetectionSumAggregateOutputType = {
    confidence: number | null
    sizeMlGuess: number | null
  }

  export type InventoryScanDetectionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    productGuessText: string | null
    productId: string | null
    confidence: number | null
    remainingBucket: string | null
    sizeMlGuess: number | null
  }

  export type InventoryScanDetectionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    productGuessText: string | null
    productId: string | null
    confidence: number | null
    remainingBucket: string | null
    sizeMlGuess: number | null
  }

  export type InventoryScanDetectionCountAggregateOutputType = {
    id: number
    sessionId: number
    productGuessText: number
    productId: number
    bbox: number
    confidence: number
    remainingBucket: number
    sizeMlGuess: number
    _all: number
  }


  export type InventoryScanDetectionAvgAggregateInputType = {
    confidence?: true
    sizeMlGuess?: true
  }

  export type InventoryScanDetectionSumAggregateInputType = {
    confidence?: true
    sizeMlGuess?: true
  }

  export type InventoryScanDetectionMinAggregateInputType = {
    id?: true
    sessionId?: true
    productGuessText?: true
    productId?: true
    confidence?: true
    remainingBucket?: true
    sizeMlGuess?: true
  }

  export type InventoryScanDetectionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    productGuessText?: true
    productId?: true
    confidence?: true
    remainingBucket?: true
    sizeMlGuess?: true
  }

  export type InventoryScanDetectionCountAggregateInputType = {
    id?: true
    sessionId?: true
    productGuessText?: true
    productId?: true
    bbox?: true
    confidence?: true
    remainingBucket?: true
    sizeMlGuess?: true
    _all?: true
  }

  export type InventoryScanDetectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryScanDetection to aggregate.
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanDetections to fetch.
     */
    orderBy?: InventoryScanDetectionOrderByWithRelationInput | InventoryScanDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryScanDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryScanDetections
    **/
    _count?: true | InventoryScanDetectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryScanDetectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryScanDetectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryScanDetectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryScanDetectionMaxAggregateInputType
  }

  export type GetInventoryScanDetectionAggregateType<T extends InventoryScanDetectionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryScanDetection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryScanDetection[P]>
      : GetScalarType<T[P], AggregateInventoryScanDetection[P]>
  }




  export type InventoryScanDetectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryScanDetectionWhereInput
    orderBy?: InventoryScanDetectionOrderByWithAggregationInput | InventoryScanDetectionOrderByWithAggregationInput[]
    by: InventoryScanDetectionScalarFieldEnum[] | InventoryScanDetectionScalarFieldEnum
    having?: InventoryScanDetectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryScanDetectionCountAggregateInputType | true
    _avg?: InventoryScanDetectionAvgAggregateInputType
    _sum?: InventoryScanDetectionSumAggregateInputType
    _min?: InventoryScanDetectionMinAggregateInputType
    _max?: InventoryScanDetectionMaxAggregateInputType
  }

  export type InventoryScanDetectionGroupByOutputType = {
    id: string
    sessionId: string
    productGuessText: string
    productId: string | null
    bbox: JsonValue | null
    confidence: number
    remainingBucket: string | null
    sizeMlGuess: number | null
    _count: InventoryScanDetectionCountAggregateOutputType | null
    _avg: InventoryScanDetectionAvgAggregateOutputType | null
    _sum: InventoryScanDetectionSumAggregateOutputType | null
    _min: InventoryScanDetectionMinAggregateOutputType | null
    _max: InventoryScanDetectionMaxAggregateOutputType | null
  }

  type GetInventoryScanDetectionGroupByPayload<T extends InventoryScanDetectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryScanDetectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryScanDetectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryScanDetectionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryScanDetectionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryScanDetectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    productGuessText?: boolean
    productId?: boolean
    bbox?: boolean
    confidence?: boolean
    remainingBucket?: boolean
    sizeMlGuess?: boolean
    session?: boolean | InventoryScanSessionDefaultArgs<ExtArgs>
    product?: boolean | InventoryScanDetection$productArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryScanDetection"]>

  export type InventoryScanDetectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    productGuessText?: boolean
    productId?: boolean
    bbox?: boolean
    confidence?: boolean
    remainingBucket?: boolean
    sizeMlGuess?: boolean
    session?: boolean | InventoryScanSessionDefaultArgs<ExtArgs>
    product?: boolean | InventoryScanDetection$productArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryScanDetection"]>

  export type InventoryScanDetectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    productGuessText?: boolean
    productId?: boolean
    bbox?: boolean
    confidence?: boolean
    remainingBucket?: boolean
    sizeMlGuess?: boolean
    session?: boolean | InventoryScanSessionDefaultArgs<ExtArgs>
    product?: boolean | InventoryScanDetection$productArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryScanDetection"]>

  export type InventoryScanDetectionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    productGuessText?: boolean
    productId?: boolean
    bbox?: boolean
    confidence?: boolean
    remainingBucket?: boolean
    sizeMlGuess?: boolean
  }

  export type InventoryScanDetectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "productGuessText" | "productId" | "bbox" | "confidence" | "remainingBucket" | "sizeMlGuess", ExtArgs["result"]["inventoryScanDetection"]>
  export type InventoryScanDetectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InventoryScanSessionDefaultArgs<ExtArgs>
    product?: boolean | InventoryScanDetection$productArgs<ExtArgs>
  }
  export type InventoryScanDetectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InventoryScanSessionDefaultArgs<ExtArgs>
    product?: boolean | InventoryScanDetection$productArgs<ExtArgs>
  }
  export type InventoryScanDetectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InventoryScanSessionDefaultArgs<ExtArgs>
    product?: boolean | InventoryScanDetection$productArgs<ExtArgs>
  }

  export type $InventoryScanDetectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryScanDetection"
    objects: {
      session: Prisma.$InventoryScanSessionPayload<ExtArgs>
      product: Prisma.$BarProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      productGuessText: string
      productId: string | null
      bbox: Prisma.JsonValue | null
      confidence: number
      remainingBucket: string | null
      sizeMlGuess: number | null
    }, ExtArgs["result"]["inventoryScanDetection"]>
    composites: {}
  }

  type InventoryScanDetectionGetPayload<S extends boolean | null | undefined | InventoryScanDetectionDefaultArgs> = $Result.GetResult<Prisma.$InventoryScanDetectionPayload, S>

  type InventoryScanDetectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryScanDetectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryScanDetectionCountAggregateInputType | true
    }

  export interface InventoryScanDetectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryScanDetection'], meta: { name: 'InventoryScanDetection' } }
    /**
     * Find zero or one InventoryScanDetection that matches the filter.
     * @param {InventoryScanDetectionFindUniqueArgs} args - Arguments to find a InventoryScanDetection
     * @example
     * // Get one InventoryScanDetection
     * const inventoryScanDetection = await prisma.inventoryScanDetection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryScanDetectionFindUniqueArgs>(args: SelectSubset<T, InventoryScanDetectionFindUniqueArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryScanDetection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryScanDetectionFindUniqueOrThrowArgs} args - Arguments to find a InventoryScanDetection
     * @example
     * // Get one InventoryScanDetection
     * const inventoryScanDetection = await prisma.inventoryScanDetection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryScanDetectionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryScanDetectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryScanDetection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionFindFirstArgs} args - Arguments to find a InventoryScanDetection
     * @example
     * // Get one InventoryScanDetection
     * const inventoryScanDetection = await prisma.inventoryScanDetection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryScanDetectionFindFirstArgs>(args?: SelectSubset<T, InventoryScanDetectionFindFirstArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryScanDetection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionFindFirstOrThrowArgs} args - Arguments to find a InventoryScanDetection
     * @example
     * // Get one InventoryScanDetection
     * const inventoryScanDetection = await prisma.inventoryScanDetection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryScanDetectionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryScanDetectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryScanDetections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryScanDetections
     * const inventoryScanDetections = await prisma.inventoryScanDetection.findMany()
     * 
     * // Get first 10 InventoryScanDetections
     * const inventoryScanDetections = await prisma.inventoryScanDetection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryScanDetectionWithIdOnly = await prisma.inventoryScanDetection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryScanDetectionFindManyArgs>(args?: SelectSubset<T, InventoryScanDetectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryScanDetection.
     * @param {InventoryScanDetectionCreateArgs} args - Arguments to create a InventoryScanDetection.
     * @example
     * // Create one InventoryScanDetection
     * const InventoryScanDetection = await prisma.inventoryScanDetection.create({
     *   data: {
     *     // ... data to create a InventoryScanDetection
     *   }
     * })
     * 
     */
    create<T extends InventoryScanDetectionCreateArgs>(args: SelectSubset<T, InventoryScanDetectionCreateArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryScanDetections.
     * @param {InventoryScanDetectionCreateManyArgs} args - Arguments to create many InventoryScanDetections.
     * @example
     * // Create many InventoryScanDetections
     * const inventoryScanDetection = await prisma.inventoryScanDetection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryScanDetectionCreateManyArgs>(args?: SelectSubset<T, InventoryScanDetectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryScanDetections and returns the data saved in the database.
     * @param {InventoryScanDetectionCreateManyAndReturnArgs} args - Arguments to create many InventoryScanDetections.
     * @example
     * // Create many InventoryScanDetections
     * const inventoryScanDetection = await prisma.inventoryScanDetection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryScanDetections and only return the `id`
     * const inventoryScanDetectionWithIdOnly = await prisma.inventoryScanDetection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryScanDetectionCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryScanDetectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryScanDetection.
     * @param {InventoryScanDetectionDeleteArgs} args - Arguments to delete one InventoryScanDetection.
     * @example
     * // Delete one InventoryScanDetection
     * const InventoryScanDetection = await prisma.inventoryScanDetection.delete({
     *   where: {
     *     // ... filter to delete one InventoryScanDetection
     *   }
     * })
     * 
     */
    delete<T extends InventoryScanDetectionDeleteArgs>(args: SelectSubset<T, InventoryScanDetectionDeleteArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryScanDetection.
     * @param {InventoryScanDetectionUpdateArgs} args - Arguments to update one InventoryScanDetection.
     * @example
     * // Update one InventoryScanDetection
     * const inventoryScanDetection = await prisma.inventoryScanDetection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryScanDetectionUpdateArgs>(args: SelectSubset<T, InventoryScanDetectionUpdateArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryScanDetections.
     * @param {InventoryScanDetectionDeleteManyArgs} args - Arguments to filter InventoryScanDetections to delete.
     * @example
     * // Delete a few InventoryScanDetections
     * const { count } = await prisma.inventoryScanDetection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryScanDetectionDeleteManyArgs>(args?: SelectSubset<T, InventoryScanDetectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryScanDetections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryScanDetections
     * const inventoryScanDetection = await prisma.inventoryScanDetection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryScanDetectionUpdateManyArgs>(args: SelectSubset<T, InventoryScanDetectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryScanDetections and returns the data updated in the database.
     * @param {InventoryScanDetectionUpdateManyAndReturnArgs} args - Arguments to update many InventoryScanDetections.
     * @example
     * // Update many InventoryScanDetections
     * const inventoryScanDetection = await prisma.inventoryScanDetection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryScanDetections and only return the `id`
     * const inventoryScanDetectionWithIdOnly = await prisma.inventoryScanDetection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryScanDetectionUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryScanDetectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryScanDetection.
     * @param {InventoryScanDetectionUpsertArgs} args - Arguments to update or create a InventoryScanDetection.
     * @example
     * // Update or create a InventoryScanDetection
     * const inventoryScanDetection = await prisma.inventoryScanDetection.upsert({
     *   create: {
     *     // ... data to create a InventoryScanDetection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryScanDetection we want to update
     *   }
     * })
     */
    upsert<T extends InventoryScanDetectionUpsertArgs>(args: SelectSubset<T, InventoryScanDetectionUpsertArgs<ExtArgs>>): Prisma__InventoryScanDetectionClient<$Result.GetResult<Prisma.$InventoryScanDetectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryScanDetections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionCountArgs} args - Arguments to filter InventoryScanDetections to count.
     * @example
     * // Count the number of InventoryScanDetections
     * const count = await prisma.inventoryScanDetection.count({
     *   where: {
     *     // ... the filter for the InventoryScanDetections we want to count
     *   }
     * })
    **/
    count<T extends InventoryScanDetectionCountArgs>(
      args?: Subset<T, InventoryScanDetectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryScanDetectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryScanDetection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryScanDetectionAggregateArgs>(args: Subset<T, InventoryScanDetectionAggregateArgs>): Prisma.PrismaPromise<GetInventoryScanDetectionAggregateType<T>>

    /**
     * Group by InventoryScanDetection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryScanDetectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryScanDetectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryScanDetectionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryScanDetectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryScanDetectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryScanDetectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryScanDetection model
   */
  readonly fields: InventoryScanDetectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryScanDetection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryScanDetectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends InventoryScanSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryScanSessionDefaultArgs<ExtArgs>>): Prisma__InventoryScanSessionClient<$Result.GetResult<Prisma.$InventoryScanSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends InventoryScanDetection$productArgs<ExtArgs> = {}>(args?: Subset<T, InventoryScanDetection$productArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryScanDetection model
   */
  interface InventoryScanDetectionFieldRefs {
    readonly id: FieldRef<"InventoryScanDetection", 'String'>
    readonly sessionId: FieldRef<"InventoryScanDetection", 'String'>
    readonly productGuessText: FieldRef<"InventoryScanDetection", 'String'>
    readonly productId: FieldRef<"InventoryScanDetection", 'String'>
    readonly bbox: FieldRef<"InventoryScanDetection", 'Json'>
    readonly confidence: FieldRef<"InventoryScanDetection", 'Float'>
    readonly remainingBucket: FieldRef<"InventoryScanDetection", 'String'>
    readonly sizeMlGuess: FieldRef<"InventoryScanDetection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InventoryScanDetection findUnique
   */
  export type InventoryScanDetectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanDetection to fetch.
     */
    where: InventoryScanDetectionWhereUniqueInput
  }

  /**
   * InventoryScanDetection findUniqueOrThrow
   */
  export type InventoryScanDetectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanDetection to fetch.
     */
    where: InventoryScanDetectionWhereUniqueInput
  }

  /**
   * InventoryScanDetection findFirst
   */
  export type InventoryScanDetectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanDetection to fetch.
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanDetections to fetch.
     */
    orderBy?: InventoryScanDetectionOrderByWithRelationInput | InventoryScanDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryScanDetections.
     */
    cursor?: InventoryScanDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryScanDetections.
     */
    distinct?: InventoryScanDetectionScalarFieldEnum | InventoryScanDetectionScalarFieldEnum[]
  }

  /**
   * InventoryScanDetection findFirstOrThrow
   */
  export type InventoryScanDetectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanDetection to fetch.
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanDetections to fetch.
     */
    orderBy?: InventoryScanDetectionOrderByWithRelationInput | InventoryScanDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryScanDetections.
     */
    cursor?: InventoryScanDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanDetections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryScanDetections.
     */
    distinct?: InventoryScanDetectionScalarFieldEnum | InventoryScanDetectionScalarFieldEnum[]
  }

  /**
   * InventoryScanDetection findMany
   */
  export type InventoryScanDetectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryScanDetections to fetch.
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryScanDetections to fetch.
     */
    orderBy?: InventoryScanDetectionOrderByWithRelationInput | InventoryScanDetectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryScanDetections.
     */
    cursor?: InventoryScanDetectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryScanDetections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryScanDetections.
     */
    skip?: number
    distinct?: InventoryScanDetectionScalarFieldEnum | InventoryScanDetectionScalarFieldEnum[]
  }

  /**
   * InventoryScanDetection create
   */
  export type InventoryScanDetectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryScanDetection.
     */
    data: XOR<InventoryScanDetectionCreateInput, InventoryScanDetectionUncheckedCreateInput>
  }

  /**
   * InventoryScanDetection createMany
   */
  export type InventoryScanDetectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryScanDetections.
     */
    data: InventoryScanDetectionCreateManyInput | InventoryScanDetectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryScanDetection createManyAndReturn
   */
  export type InventoryScanDetectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryScanDetections.
     */
    data: InventoryScanDetectionCreateManyInput | InventoryScanDetectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryScanDetection update
   */
  export type InventoryScanDetectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryScanDetection.
     */
    data: XOR<InventoryScanDetectionUpdateInput, InventoryScanDetectionUncheckedUpdateInput>
    /**
     * Choose, which InventoryScanDetection to update.
     */
    where: InventoryScanDetectionWhereUniqueInput
  }

  /**
   * InventoryScanDetection updateMany
   */
  export type InventoryScanDetectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryScanDetections.
     */
    data: XOR<InventoryScanDetectionUpdateManyMutationInput, InventoryScanDetectionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryScanDetections to update
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * Limit how many InventoryScanDetections to update.
     */
    limit?: number
  }

  /**
   * InventoryScanDetection updateManyAndReturn
   */
  export type InventoryScanDetectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * The data used to update InventoryScanDetections.
     */
    data: XOR<InventoryScanDetectionUpdateManyMutationInput, InventoryScanDetectionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryScanDetections to update
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * Limit how many InventoryScanDetections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryScanDetection upsert
   */
  export type InventoryScanDetectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryScanDetection to update in case it exists.
     */
    where: InventoryScanDetectionWhereUniqueInput
    /**
     * In case the InventoryScanDetection found by the `where` argument doesn't exist, create a new InventoryScanDetection with this data.
     */
    create: XOR<InventoryScanDetectionCreateInput, InventoryScanDetectionUncheckedCreateInput>
    /**
     * In case the InventoryScanDetection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryScanDetectionUpdateInput, InventoryScanDetectionUncheckedUpdateInput>
  }

  /**
   * InventoryScanDetection delete
   */
  export type InventoryScanDetectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
    /**
     * Filter which InventoryScanDetection to delete.
     */
    where: InventoryScanDetectionWhereUniqueInput
  }

  /**
   * InventoryScanDetection deleteMany
   */
  export type InventoryScanDetectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryScanDetections to delete
     */
    where?: InventoryScanDetectionWhereInput
    /**
     * Limit how many InventoryScanDetections to delete.
     */
    limit?: number
  }

  /**
   * InventoryScanDetection.product
   */
  export type InventoryScanDetection$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarProduct
     */
    select?: BarProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarProduct
     */
    omit?: BarProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarProductInclude<ExtArgs> | null
    where?: BarProductWhereInput
  }

  /**
   * InventoryScanDetection without action
   */
  export type InventoryScanDetectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryScanDetection
     */
    select?: InventoryScanDetectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryScanDetection
     */
    omit?: InventoryScanDetectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryScanDetectionInclude<ExtArgs> | null
  }


  /**
   * Model InventoryCount
   */

  export type AggregateInventoryCount = {
    _count: InventoryCountCountAggregateOutputType | null
    _avg: InventoryCountAvgAggregateOutputType | null
    _sum: InventoryCountSumAggregateOutputType | null
    _min: InventoryCountMinAggregateOutputType | null
    _max: InventoryCountMaxAggregateOutputType | null
  }

  export type InventoryCountAvgAggregateOutputType = {
    quantity: Decimal | null
    remainingPercent: number | null
    confidence: number | null
  }

  export type InventoryCountSumAggregateOutputType = {
    quantity: Decimal | null
    remainingPercent: number | null
    confidence: number | null
  }

  export type InventoryCountMinAggregateOutputType = {
    id: string | null
    barId: string | null
    productId: string | null
    countedAt: Date | null
    quantity: Decimal | null
    unit: string | null
    remainingPercent: number | null
    remainingBucket: string | null
    method: string | null
    confidence: number | null
    notes: string | null
  }

  export type InventoryCountMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    productId: string | null
    countedAt: Date | null
    quantity: Decimal | null
    unit: string | null
    remainingPercent: number | null
    remainingBucket: string | null
    method: string | null
    confidence: number | null
    notes: string | null
  }

  export type InventoryCountCountAggregateOutputType = {
    id: number
    barId: number
    productId: number
    countedAt: number
    quantity: number
    unit: number
    remainingPercent: number
    remainingBucket: number
    method: number
    confidence: number
    notes: number
    _all: number
  }


  export type InventoryCountAvgAggregateInputType = {
    quantity?: true
    remainingPercent?: true
    confidence?: true
  }

  export type InventoryCountSumAggregateInputType = {
    quantity?: true
    remainingPercent?: true
    confidence?: true
  }

  export type InventoryCountMinAggregateInputType = {
    id?: true
    barId?: true
    productId?: true
    countedAt?: true
    quantity?: true
    unit?: true
    remainingPercent?: true
    remainingBucket?: true
    method?: true
    confidence?: true
    notes?: true
  }

  export type InventoryCountMaxAggregateInputType = {
    id?: true
    barId?: true
    productId?: true
    countedAt?: true
    quantity?: true
    unit?: true
    remainingPercent?: true
    remainingBucket?: true
    method?: true
    confidence?: true
    notes?: true
  }

  export type InventoryCountCountAggregateInputType = {
    id?: true
    barId?: true
    productId?: true
    countedAt?: true
    quantity?: true
    unit?: true
    remainingPercent?: true
    remainingBucket?: true
    method?: true
    confidence?: true
    notes?: true
    _all?: true
  }

  export type InventoryCountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryCount to aggregate.
     */
    where?: InventoryCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCounts to fetch.
     */
    orderBy?: InventoryCountOrderByWithRelationInput | InventoryCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryCounts
    **/
    _count?: true | InventoryCountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryCountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryCountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryCountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryCountMaxAggregateInputType
  }

  export type GetInventoryCountAggregateType<T extends InventoryCountAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryCount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryCount[P]>
      : GetScalarType<T[P], AggregateInventoryCount[P]>
  }




  export type InventoryCountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryCountWhereInput
    orderBy?: InventoryCountOrderByWithAggregationInput | InventoryCountOrderByWithAggregationInput[]
    by: InventoryCountScalarFieldEnum[] | InventoryCountScalarFieldEnum
    having?: InventoryCountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountCountAggregateInputType | true
    _avg?: InventoryCountAvgAggregateInputType
    _sum?: InventoryCountSumAggregateInputType
    _min?: InventoryCountMinAggregateInputType
    _max?: InventoryCountMaxAggregateInputType
  }

  export type InventoryCountGroupByOutputType = {
    id: string
    barId: string
    productId: string
    countedAt: Date
    quantity: Decimal
    unit: string
    remainingPercent: number | null
    remainingBucket: string | null
    method: string
    confidence: number | null
    notes: string | null
    _count: InventoryCountCountAggregateOutputType | null
    _avg: InventoryCountAvgAggregateOutputType | null
    _sum: InventoryCountSumAggregateOutputType | null
    _min: InventoryCountMinAggregateOutputType | null
    _max: InventoryCountMaxAggregateOutputType | null
  }

  type GetInventoryCountGroupByPayload<T extends InventoryCountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryCountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryCountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryCountGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryCountGroupByOutputType[P]>
        }
      >
    >


  export type InventoryCountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    productId?: boolean
    countedAt?: boolean
    quantity?: boolean
    unit?: boolean
    remainingPercent?: boolean
    remainingBucket?: boolean
    method?: boolean
    confidence?: boolean
    notes?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryCount"]>

  export type InventoryCountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    productId?: boolean
    countedAt?: boolean
    quantity?: boolean
    unit?: boolean
    remainingPercent?: boolean
    remainingBucket?: boolean
    method?: boolean
    confidence?: boolean
    notes?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryCount"]>

  export type InventoryCountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    productId?: boolean
    countedAt?: boolean
    quantity?: boolean
    unit?: boolean
    remainingPercent?: boolean
    remainingBucket?: boolean
    method?: boolean
    confidence?: boolean
    notes?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryCount"]>

  export type InventoryCountSelectScalar = {
    id?: boolean
    barId?: boolean
    productId?: boolean
    countedAt?: boolean
    quantity?: boolean
    unit?: boolean
    remainingPercent?: boolean
    remainingBucket?: boolean
    method?: boolean
    confidence?: boolean
    notes?: boolean
  }

  export type InventoryCountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "productId" | "countedAt" | "quantity" | "unit" | "remainingPercent" | "remainingBucket" | "method" | "confidence" | "notes", ExtArgs["result"]["inventoryCount"]>
  export type InventoryCountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProductDefaultArgs<ExtArgs>
  }
  export type InventoryCountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProductDefaultArgs<ExtArgs>
  }
  export type InventoryCountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
    product?: boolean | BarProductDefaultArgs<ExtArgs>
  }

  export type $InventoryCountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryCount"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
      product: Prisma.$BarProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      productId: string
      countedAt: Date
      quantity: Prisma.Decimal
      unit: string
      remainingPercent: number | null
      remainingBucket: string | null
      method: string
      confidence: number | null
      notes: string | null
    }, ExtArgs["result"]["inventoryCount"]>
    composites: {}
  }

  type InventoryCountGetPayload<S extends boolean | null | undefined | InventoryCountDefaultArgs> = $Result.GetResult<Prisma.$InventoryCountPayload, S>

  type InventoryCountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryCountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountCountAggregateInputType | true
    }

  export interface InventoryCountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryCount'], meta: { name: 'InventoryCount' } }
    /**
     * Find zero or one InventoryCount that matches the filter.
     * @param {InventoryCountFindUniqueArgs} args - Arguments to find a InventoryCount
     * @example
     * // Get one InventoryCount
     * const inventoryCount = await prisma.inventoryCount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryCountFindUniqueArgs>(args: SelectSubset<T, InventoryCountFindUniqueArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryCount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryCountFindUniqueOrThrowArgs} args - Arguments to find a InventoryCount
     * @example
     * // Get one InventoryCount
     * const inventoryCount = await prisma.inventoryCount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryCountFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryCountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryCount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountFindFirstArgs} args - Arguments to find a InventoryCount
     * @example
     * // Get one InventoryCount
     * const inventoryCount = await prisma.inventoryCount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryCountFindFirstArgs>(args?: SelectSubset<T, InventoryCountFindFirstArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryCount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountFindFirstOrThrowArgs} args - Arguments to find a InventoryCount
     * @example
     * // Get one InventoryCount
     * const inventoryCount = await prisma.inventoryCount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryCountFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryCountFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryCounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryCounts
     * const inventoryCounts = await prisma.inventoryCount.findMany()
     * 
     * // Get first 10 InventoryCounts
     * const inventoryCounts = await prisma.inventoryCount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryCountWithIdOnly = await prisma.inventoryCount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryCountFindManyArgs>(args?: SelectSubset<T, InventoryCountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryCount.
     * @param {InventoryCountCreateArgs} args - Arguments to create a InventoryCount.
     * @example
     * // Create one InventoryCount
     * const InventoryCount = await prisma.inventoryCount.create({
     *   data: {
     *     // ... data to create a InventoryCount
     *   }
     * })
     * 
     */
    create<T extends InventoryCountCreateArgs>(args: SelectSubset<T, InventoryCountCreateArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryCounts.
     * @param {InventoryCountCreateManyArgs} args - Arguments to create many InventoryCounts.
     * @example
     * // Create many InventoryCounts
     * const inventoryCount = await prisma.inventoryCount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCountCreateManyArgs>(args?: SelectSubset<T, InventoryCountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryCounts and returns the data saved in the database.
     * @param {InventoryCountCreateManyAndReturnArgs} args - Arguments to create many InventoryCounts.
     * @example
     * // Create many InventoryCounts
     * const inventoryCount = await prisma.inventoryCount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryCounts and only return the `id`
     * const inventoryCountWithIdOnly = await prisma.inventoryCount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCountCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryCount.
     * @param {InventoryCountDeleteArgs} args - Arguments to delete one InventoryCount.
     * @example
     * // Delete one InventoryCount
     * const InventoryCount = await prisma.inventoryCount.delete({
     *   where: {
     *     // ... filter to delete one InventoryCount
     *   }
     * })
     * 
     */
    delete<T extends InventoryCountDeleteArgs>(args: SelectSubset<T, InventoryCountDeleteArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryCount.
     * @param {InventoryCountUpdateArgs} args - Arguments to update one InventoryCount.
     * @example
     * // Update one InventoryCount
     * const inventoryCount = await prisma.inventoryCount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryCountUpdateArgs>(args: SelectSubset<T, InventoryCountUpdateArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryCounts.
     * @param {InventoryCountDeleteManyArgs} args - Arguments to filter InventoryCounts to delete.
     * @example
     * // Delete a few InventoryCounts
     * const { count } = await prisma.inventoryCount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryCountDeleteManyArgs>(args?: SelectSubset<T, InventoryCountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryCounts
     * const inventoryCount = await prisma.inventoryCount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryCountUpdateManyArgs>(args: SelectSubset<T, InventoryCountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryCounts and returns the data updated in the database.
     * @param {InventoryCountUpdateManyAndReturnArgs} args - Arguments to update many InventoryCounts.
     * @example
     * // Update many InventoryCounts
     * const inventoryCount = await prisma.inventoryCount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryCounts and only return the `id`
     * const inventoryCountWithIdOnly = await prisma.inventoryCount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryCountUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryCountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryCount.
     * @param {InventoryCountUpsertArgs} args - Arguments to update or create a InventoryCount.
     * @example
     * // Update or create a InventoryCount
     * const inventoryCount = await prisma.inventoryCount.upsert({
     *   create: {
     *     // ... data to create a InventoryCount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryCount we want to update
     *   }
     * })
     */
    upsert<T extends InventoryCountUpsertArgs>(args: SelectSubset<T, InventoryCountUpsertArgs<ExtArgs>>): Prisma__InventoryCountClient<$Result.GetResult<Prisma.$InventoryCountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountCountArgs} args - Arguments to filter InventoryCounts to count.
     * @example
     * // Count the number of InventoryCounts
     * const count = await prisma.inventoryCount.count({
     *   where: {
     *     // ... the filter for the InventoryCounts we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountCountArgs>(
      args?: Subset<T, InventoryCountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryCountAggregateArgs>(args: Subset<T, InventoryCountAggregateArgs>): Prisma.PrismaPromise<GetInventoryCountAggregateType<T>>

    /**
     * Group by InventoryCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryCountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryCountGroupByArgs['orderBy'] }
        : { orderBy?: InventoryCountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryCountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryCountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryCount model
   */
  readonly fields: InventoryCountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryCount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryCountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends BarProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarProductDefaultArgs<ExtArgs>>): Prisma__BarProductClient<$Result.GetResult<Prisma.$BarProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryCount model
   */
  interface InventoryCountFieldRefs {
    readonly id: FieldRef<"InventoryCount", 'String'>
    readonly barId: FieldRef<"InventoryCount", 'String'>
    readonly productId: FieldRef<"InventoryCount", 'String'>
    readonly countedAt: FieldRef<"InventoryCount", 'DateTime'>
    readonly quantity: FieldRef<"InventoryCount", 'Decimal'>
    readonly unit: FieldRef<"InventoryCount", 'String'>
    readonly remainingPercent: FieldRef<"InventoryCount", 'Int'>
    readonly remainingBucket: FieldRef<"InventoryCount", 'String'>
    readonly method: FieldRef<"InventoryCount", 'String'>
    readonly confidence: FieldRef<"InventoryCount", 'Float'>
    readonly notes: FieldRef<"InventoryCount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryCount findUnique
   */
  export type InventoryCountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCount to fetch.
     */
    where: InventoryCountWhereUniqueInput
  }

  /**
   * InventoryCount findUniqueOrThrow
   */
  export type InventoryCountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCount to fetch.
     */
    where: InventoryCountWhereUniqueInput
  }

  /**
   * InventoryCount findFirst
   */
  export type InventoryCountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCount to fetch.
     */
    where?: InventoryCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCounts to fetch.
     */
    orderBy?: InventoryCountOrderByWithRelationInput | InventoryCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryCounts.
     */
    cursor?: InventoryCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryCounts.
     */
    distinct?: InventoryCountScalarFieldEnum | InventoryCountScalarFieldEnum[]
  }

  /**
   * InventoryCount findFirstOrThrow
   */
  export type InventoryCountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCount to fetch.
     */
    where?: InventoryCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCounts to fetch.
     */
    orderBy?: InventoryCountOrderByWithRelationInput | InventoryCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryCounts.
     */
    cursor?: InventoryCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryCounts.
     */
    distinct?: InventoryCountScalarFieldEnum | InventoryCountScalarFieldEnum[]
  }

  /**
   * InventoryCount findMany
   */
  export type InventoryCountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * Filter, which InventoryCounts to fetch.
     */
    where?: InventoryCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryCounts to fetch.
     */
    orderBy?: InventoryCountOrderByWithRelationInput | InventoryCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryCounts.
     */
    cursor?: InventoryCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryCounts.
     */
    skip?: number
    distinct?: InventoryCountScalarFieldEnum | InventoryCountScalarFieldEnum[]
  }

  /**
   * InventoryCount create
   */
  export type InventoryCountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryCount.
     */
    data: XOR<InventoryCountCreateInput, InventoryCountUncheckedCreateInput>
  }

  /**
   * InventoryCount createMany
   */
  export type InventoryCountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryCounts.
     */
    data: InventoryCountCreateManyInput | InventoryCountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryCount createManyAndReturn
   */
  export type InventoryCountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryCounts.
     */
    data: InventoryCountCreateManyInput | InventoryCountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryCount update
   */
  export type InventoryCountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryCount.
     */
    data: XOR<InventoryCountUpdateInput, InventoryCountUncheckedUpdateInput>
    /**
     * Choose, which InventoryCount to update.
     */
    where: InventoryCountWhereUniqueInput
  }

  /**
   * InventoryCount updateMany
   */
  export type InventoryCountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryCounts.
     */
    data: XOR<InventoryCountUpdateManyMutationInput, InventoryCountUncheckedUpdateManyInput>
    /**
     * Filter which InventoryCounts to update
     */
    where?: InventoryCountWhereInput
    /**
     * Limit how many InventoryCounts to update.
     */
    limit?: number
  }

  /**
   * InventoryCount updateManyAndReturn
   */
  export type InventoryCountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * The data used to update InventoryCounts.
     */
    data: XOR<InventoryCountUpdateManyMutationInput, InventoryCountUncheckedUpdateManyInput>
    /**
     * Filter which InventoryCounts to update
     */
    where?: InventoryCountWhereInput
    /**
     * Limit how many InventoryCounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryCount upsert
   */
  export type InventoryCountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryCount to update in case it exists.
     */
    where: InventoryCountWhereUniqueInput
    /**
     * In case the InventoryCount found by the `where` argument doesn't exist, create a new InventoryCount with this data.
     */
    create: XOR<InventoryCountCreateInput, InventoryCountUncheckedCreateInput>
    /**
     * In case the InventoryCount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryCountUpdateInput, InventoryCountUncheckedUpdateInput>
  }

  /**
   * InventoryCount delete
   */
  export type InventoryCountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
    /**
     * Filter which InventoryCount to delete.
     */
    where: InventoryCountWhereUniqueInput
  }

  /**
   * InventoryCount deleteMany
   */
  export type InventoryCountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryCounts to delete
     */
    where?: InventoryCountWhereInput
    /**
     * Limit how many InventoryCounts to delete.
     */
    limit?: number
  }

  /**
   * InventoryCount without action
   */
  export type InventoryCountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCount
     */
    select?: InventoryCountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryCount
     */
    omit?: InventoryCountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryCountInclude<ExtArgs> | null
  }


  /**
   * Model AdminAudit
   */

  export type AggregateAdminAudit = {
    _count: AdminAuditCountAggregateOutputType | null
    _min: AdminAuditMinAggregateOutputType | null
    _max: AdminAuditMaxAggregateOutputType | null
  }

  export type AdminAuditMinAggregateOutputType = {
    id: string | null
    adminEmail: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AdminAuditMaxAggregateOutputType = {
    id: string | null
    adminEmail: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AdminAuditCountAggregateOutputType = {
    id: number
    adminEmail: number
    action: number
    entityType: number
    entityId: number
    before: number
    after: number
    createdAt: number
    _all: number
  }


  export type AdminAuditMinAggregateInputType = {
    id?: true
    adminEmail?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AdminAuditMaxAggregateInputType = {
    id?: true
    adminEmail?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AdminAuditCountAggregateInputType = {
    id?: true
    adminEmail?: true
    action?: true
    entityType?: true
    entityId?: true
    before?: true
    after?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAudit to aggregate.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAudits
    **/
    _count?: true | AdminAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditMaxAggregateInputType
  }

  export type GetAdminAuditAggregateType<T extends AdminAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAudit[P]>
      : GetScalarType<T[P], AggregateAdminAudit[P]>
  }




  export type AdminAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditWhereInput
    orderBy?: AdminAuditOrderByWithAggregationInput | AdminAuditOrderByWithAggregationInput[]
    by: AdminAuditScalarFieldEnum[] | AdminAuditScalarFieldEnum
    having?: AdminAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditCountAggregateInputType | true
    _min?: AdminAuditMinAggregateInputType
    _max?: AdminAuditMaxAggregateInputType
  }

  export type AdminAuditGroupByOutputType = {
    id: string
    adminEmail: string
    action: string
    entityType: string | null
    entityId: string | null
    before: JsonValue | null
    after: JsonValue | null
    createdAt: Date
    _count: AdminAuditCountAggregateOutputType | null
    _min: AdminAuditMinAggregateOutputType | null
    _max: AdminAuditMaxAggregateOutputType | null
  }

  type GetAdminAuditGroupByPayload<T extends AdminAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminEmail?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminAudit"]>

  export type AdminAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminEmail?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminAudit"]>

  export type AdminAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminEmail?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminAudit"]>

  export type AdminAuditSelectScalar = {
    id?: boolean
    adminEmail?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    createdAt?: boolean
  }

  export type AdminAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminEmail" | "action" | "entityType" | "entityId" | "before" | "after" | "createdAt", ExtArgs["result"]["adminAudit"]>

  export type $AdminAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAudit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminEmail: string
      action: string
      entityType: string | null
      entityId: string | null
      before: Prisma.JsonValue | null
      after: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["adminAudit"]>
    composites: {}
  }

  type AdminAuditGetPayload<S extends boolean | null | undefined | AdminAuditDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditPayload, S>

  type AdminAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuditCountAggregateInputType | true
    }

  export interface AdminAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAudit'], meta: { name: 'AdminAudit' } }
    /**
     * Find zero or one AdminAudit that matches the filter.
     * @param {AdminAuditFindUniqueArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditFindUniqueArgs>(args: SelectSubset<T, AdminAuditFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuditFindUniqueOrThrowArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditFindFirstArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditFindFirstArgs>(args?: SelectSubset<T, AdminAuditFindFirstArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditFindFirstOrThrowArgs} args - Arguments to find a AdminAudit
     * @example
     * // Get one AdminAudit
     * const adminAudit = await prisma.adminAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAudits
     * const adminAudits = await prisma.adminAudit.findMany()
     * 
     * // Get first 10 AdminAudits
     * const adminAudits = await prisma.adminAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditWithIdOnly = await prisma.adminAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditFindManyArgs>(args?: SelectSubset<T, AdminAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAudit.
     * @param {AdminAuditCreateArgs} args - Arguments to create a AdminAudit.
     * @example
     * // Create one AdminAudit
     * const AdminAudit = await prisma.adminAudit.create({
     *   data: {
     *     // ... data to create a AdminAudit
     *   }
     * })
     * 
     */
    create<T extends AdminAuditCreateArgs>(args: SelectSubset<T, AdminAuditCreateArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAudits.
     * @param {AdminAuditCreateManyArgs} args - Arguments to create many AdminAudits.
     * @example
     * // Create many AdminAudits
     * const adminAudit = await prisma.adminAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditCreateManyArgs>(args?: SelectSubset<T, AdminAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAudits and returns the data saved in the database.
     * @param {AdminAuditCreateManyAndReturnArgs} args - Arguments to create many AdminAudits.
     * @example
     * // Create many AdminAudits
     * const adminAudit = await prisma.adminAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAudits and only return the `id`
     * const adminAuditWithIdOnly = await prisma.adminAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAudit.
     * @param {AdminAuditDeleteArgs} args - Arguments to delete one AdminAudit.
     * @example
     * // Delete one AdminAudit
     * const AdminAudit = await prisma.adminAudit.delete({
     *   where: {
     *     // ... filter to delete one AdminAudit
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditDeleteArgs>(args: SelectSubset<T, AdminAuditDeleteArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAudit.
     * @param {AdminAuditUpdateArgs} args - Arguments to update one AdminAudit.
     * @example
     * // Update one AdminAudit
     * const adminAudit = await prisma.adminAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditUpdateArgs>(args: SelectSubset<T, AdminAuditUpdateArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAudits.
     * @param {AdminAuditDeleteManyArgs} args - Arguments to filter AdminAudits to delete.
     * @example
     * // Delete a few AdminAudits
     * const { count } = await prisma.adminAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditDeleteManyArgs>(args?: SelectSubset<T, AdminAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAudits
     * const adminAudit = await prisma.adminAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditUpdateManyArgs>(args: SelectSubset<T, AdminAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAudits and returns the data updated in the database.
     * @param {AdminAuditUpdateManyAndReturnArgs} args - Arguments to update many AdminAudits.
     * @example
     * // Update many AdminAudits
     * const adminAudit = await prisma.adminAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAudits and only return the `id`
     * const adminAuditWithIdOnly = await prisma.adminAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAudit.
     * @param {AdminAuditUpsertArgs} args - Arguments to update or create a AdminAudit.
     * @example
     * // Update or create a AdminAudit
     * const adminAudit = await prisma.adminAudit.upsert({
     *   create: {
     *     // ... data to create a AdminAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAudit we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditUpsertArgs>(args: SelectSubset<T, AdminAuditUpsertArgs<ExtArgs>>): Prisma__AdminAuditClient<$Result.GetResult<Prisma.$AdminAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditCountArgs} args - Arguments to filter AdminAudits to count.
     * @example
     * // Count the number of AdminAudits
     * const count = await prisma.adminAudit.count({
     *   where: {
     *     // ... the filter for the AdminAudits we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditCountArgs>(
      args?: Subset<T, AdminAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditAggregateArgs>(args: Subset<T, AdminAuditAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditAggregateType<T>>

    /**
     * Group by AdminAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAudit model
   */
  readonly fields: AdminAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAudit model
   */
  interface AdminAuditFieldRefs {
    readonly id: FieldRef<"AdminAudit", 'String'>
    readonly adminEmail: FieldRef<"AdminAudit", 'String'>
    readonly action: FieldRef<"AdminAudit", 'String'>
    readonly entityType: FieldRef<"AdminAudit", 'String'>
    readonly entityId: FieldRef<"AdminAudit", 'String'>
    readonly before: FieldRef<"AdminAudit", 'Json'>
    readonly after: FieldRef<"AdminAudit", 'Json'>
    readonly createdAt: FieldRef<"AdminAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAudit findUnique
   */
  export type AdminAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit findUniqueOrThrow
   */
  export type AdminAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit findFirst
   */
  export type AdminAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAudits.
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAudits.
     */
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * AdminAudit findFirstOrThrow
   */
  export type AdminAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * Filter, which AdminAudit to fetch.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAudits.
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAudits.
     */
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * AdminAudit findMany
   */
  export type AdminAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * Filter, which AdminAudits to fetch.
     */
    where?: AdminAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAudits to fetch.
     */
    orderBy?: AdminAuditOrderByWithRelationInput | AdminAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAudits.
     */
    cursor?: AdminAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAudits.
     */
    skip?: number
    distinct?: AdminAuditScalarFieldEnum | AdminAuditScalarFieldEnum[]
  }

  /**
   * AdminAudit create
   */
  export type AdminAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminAudit.
     */
    data: XOR<AdminAuditCreateInput, AdminAuditUncheckedCreateInput>
  }

  /**
   * AdminAudit createMany
   */
  export type AdminAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAudits.
     */
    data: AdminAuditCreateManyInput | AdminAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAudit createManyAndReturn
   */
  export type AdminAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAudits.
     */
    data: AdminAuditCreateManyInput | AdminAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAudit update
   */
  export type AdminAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminAudit.
     */
    data: XOR<AdminAuditUpdateInput, AdminAuditUncheckedUpdateInput>
    /**
     * Choose, which AdminAudit to update.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit updateMany
   */
  export type AdminAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAudits.
     */
    data: XOR<AdminAuditUpdateManyMutationInput, AdminAuditUncheckedUpdateManyInput>
    /**
     * Filter which AdminAudits to update
     */
    where?: AdminAuditWhereInput
    /**
     * Limit how many AdminAudits to update.
     */
    limit?: number
  }

  /**
   * AdminAudit updateManyAndReturn
   */
  export type AdminAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * The data used to update AdminAudits.
     */
    data: XOR<AdminAuditUpdateManyMutationInput, AdminAuditUncheckedUpdateManyInput>
    /**
     * Filter which AdminAudits to update
     */
    where?: AdminAuditWhereInput
    /**
     * Limit how many AdminAudits to update.
     */
    limit?: number
  }

  /**
   * AdminAudit upsert
   */
  export type AdminAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminAudit to update in case it exists.
     */
    where: AdminAuditWhereUniqueInput
    /**
     * In case the AdminAudit found by the `where` argument doesn't exist, create a new AdminAudit with this data.
     */
    create: XOR<AdminAuditCreateInput, AdminAuditUncheckedCreateInput>
    /**
     * In case the AdminAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditUpdateInput, AdminAuditUncheckedUpdateInput>
  }

  /**
   * AdminAudit delete
   */
  export type AdminAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
    /**
     * Filter which AdminAudit to delete.
     */
    where: AdminAuditWhereUniqueInput
  }

  /**
   * AdminAudit deleteMany
   */
  export type AdminAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAudits to delete
     */
    where?: AdminAuditWhereInput
    /**
     * Limit how many AdminAudits to delete.
     */
    limit?: number
  }

  /**
   * AdminAudit without action
   */
  export type AdminAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAudit
     */
    select?: AdminAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAudit
     */
    omit?: AdminAuditOmit<ExtArgs> | null
  }


  /**
   * Model AdminNote
   */

  export type AggregateAdminNote = {
    _count: AdminNoteCountAggregateOutputType | null
    _min: AdminNoteMinAggregateOutputType | null
    _max: AdminNoteMaxAggregateOutputType | null
  }

  export type AdminNoteMinAggregateOutputType = {
    id: string | null
    adminEmail: string | null
    barId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AdminNoteMaxAggregateOutputType = {
    id: string | null
    adminEmail: string | null
    barId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type AdminNoteCountAggregateOutputType = {
    id: number
    adminEmail: number
    barId: number
    userId: number
    content: number
    createdAt: number
    _all: number
  }


  export type AdminNoteMinAggregateInputType = {
    id?: true
    adminEmail?: true
    barId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type AdminNoteMaxAggregateInputType = {
    id?: true
    adminEmail?: true
    barId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type AdminNoteCountAggregateInputType = {
    id?: true
    adminEmail?: true
    barId?: true
    userId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AdminNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNote to aggregate.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminNotes
    **/
    _count?: true | AdminNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminNoteMaxAggregateInputType
  }

  export type GetAdminNoteAggregateType<T extends AdminNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminNote[P]>
      : GetScalarType<T[P], AggregateAdminNote[P]>
  }




  export type AdminNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithAggregationInput | AdminNoteOrderByWithAggregationInput[]
    by: AdminNoteScalarFieldEnum[] | AdminNoteScalarFieldEnum
    having?: AdminNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminNoteCountAggregateInputType | true
    _min?: AdminNoteMinAggregateInputType
    _max?: AdminNoteMaxAggregateInputType
  }

  export type AdminNoteGroupByOutputType = {
    id: string
    adminEmail: string
    barId: string | null
    userId: string | null
    content: string
    createdAt: Date
    _count: AdminNoteCountAggregateOutputType | null
    _min: AdminNoteMinAggregateOutputType | null
    _max: AdminNoteMaxAggregateOutputType | null
  }

  type GetAdminNoteGroupByPayload<T extends AdminNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminNoteGroupByOutputType[P]>
            : GetScalarType<T[P], AdminNoteGroupByOutputType[P]>
        }
      >
    >


  export type AdminNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminEmail?: boolean
    barId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    bar?: boolean | AdminNote$barArgs<ExtArgs>
    user?: boolean | AdminNote$userArgs<ExtArgs>
  }, ExtArgs["result"]["adminNote"]>

  export type AdminNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminEmail?: boolean
    barId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    bar?: boolean | AdminNote$barArgs<ExtArgs>
    user?: boolean | AdminNote$userArgs<ExtArgs>
  }, ExtArgs["result"]["adminNote"]>

  export type AdminNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminEmail?: boolean
    barId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    bar?: boolean | AdminNote$barArgs<ExtArgs>
    user?: boolean | AdminNote$userArgs<ExtArgs>
  }, ExtArgs["result"]["adminNote"]>

  export type AdminNoteSelectScalar = {
    id?: boolean
    adminEmail?: boolean
    barId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AdminNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminEmail" | "barId" | "userId" | "content" | "createdAt", ExtArgs["result"]["adminNote"]>
  export type AdminNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | AdminNote$barArgs<ExtArgs>
    user?: boolean | AdminNote$userArgs<ExtArgs>
  }
  export type AdminNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | AdminNote$barArgs<ExtArgs>
    user?: boolean | AdminNote$userArgs<ExtArgs>
  }
  export type AdminNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | AdminNote$barArgs<ExtArgs>
    user?: boolean | AdminNote$userArgs<ExtArgs>
  }

  export type $AdminNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminNote"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminEmail: string
      barId: string | null
      userId: string | null
      content: string
      createdAt: Date
    }, ExtArgs["result"]["adminNote"]>
    composites: {}
  }

  type AdminNoteGetPayload<S extends boolean | null | undefined | AdminNoteDefaultArgs> = $Result.GetResult<Prisma.$AdminNotePayload, S>

  type AdminNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminNoteCountAggregateInputType | true
    }

  export interface AdminNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminNote'], meta: { name: 'AdminNote' } }
    /**
     * Find zero or one AdminNote that matches the filter.
     * @param {AdminNoteFindUniqueArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminNoteFindUniqueArgs>(args: SelectSubset<T, AdminNoteFindUniqueArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminNoteFindUniqueOrThrowArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteFindFirstArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminNoteFindFirstArgs>(args?: SelectSubset<T, AdminNoteFindFirstArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteFindFirstOrThrowArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminNotes
     * const adminNotes = await prisma.adminNote.findMany()
     * 
     * // Get first 10 AdminNotes
     * const adminNotes = await prisma.adminNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminNoteWithIdOnly = await prisma.adminNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminNoteFindManyArgs>(args?: SelectSubset<T, AdminNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminNote.
     * @param {AdminNoteCreateArgs} args - Arguments to create a AdminNote.
     * @example
     * // Create one AdminNote
     * const AdminNote = await prisma.adminNote.create({
     *   data: {
     *     // ... data to create a AdminNote
     *   }
     * })
     * 
     */
    create<T extends AdminNoteCreateArgs>(args: SelectSubset<T, AdminNoteCreateArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminNotes.
     * @param {AdminNoteCreateManyArgs} args - Arguments to create many AdminNotes.
     * @example
     * // Create many AdminNotes
     * const adminNote = await prisma.adminNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminNoteCreateManyArgs>(args?: SelectSubset<T, AdminNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminNotes and returns the data saved in the database.
     * @param {AdminNoteCreateManyAndReturnArgs} args - Arguments to create many AdminNotes.
     * @example
     * // Create many AdminNotes
     * const adminNote = await prisma.adminNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminNotes and only return the `id`
     * const adminNoteWithIdOnly = await prisma.adminNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminNote.
     * @param {AdminNoteDeleteArgs} args - Arguments to delete one AdminNote.
     * @example
     * // Delete one AdminNote
     * const AdminNote = await prisma.adminNote.delete({
     *   where: {
     *     // ... filter to delete one AdminNote
     *   }
     * })
     * 
     */
    delete<T extends AdminNoteDeleteArgs>(args: SelectSubset<T, AdminNoteDeleteArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminNote.
     * @param {AdminNoteUpdateArgs} args - Arguments to update one AdminNote.
     * @example
     * // Update one AdminNote
     * const adminNote = await prisma.adminNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminNoteUpdateArgs>(args: SelectSubset<T, AdminNoteUpdateArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminNotes.
     * @param {AdminNoteDeleteManyArgs} args - Arguments to filter AdminNotes to delete.
     * @example
     * // Delete a few AdminNotes
     * const { count } = await prisma.adminNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminNoteDeleteManyArgs>(args?: SelectSubset<T, AdminNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminNotes
     * const adminNote = await prisma.adminNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminNoteUpdateManyArgs>(args: SelectSubset<T, AdminNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotes and returns the data updated in the database.
     * @param {AdminNoteUpdateManyAndReturnArgs} args - Arguments to update many AdminNotes.
     * @example
     * // Update many AdminNotes
     * const adminNote = await prisma.adminNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminNotes and only return the `id`
     * const adminNoteWithIdOnly = await prisma.adminNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminNote.
     * @param {AdminNoteUpsertArgs} args - Arguments to update or create a AdminNote.
     * @example
     * // Update or create a AdminNote
     * const adminNote = await prisma.adminNote.upsert({
     *   create: {
     *     // ... data to create a AdminNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminNote we want to update
     *   }
     * })
     */
    upsert<T extends AdminNoteUpsertArgs>(args: SelectSubset<T, AdminNoteUpsertArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteCountArgs} args - Arguments to filter AdminNotes to count.
     * @example
     * // Count the number of AdminNotes
     * const count = await prisma.adminNote.count({
     *   where: {
     *     // ... the filter for the AdminNotes we want to count
     *   }
     * })
    **/
    count<T extends AdminNoteCountArgs>(
      args?: Subset<T, AdminNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminNoteAggregateArgs>(args: Subset<T, AdminNoteAggregateArgs>): Prisma.PrismaPromise<GetAdminNoteAggregateType<T>>

    /**
     * Group by AdminNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminNoteGroupByArgs['orderBy'] }
        : { orderBy?: AdminNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminNote model
   */
  readonly fields: AdminNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends AdminNote$barArgs<ExtArgs> = {}>(args?: Subset<T, AdminNote$barArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends AdminNote$userArgs<ExtArgs> = {}>(args?: Subset<T, AdminNote$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminNote model
   */
  interface AdminNoteFieldRefs {
    readonly id: FieldRef<"AdminNote", 'String'>
    readonly adminEmail: FieldRef<"AdminNote", 'String'>
    readonly barId: FieldRef<"AdminNote", 'String'>
    readonly userId: FieldRef<"AdminNote", 'String'>
    readonly content: FieldRef<"AdminNote", 'String'>
    readonly createdAt: FieldRef<"AdminNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminNote findUnique
   */
  export type AdminNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote findUniqueOrThrow
   */
  export type AdminNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote findFirst
   */
  export type AdminNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotes.
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotes.
     */
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * AdminNote findFirstOrThrow
   */
  export type AdminNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotes.
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotes.
     */
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * AdminNote findMany
   */
  export type AdminNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotes to fetch.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminNotes.
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * AdminNote create
   */
  export type AdminNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminNote.
     */
    data: XOR<AdminNoteCreateInput, AdminNoteUncheckedCreateInput>
  }

  /**
   * AdminNote createMany
   */
  export type AdminNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminNotes.
     */
    data: AdminNoteCreateManyInput | AdminNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminNote createManyAndReturn
   */
  export type AdminNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * The data used to create many AdminNotes.
     */
    data: AdminNoteCreateManyInput | AdminNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminNote update
   */
  export type AdminNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminNote.
     */
    data: XOR<AdminNoteUpdateInput, AdminNoteUncheckedUpdateInput>
    /**
     * Choose, which AdminNote to update.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote updateMany
   */
  export type AdminNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminNotes.
     */
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotes to update
     */
    where?: AdminNoteWhereInput
    /**
     * Limit how many AdminNotes to update.
     */
    limit?: number
  }

  /**
   * AdminNote updateManyAndReturn
   */
  export type AdminNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * The data used to update AdminNotes.
     */
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotes to update
     */
    where?: AdminNoteWhereInput
    /**
     * Limit how many AdminNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminNote upsert
   */
  export type AdminNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminNote to update in case it exists.
     */
    where: AdminNoteWhereUniqueInput
    /**
     * In case the AdminNote found by the `where` argument doesn't exist, create a new AdminNote with this data.
     */
    create: XOR<AdminNoteCreateInput, AdminNoteUncheckedCreateInput>
    /**
     * In case the AdminNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminNoteUpdateInput, AdminNoteUncheckedUpdateInput>
  }

  /**
   * AdminNote delete
   */
  export type AdminNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter which AdminNote to delete.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote deleteMany
   */
  export type AdminNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNotes to delete
     */
    where?: AdminNoteWhereInput
    /**
     * Limit how many AdminNotes to delete.
     */
    limit?: number
  }

  /**
   * AdminNote.bar
   */
  export type AdminNote$barArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    where?: BarWhereInput
  }

  /**
   * AdminNote.user
   */
  export type AdminNote$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AdminNote without action
   */
  export type AdminNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNote
     */
    omit?: AdminNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    barId: string | null
    userEmail: string | null
    userId: string | null
    subject: string | null
    status: string | null
    priority: string | null
    message: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    userEmail: string | null
    userId: string | null
    subject: string | null
    status: string | null
    priority: string | null
    message: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    barId: number
    userEmail: number
    userId: number
    subject: number
    status: number
    priority: number
    message: number
    resolution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    barId?: true
    userEmail?: true
    userId?: true
    subject?: true
    status?: true
    priority?: true
    message?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    barId?: true
    userEmail?: true
    userId?: true
    subject?: true
    status?: true
    priority?: true
    message?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    barId?: true
    userEmail?: true
    userId?: true
    subject?: true
    status?: true
    priority?: true
    message?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    barId: string | null
    userEmail: string
    userId: string | null
    subject: string
    status: string
    priority: string
    message: string
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userEmail?: boolean
    userId?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    message?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | SupportTicket$barArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userEmail?: boolean
    userId?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    message?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | SupportTicket$barArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    userEmail?: boolean
    userId?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    message?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | SupportTicket$barArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    barId?: boolean
    userEmail?: boolean
    userId?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    message?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "userEmail" | "userId" | "subject" | "status" | "priority" | "message" | "resolution" | "createdAt" | "updatedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | SupportTicket$barArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | SupportTicket$barArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | SupportTicket$barArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string | null
      userEmail: string
      userId: string | null
      subject: string
      status: string
      priority: string
      message: string
      resolution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends SupportTicket$barArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$barArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends SupportTicket$userArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly barId: FieldRef<"SupportTicket", 'String'>
    readonly userEmail: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'String'>
    readonly message: FieldRef<"SupportTicket", 'String'>
    readonly resolution: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.bar
   */
  export type SupportTicket$barArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bar
     */
    select?: BarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bar
     */
    omit?: BarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarInclude<ExtArgs> | null
    where?: BarWhereInput
  }

  /**
   * SupportTicket.user
   */
  export type SupportTicket$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model StaticOffering
   */

  export type AggregateStaticOffering = {
    _count: StaticOfferingCountAggregateOutputType | null
    _avg: StaticOfferingAvgAggregateOutputType | null
    _sum: StaticOfferingSumAggregateOutputType | null
    _min: StaticOfferingMinAggregateOutputType | null
    _max: StaticOfferingMaxAggregateOutputType | null
  }

  export type StaticOfferingAvgAggregateOutputType = {
    position: number | null
  }

  export type StaticOfferingSumAggregateOutputType = {
    position: number | null
  }

  export type StaticOfferingMinAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    icon: string | null
    description: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaticOfferingMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    icon: string | null
    description: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaticOfferingCountAggregateOutputType = {
    id: number
    barId: number
    name: number
    icon: number
    description: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaticOfferingAvgAggregateInputType = {
    position?: true
  }

  export type StaticOfferingSumAggregateInputType = {
    position?: true
  }

  export type StaticOfferingMinAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    icon?: true
    description?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaticOfferingMaxAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    icon?: true
    description?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaticOfferingCountAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    icon?: true
    description?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaticOfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaticOffering to aggregate.
     */
    where?: StaticOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticOfferings to fetch.
     */
    orderBy?: StaticOfferingOrderByWithRelationInput | StaticOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaticOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaticOfferings
    **/
    _count?: true | StaticOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaticOfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaticOfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaticOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaticOfferingMaxAggregateInputType
  }

  export type GetStaticOfferingAggregateType<T extends StaticOfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateStaticOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaticOffering[P]>
      : GetScalarType<T[P], AggregateStaticOffering[P]>
  }




  export type StaticOfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaticOfferingWhereInput
    orderBy?: StaticOfferingOrderByWithAggregationInput | StaticOfferingOrderByWithAggregationInput[]
    by: StaticOfferingScalarFieldEnum[] | StaticOfferingScalarFieldEnum
    having?: StaticOfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaticOfferingCountAggregateInputType | true
    _avg?: StaticOfferingAvgAggregateInputType
    _sum?: StaticOfferingSumAggregateInputType
    _min?: StaticOfferingMinAggregateInputType
    _max?: StaticOfferingMaxAggregateInputType
  }

  export type StaticOfferingGroupByOutputType = {
    id: string
    barId: string
    name: string
    icon: string
    description: string | null
    position: number
    createdAt: Date
    updatedAt: Date
    _count: StaticOfferingCountAggregateOutputType | null
    _avg: StaticOfferingAvgAggregateOutputType | null
    _sum: StaticOfferingSumAggregateOutputType | null
    _min: StaticOfferingMinAggregateOutputType | null
    _max: StaticOfferingMaxAggregateOutputType | null
  }

  type GetStaticOfferingGroupByPayload<T extends StaticOfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaticOfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaticOfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaticOfferingGroupByOutputType[P]>
            : GetScalarType<T[P], StaticOfferingGroupByOutputType[P]>
        }
      >
    >


  export type StaticOfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staticOffering"]>

  export type StaticOfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staticOffering"]>

  export type StaticOfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staticOffering"]>

  export type StaticOfferingSelectScalar = {
    id?: boolean
    barId?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaticOfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "name" | "icon" | "description" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["staticOffering"]>
  export type StaticOfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type StaticOfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type StaticOfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $StaticOfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaticOffering"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      name: string
      icon: string
      description: string | null
      position: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staticOffering"]>
    composites: {}
  }

  type StaticOfferingGetPayload<S extends boolean | null | undefined | StaticOfferingDefaultArgs> = $Result.GetResult<Prisma.$StaticOfferingPayload, S>

  type StaticOfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaticOfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaticOfferingCountAggregateInputType | true
    }

  export interface StaticOfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaticOffering'], meta: { name: 'StaticOffering' } }
    /**
     * Find zero or one StaticOffering that matches the filter.
     * @param {StaticOfferingFindUniqueArgs} args - Arguments to find a StaticOffering
     * @example
     * // Get one StaticOffering
     * const staticOffering = await prisma.staticOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaticOfferingFindUniqueArgs>(args: SelectSubset<T, StaticOfferingFindUniqueArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaticOffering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaticOfferingFindUniqueOrThrowArgs} args - Arguments to find a StaticOffering
     * @example
     * // Get one StaticOffering
     * const staticOffering = await prisma.staticOffering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaticOfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, StaticOfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaticOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingFindFirstArgs} args - Arguments to find a StaticOffering
     * @example
     * // Get one StaticOffering
     * const staticOffering = await prisma.staticOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaticOfferingFindFirstArgs>(args?: SelectSubset<T, StaticOfferingFindFirstArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaticOffering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingFindFirstOrThrowArgs} args - Arguments to find a StaticOffering
     * @example
     * // Get one StaticOffering
     * const staticOffering = await prisma.staticOffering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaticOfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, StaticOfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaticOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaticOfferings
     * const staticOfferings = await prisma.staticOffering.findMany()
     * 
     * // Get first 10 StaticOfferings
     * const staticOfferings = await prisma.staticOffering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staticOfferingWithIdOnly = await prisma.staticOffering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaticOfferingFindManyArgs>(args?: SelectSubset<T, StaticOfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaticOffering.
     * @param {StaticOfferingCreateArgs} args - Arguments to create a StaticOffering.
     * @example
     * // Create one StaticOffering
     * const StaticOffering = await prisma.staticOffering.create({
     *   data: {
     *     // ... data to create a StaticOffering
     *   }
     * })
     * 
     */
    create<T extends StaticOfferingCreateArgs>(args: SelectSubset<T, StaticOfferingCreateArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaticOfferings.
     * @param {StaticOfferingCreateManyArgs} args - Arguments to create many StaticOfferings.
     * @example
     * // Create many StaticOfferings
     * const staticOffering = await prisma.staticOffering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaticOfferingCreateManyArgs>(args?: SelectSubset<T, StaticOfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaticOfferings and returns the data saved in the database.
     * @param {StaticOfferingCreateManyAndReturnArgs} args - Arguments to create many StaticOfferings.
     * @example
     * // Create many StaticOfferings
     * const staticOffering = await prisma.staticOffering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaticOfferings and only return the `id`
     * const staticOfferingWithIdOnly = await prisma.staticOffering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaticOfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, StaticOfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaticOffering.
     * @param {StaticOfferingDeleteArgs} args - Arguments to delete one StaticOffering.
     * @example
     * // Delete one StaticOffering
     * const StaticOffering = await prisma.staticOffering.delete({
     *   where: {
     *     // ... filter to delete one StaticOffering
     *   }
     * })
     * 
     */
    delete<T extends StaticOfferingDeleteArgs>(args: SelectSubset<T, StaticOfferingDeleteArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaticOffering.
     * @param {StaticOfferingUpdateArgs} args - Arguments to update one StaticOffering.
     * @example
     * // Update one StaticOffering
     * const staticOffering = await prisma.staticOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaticOfferingUpdateArgs>(args: SelectSubset<T, StaticOfferingUpdateArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaticOfferings.
     * @param {StaticOfferingDeleteManyArgs} args - Arguments to filter StaticOfferings to delete.
     * @example
     * // Delete a few StaticOfferings
     * const { count } = await prisma.staticOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaticOfferingDeleteManyArgs>(args?: SelectSubset<T, StaticOfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaticOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaticOfferings
     * const staticOffering = await prisma.staticOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaticOfferingUpdateManyArgs>(args: SelectSubset<T, StaticOfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaticOfferings and returns the data updated in the database.
     * @param {StaticOfferingUpdateManyAndReturnArgs} args - Arguments to update many StaticOfferings.
     * @example
     * // Update many StaticOfferings
     * const staticOffering = await prisma.staticOffering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaticOfferings and only return the `id`
     * const staticOfferingWithIdOnly = await prisma.staticOffering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaticOfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, StaticOfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaticOffering.
     * @param {StaticOfferingUpsertArgs} args - Arguments to update or create a StaticOffering.
     * @example
     * // Update or create a StaticOffering
     * const staticOffering = await prisma.staticOffering.upsert({
     *   create: {
     *     // ... data to create a StaticOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaticOffering we want to update
     *   }
     * })
     */
    upsert<T extends StaticOfferingUpsertArgs>(args: SelectSubset<T, StaticOfferingUpsertArgs<ExtArgs>>): Prisma__StaticOfferingClient<$Result.GetResult<Prisma.$StaticOfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaticOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingCountArgs} args - Arguments to filter StaticOfferings to count.
     * @example
     * // Count the number of StaticOfferings
     * const count = await prisma.staticOffering.count({
     *   where: {
     *     // ... the filter for the StaticOfferings we want to count
     *   }
     * })
    **/
    count<T extends StaticOfferingCountArgs>(
      args?: Subset<T, StaticOfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaticOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaticOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaticOfferingAggregateArgs>(args: Subset<T, StaticOfferingAggregateArgs>): Prisma.PrismaPromise<GetStaticOfferingAggregateType<T>>

    /**
     * Group by StaticOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticOfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaticOfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaticOfferingGroupByArgs['orderBy'] }
        : { orderBy?: StaticOfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaticOfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaticOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaticOffering model
   */
  readonly fields: StaticOfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaticOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaticOfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaticOffering model
   */
  interface StaticOfferingFieldRefs {
    readonly id: FieldRef<"StaticOffering", 'String'>
    readonly barId: FieldRef<"StaticOffering", 'String'>
    readonly name: FieldRef<"StaticOffering", 'String'>
    readonly icon: FieldRef<"StaticOffering", 'String'>
    readonly description: FieldRef<"StaticOffering", 'String'>
    readonly position: FieldRef<"StaticOffering", 'Int'>
    readonly createdAt: FieldRef<"StaticOffering", 'DateTime'>
    readonly updatedAt: FieldRef<"StaticOffering", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaticOffering findUnique
   */
  export type StaticOfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * Filter, which StaticOffering to fetch.
     */
    where: StaticOfferingWhereUniqueInput
  }

  /**
   * StaticOffering findUniqueOrThrow
   */
  export type StaticOfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * Filter, which StaticOffering to fetch.
     */
    where: StaticOfferingWhereUniqueInput
  }

  /**
   * StaticOffering findFirst
   */
  export type StaticOfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * Filter, which StaticOffering to fetch.
     */
    where?: StaticOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticOfferings to fetch.
     */
    orderBy?: StaticOfferingOrderByWithRelationInput | StaticOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaticOfferings.
     */
    cursor?: StaticOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaticOfferings.
     */
    distinct?: StaticOfferingScalarFieldEnum | StaticOfferingScalarFieldEnum[]
  }

  /**
   * StaticOffering findFirstOrThrow
   */
  export type StaticOfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * Filter, which StaticOffering to fetch.
     */
    where?: StaticOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticOfferings to fetch.
     */
    orderBy?: StaticOfferingOrderByWithRelationInput | StaticOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaticOfferings.
     */
    cursor?: StaticOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaticOfferings.
     */
    distinct?: StaticOfferingScalarFieldEnum | StaticOfferingScalarFieldEnum[]
  }

  /**
   * StaticOffering findMany
   */
  export type StaticOfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * Filter, which StaticOfferings to fetch.
     */
    where?: StaticOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticOfferings to fetch.
     */
    orderBy?: StaticOfferingOrderByWithRelationInput | StaticOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaticOfferings.
     */
    cursor?: StaticOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticOfferings.
     */
    skip?: number
    distinct?: StaticOfferingScalarFieldEnum | StaticOfferingScalarFieldEnum[]
  }

  /**
   * StaticOffering create
   */
  export type StaticOfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a StaticOffering.
     */
    data: XOR<StaticOfferingCreateInput, StaticOfferingUncheckedCreateInput>
  }

  /**
   * StaticOffering createMany
   */
  export type StaticOfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaticOfferings.
     */
    data: StaticOfferingCreateManyInput | StaticOfferingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaticOffering createManyAndReturn
   */
  export type StaticOfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * The data used to create many StaticOfferings.
     */
    data: StaticOfferingCreateManyInput | StaticOfferingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaticOffering update
   */
  export type StaticOfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a StaticOffering.
     */
    data: XOR<StaticOfferingUpdateInput, StaticOfferingUncheckedUpdateInput>
    /**
     * Choose, which StaticOffering to update.
     */
    where: StaticOfferingWhereUniqueInput
  }

  /**
   * StaticOffering updateMany
   */
  export type StaticOfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaticOfferings.
     */
    data: XOR<StaticOfferingUpdateManyMutationInput, StaticOfferingUncheckedUpdateManyInput>
    /**
     * Filter which StaticOfferings to update
     */
    where?: StaticOfferingWhereInput
    /**
     * Limit how many StaticOfferings to update.
     */
    limit?: number
  }

  /**
   * StaticOffering updateManyAndReturn
   */
  export type StaticOfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * The data used to update StaticOfferings.
     */
    data: XOR<StaticOfferingUpdateManyMutationInput, StaticOfferingUncheckedUpdateManyInput>
    /**
     * Filter which StaticOfferings to update
     */
    where?: StaticOfferingWhereInput
    /**
     * Limit how many StaticOfferings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaticOffering upsert
   */
  export type StaticOfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the StaticOffering to update in case it exists.
     */
    where: StaticOfferingWhereUniqueInput
    /**
     * In case the StaticOffering found by the `where` argument doesn't exist, create a new StaticOffering with this data.
     */
    create: XOR<StaticOfferingCreateInput, StaticOfferingUncheckedCreateInput>
    /**
     * In case the StaticOffering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaticOfferingUpdateInput, StaticOfferingUncheckedUpdateInput>
  }

  /**
   * StaticOffering delete
   */
  export type StaticOfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
    /**
     * Filter which StaticOffering to delete.
     */
    where: StaticOfferingWhereUniqueInput
  }

  /**
   * StaticOffering deleteMany
   */
  export type StaticOfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaticOfferings to delete
     */
    where?: StaticOfferingWhereInput
    /**
     * Limit how many StaticOfferings to delete.
     */
    limit?: number
  }

  /**
   * StaticOffering without action
   */
  export type StaticOfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticOffering
     */
    select?: StaticOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticOffering
     */
    omit?: StaticOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticOfferingInclude<ExtArgs> | null
  }


  /**
   * Model DrinkSpecial
   */

  export type AggregateDrinkSpecial = {
    _count: DrinkSpecialCountAggregateOutputType | null
    _avg: DrinkSpecialAvgAggregateOutputType | null
    _sum: DrinkSpecialSumAggregateOutputType | null
    _min: DrinkSpecialMinAggregateOutputType | null
    _max: DrinkSpecialMaxAggregateOutputType | null
  }

  export type DrinkSpecialAvgAggregateOutputType = {
    daysOfWeek: number | null
  }

  export type DrinkSpecialSumAggregateOutputType = {
    daysOfWeek: number[]
  }

  export type DrinkSpecialMinAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DrinkSpecialMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DrinkSpecialCountAggregateOutputType = {
    id: number
    barId: number
    name: number
    description: number
    startTime: number
    endTime: number
    daysOfWeek: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DrinkSpecialAvgAggregateInputType = {
    daysOfWeek?: true
  }

  export type DrinkSpecialSumAggregateInputType = {
    daysOfWeek?: true
  }

  export type DrinkSpecialMinAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DrinkSpecialMaxAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DrinkSpecialCountAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    daysOfWeek?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DrinkSpecialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrinkSpecial to aggregate.
     */
    where?: DrinkSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrinkSpecials to fetch.
     */
    orderBy?: DrinkSpecialOrderByWithRelationInput | DrinkSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrinkSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrinkSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrinkSpecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DrinkSpecials
    **/
    _count?: true | DrinkSpecialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrinkSpecialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrinkSpecialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrinkSpecialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrinkSpecialMaxAggregateInputType
  }

  export type GetDrinkSpecialAggregateType<T extends DrinkSpecialAggregateArgs> = {
        [P in keyof T & keyof AggregateDrinkSpecial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrinkSpecial[P]>
      : GetScalarType<T[P], AggregateDrinkSpecial[P]>
  }




  export type DrinkSpecialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrinkSpecialWhereInput
    orderBy?: DrinkSpecialOrderByWithAggregationInput | DrinkSpecialOrderByWithAggregationInput[]
    by: DrinkSpecialScalarFieldEnum[] | DrinkSpecialScalarFieldEnum
    having?: DrinkSpecialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrinkSpecialCountAggregateInputType | true
    _avg?: DrinkSpecialAvgAggregateInputType
    _sum?: DrinkSpecialSumAggregateInputType
    _min?: DrinkSpecialMinAggregateInputType
    _max?: DrinkSpecialMaxAggregateInputType
  }

  export type DrinkSpecialGroupByOutputType = {
    id: string
    barId: string
    name: string
    description: string | null
    startTime: string
    endTime: string
    daysOfWeek: number[]
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: DrinkSpecialCountAggregateOutputType | null
    _avg: DrinkSpecialAvgAggregateOutputType | null
    _sum: DrinkSpecialSumAggregateOutputType | null
    _min: DrinkSpecialMinAggregateOutputType | null
    _max: DrinkSpecialMaxAggregateOutputType | null
  }

  type GetDrinkSpecialGroupByPayload<T extends DrinkSpecialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrinkSpecialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrinkSpecialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrinkSpecialGroupByOutputType[P]>
            : GetScalarType<T[P], DrinkSpecialGroupByOutputType[P]>
        }
      >
    >


  export type DrinkSpecialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drinkSpecial"]>

  export type DrinkSpecialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drinkSpecial"]>

  export type DrinkSpecialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drinkSpecial"]>

  export type DrinkSpecialSelectScalar = {
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DrinkSpecialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "name" | "description" | "startTime" | "endTime" | "daysOfWeek" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["drinkSpecial"]>
  export type DrinkSpecialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type DrinkSpecialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type DrinkSpecialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $DrinkSpecialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DrinkSpecial"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      name: string
      description: string | null
      startTime: string
      endTime: string
      daysOfWeek: number[]
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["drinkSpecial"]>
    composites: {}
  }

  type DrinkSpecialGetPayload<S extends boolean | null | undefined | DrinkSpecialDefaultArgs> = $Result.GetResult<Prisma.$DrinkSpecialPayload, S>

  type DrinkSpecialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DrinkSpecialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DrinkSpecialCountAggregateInputType | true
    }

  export interface DrinkSpecialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DrinkSpecial'], meta: { name: 'DrinkSpecial' } }
    /**
     * Find zero or one DrinkSpecial that matches the filter.
     * @param {DrinkSpecialFindUniqueArgs} args - Arguments to find a DrinkSpecial
     * @example
     * // Get one DrinkSpecial
     * const drinkSpecial = await prisma.drinkSpecial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrinkSpecialFindUniqueArgs>(args: SelectSubset<T, DrinkSpecialFindUniqueArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DrinkSpecial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DrinkSpecialFindUniqueOrThrowArgs} args - Arguments to find a DrinkSpecial
     * @example
     * // Get one DrinkSpecial
     * const drinkSpecial = await prisma.drinkSpecial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrinkSpecialFindUniqueOrThrowArgs>(args: SelectSubset<T, DrinkSpecialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrinkSpecial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialFindFirstArgs} args - Arguments to find a DrinkSpecial
     * @example
     * // Get one DrinkSpecial
     * const drinkSpecial = await prisma.drinkSpecial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrinkSpecialFindFirstArgs>(args?: SelectSubset<T, DrinkSpecialFindFirstArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrinkSpecial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialFindFirstOrThrowArgs} args - Arguments to find a DrinkSpecial
     * @example
     * // Get one DrinkSpecial
     * const drinkSpecial = await prisma.drinkSpecial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrinkSpecialFindFirstOrThrowArgs>(args?: SelectSubset<T, DrinkSpecialFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DrinkSpecials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DrinkSpecials
     * const drinkSpecials = await prisma.drinkSpecial.findMany()
     * 
     * // Get first 10 DrinkSpecials
     * const drinkSpecials = await prisma.drinkSpecial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drinkSpecialWithIdOnly = await prisma.drinkSpecial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrinkSpecialFindManyArgs>(args?: SelectSubset<T, DrinkSpecialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DrinkSpecial.
     * @param {DrinkSpecialCreateArgs} args - Arguments to create a DrinkSpecial.
     * @example
     * // Create one DrinkSpecial
     * const DrinkSpecial = await prisma.drinkSpecial.create({
     *   data: {
     *     // ... data to create a DrinkSpecial
     *   }
     * })
     * 
     */
    create<T extends DrinkSpecialCreateArgs>(args: SelectSubset<T, DrinkSpecialCreateArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DrinkSpecials.
     * @param {DrinkSpecialCreateManyArgs} args - Arguments to create many DrinkSpecials.
     * @example
     * // Create many DrinkSpecials
     * const drinkSpecial = await prisma.drinkSpecial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrinkSpecialCreateManyArgs>(args?: SelectSubset<T, DrinkSpecialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DrinkSpecials and returns the data saved in the database.
     * @param {DrinkSpecialCreateManyAndReturnArgs} args - Arguments to create many DrinkSpecials.
     * @example
     * // Create many DrinkSpecials
     * const drinkSpecial = await prisma.drinkSpecial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DrinkSpecials and only return the `id`
     * const drinkSpecialWithIdOnly = await prisma.drinkSpecial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DrinkSpecialCreateManyAndReturnArgs>(args?: SelectSubset<T, DrinkSpecialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DrinkSpecial.
     * @param {DrinkSpecialDeleteArgs} args - Arguments to delete one DrinkSpecial.
     * @example
     * // Delete one DrinkSpecial
     * const DrinkSpecial = await prisma.drinkSpecial.delete({
     *   where: {
     *     // ... filter to delete one DrinkSpecial
     *   }
     * })
     * 
     */
    delete<T extends DrinkSpecialDeleteArgs>(args: SelectSubset<T, DrinkSpecialDeleteArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DrinkSpecial.
     * @param {DrinkSpecialUpdateArgs} args - Arguments to update one DrinkSpecial.
     * @example
     * // Update one DrinkSpecial
     * const drinkSpecial = await prisma.drinkSpecial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrinkSpecialUpdateArgs>(args: SelectSubset<T, DrinkSpecialUpdateArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DrinkSpecials.
     * @param {DrinkSpecialDeleteManyArgs} args - Arguments to filter DrinkSpecials to delete.
     * @example
     * // Delete a few DrinkSpecials
     * const { count } = await prisma.drinkSpecial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrinkSpecialDeleteManyArgs>(args?: SelectSubset<T, DrinkSpecialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrinkSpecials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DrinkSpecials
     * const drinkSpecial = await prisma.drinkSpecial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrinkSpecialUpdateManyArgs>(args: SelectSubset<T, DrinkSpecialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrinkSpecials and returns the data updated in the database.
     * @param {DrinkSpecialUpdateManyAndReturnArgs} args - Arguments to update many DrinkSpecials.
     * @example
     * // Update many DrinkSpecials
     * const drinkSpecial = await prisma.drinkSpecial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DrinkSpecials and only return the `id`
     * const drinkSpecialWithIdOnly = await prisma.drinkSpecial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DrinkSpecialUpdateManyAndReturnArgs>(args: SelectSubset<T, DrinkSpecialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DrinkSpecial.
     * @param {DrinkSpecialUpsertArgs} args - Arguments to update or create a DrinkSpecial.
     * @example
     * // Update or create a DrinkSpecial
     * const drinkSpecial = await prisma.drinkSpecial.upsert({
     *   create: {
     *     // ... data to create a DrinkSpecial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DrinkSpecial we want to update
     *   }
     * })
     */
    upsert<T extends DrinkSpecialUpsertArgs>(args: SelectSubset<T, DrinkSpecialUpsertArgs<ExtArgs>>): Prisma__DrinkSpecialClient<$Result.GetResult<Prisma.$DrinkSpecialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DrinkSpecials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialCountArgs} args - Arguments to filter DrinkSpecials to count.
     * @example
     * // Count the number of DrinkSpecials
     * const count = await prisma.drinkSpecial.count({
     *   where: {
     *     // ... the filter for the DrinkSpecials we want to count
     *   }
     * })
    **/
    count<T extends DrinkSpecialCountArgs>(
      args?: Subset<T, DrinkSpecialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrinkSpecialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DrinkSpecial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrinkSpecialAggregateArgs>(args: Subset<T, DrinkSpecialAggregateArgs>): Prisma.PrismaPromise<GetDrinkSpecialAggregateType<T>>

    /**
     * Group by DrinkSpecial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrinkSpecialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrinkSpecialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrinkSpecialGroupByArgs['orderBy'] }
        : { orderBy?: DrinkSpecialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrinkSpecialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrinkSpecialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DrinkSpecial model
   */
  readonly fields: DrinkSpecialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DrinkSpecial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrinkSpecialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DrinkSpecial model
   */
  interface DrinkSpecialFieldRefs {
    readonly id: FieldRef<"DrinkSpecial", 'String'>
    readonly barId: FieldRef<"DrinkSpecial", 'String'>
    readonly name: FieldRef<"DrinkSpecial", 'String'>
    readonly description: FieldRef<"DrinkSpecial", 'String'>
    readonly startTime: FieldRef<"DrinkSpecial", 'String'>
    readonly endTime: FieldRef<"DrinkSpecial", 'String'>
    readonly daysOfWeek: FieldRef<"DrinkSpecial", 'Int[]'>
    readonly active: FieldRef<"DrinkSpecial", 'Boolean'>
    readonly createdAt: FieldRef<"DrinkSpecial", 'DateTime'>
    readonly updatedAt: FieldRef<"DrinkSpecial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DrinkSpecial findUnique
   */
  export type DrinkSpecialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * Filter, which DrinkSpecial to fetch.
     */
    where: DrinkSpecialWhereUniqueInput
  }

  /**
   * DrinkSpecial findUniqueOrThrow
   */
  export type DrinkSpecialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * Filter, which DrinkSpecial to fetch.
     */
    where: DrinkSpecialWhereUniqueInput
  }

  /**
   * DrinkSpecial findFirst
   */
  export type DrinkSpecialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * Filter, which DrinkSpecial to fetch.
     */
    where?: DrinkSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrinkSpecials to fetch.
     */
    orderBy?: DrinkSpecialOrderByWithRelationInput | DrinkSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrinkSpecials.
     */
    cursor?: DrinkSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrinkSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrinkSpecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrinkSpecials.
     */
    distinct?: DrinkSpecialScalarFieldEnum | DrinkSpecialScalarFieldEnum[]
  }

  /**
   * DrinkSpecial findFirstOrThrow
   */
  export type DrinkSpecialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * Filter, which DrinkSpecial to fetch.
     */
    where?: DrinkSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrinkSpecials to fetch.
     */
    orderBy?: DrinkSpecialOrderByWithRelationInput | DrinkSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrinkSpecials.
     */
    cursor?: DrinkSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrinkSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrinkSpecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrinkSpecials.
     */
    distinct?: DrinkSpecialScalarFieldEnum | DrinkSpecialScalarFieldEnum[]
  }

  /**
   * DrinkSpecial findMany
   */
  export type DrinkSpecialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * Filter, which DrinkSpecials to fetch.
     */
    where?: DrinkSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrinkSpecials to fetch.
     */
    orderBy?: DrinkSpecialOrderByWithRelationInput | DrinkSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DrinkSpecials.
     */
    cursor?: DrinkSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrinkSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrinkSpecials.
     */
    skip?: number
    distinct?: DrinkSpecialScalarFieldEnum | DrinkSpecialScalarFieldEnum[]
  }

  /**
   * DrinkSpecial create
   */
  export type DrinkSpecialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * The data needed to create a DrinkSpecial.
     */
    data: XOR<DrinkSpecialCreateInput, DrinkSpecialUncheckedCreateInput>
  }

  /**
   * DrinkSpecial createMany
   */
  export type DrinkSpecialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DrinkSpecials.
     */
    data: DrinkSpecialCreateManyInput | DrinkSpecialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DrinkSpecial createManyAndReturn
   */
  export type DrinkSpecialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * The data used to create many DrinkSpecials.
     */
    data: DrinkSpecialCreateManyInput | DrinkSpecialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DrinkSpecial update
   */
  export type DrinkSpecialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * The data needed to update a DrinkSpecial.
     */
    data: XOR<DrinkSpecialUpdateInput, DrinkSpecialUncheckedUpdateInput>
    /**
     * Choose, which DrinkSpecial to update.
     */
    where: DrinkSpecialWhereUniqueInput
  }

  /**
   * DrinkSpecial updateMany
   */
  export type DrinkSpecialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DrinkSpecials.
     */
    data: XOR<DrinkSpecialUpdateManyMutationInput, DrinkSpecialUncheckedUpdateManyInput>
    /**
     * Filter which DrinkSpecials to update
     */
    where?: DrinkSpecialWhereInput
    /**
     * Limit how many DrinkSpecials to update.
     */
    limit?: number
  }

  /**
   * DrinkSpecial updateManyAndReturn
   */
  export type DrinkSpecialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * The data used to update DrinkSpecials.
     */
    data: XOR<DrinkSpecialUpdateManyMutationInput, DrinkSpecialUncheckedUpdateManyInput>
    /**
     * Filter which DrinkSpecials to update
     */
    where?: DrinkSpecialWhereInput
    /**
     * Limit how many DrinkSpecials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DrinkSpecial upsert
   */
  export type DrinkSpecialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * The filter to search for the DrinkSpecial to update in case it exists.
     */
    where: DrinkSpecialWhereUniqueInput
    /**
     * In case the DrinkSpecial found by the `where` argument doesn't exist, create a new DrinkSpecial with this data.
     */
    create: XOR<DrinkSpecialCreateInput, DrinkSpecialUncheckedCreateInput>
    /**
     * In case the DrinkSpecial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrinkSpecialUpdateInput, DrinkSpecialUncheckedUpdateInput>
  }

  /**
   * DrinkSpecial delete
   */
  export type DrinkSpecialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
    /**
     * Filter which DrinkSpecial to delete.
     */
    where: DrinkSpecialWhereUniqueInput
  }

  /**
   * DrinkSpecial deleteMany
   */
  export type DrinkSpecialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrinkSpecials to delete
     */
    where?: DrinkSpecialWhereInput
    /**
     * Limit how many DrinkSpecials to delete.
     */
    limit?: number
  }

  /**
   * DrinkSpecial without action
   */
  export type DrinkSpecialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrinkSpecial
     */
    select?: DrinkSpecialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrinkSpecial
     */
    omit?: DrinkSpecialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrinkSpecialInclude<ExtArgs> | null
  }


  /**
   * Model FoodOffering
   */

  export type AggregateFoodOffering = {
    _count: FoodOfferingCountAggregateOutputType | null
    _avg: FoodOfferingAvgAggregateOutputType | null
    _sum: FoodOfferingSumAggregateOutputType | null
    _min: FoodOfferingMinAggregateOutputType | null
    _max: FoodOfferingMaxAggregateOutputType | null
  }

  export type FoodOfferingAvgAggregateOutputType = {
    specialDays: number | null
  }

  export type FoodOfferingSumAggregateOutputType = {
    specialDays: number[]
  }

  export type FoodOfferingMinAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    description: string | null
    isSpecial: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodOfferingMaxAggregateOutputType = {
    id: string | null
    barId: string | null
    name: string | null
    description: string | null
    isSpecial: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodOfferingCountAggregateOutputType = {
    id: number
    barId: number
    name: number
    description: number
    specialDays: number
    isSpecial: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodOfferingAvgAggregateInputType = {
    specialDays?: true
  }

  export type FoodOfferingSumAggregateInputType = {
    specialDays?: true
  }

  export type FoodOfferingMinAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    description?: true
    isSpecial?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodOfferingMaxAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    description?: true
    isSpecial?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodOfferingCountAggregateInputType = {
    id?: true
    barId?: true
    name?: true
    description?: true
    specialDays?: true
    isSpecial?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodOfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodOffering to aggregate.
     */
    where?: FoodOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodOfferings to fetch.
     */
    orderBy?: FoodOfferingOrderByWithRelationInput | FoodOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodOfferings
    **/
    _count?: true | FoodOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodOfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodOfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodOfferingMaxAggregateInputType
  }

  export type GetFoodOfferingAggregateType<T extends FoodOfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodOffering[P]>
      : GetScalarType<T[P], AggregateFoodOffering[P]>
  }




  export type FoodOfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodOfferingWhereInput
    orderBy?: FoodOfferingOrderByWithAggregationInput | FoodOfferingOrderByWithAggregationInput[]
    by: FoodOfferingScalarFieldEnum[] | FoodOfferingScalarFieldEnum
    having?: FoodOfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodOfferingCountAggregateInputType | true
    _avg?: FoodOfferingAvgAggregateInputType
    _sum?: FoodOfferingSumAggregateInputType
    _min?: FoodOfferingMinAggregateInputType
    _max?: FoodOfferingMaxAggregateInputType
  }

  export type FoodOfferingGroupByOutputType = {
    id: string
    barId: string
    name: string
    description: string | null
    specialDays: number[]
    isSpecial: boolean
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: FoodOfferingCountAggregateOutputType | null
    _avg: FoodOfferingAvgAggregateOutputType | null
    _sum: FoodOfferingSumAggregateOutputType | null
    _min: FoodOfferingMinAggregateOutputType | null
    _max: FoodOfferingMaxAggregateOutputType | null
  }

  type GetFoodOfferingGroupByPayload<T extends FoodOfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodOfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodOfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodOfferingGroupByOutputType[P]>
            : GetScalarType<T[P], FoodOfferingGroupByOutputType[P]>
        }
      >
    >


  export type FoodOfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    specialDays?: boolean
    isSpecial?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodOffering"]>

  export type FoodOfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    specialDays?: boolean
    isSpecial?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodOffering"]>

  export type FoodOfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    specialDays?: boolean
    isSpecial?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodOffering"]>

  export type FoodOfferingSelectScalar = {
    id?: boolean
    barId?: boolean
    name?: boolean
    description?: boolean
    specialDays?: boolean
    isSpecial?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodOfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barId" | "name" | "description" | "specialDays" | "isSpecial" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["foodOffering"]>
  export type FoodOfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type FoodOfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }
  export type FoodOfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bar?: boolean | BarDefaultArgs<ExtArgs>
  }

  export type $FoodOfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodOffering"
    objects: {
      bar: Prisma.$BarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barId: string
      name: string
      description: string | null
      specialDays: number[]
      isSpecial: boolean
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodOffering"]>
    composites: {}
  }

  type FoodOfferingGetPayload<S extends boolean | null | undefined | FoodOfferingDefaultArgs> = $Result.GetResult<Prisma.$FoodOfferingPayload, S>

  type FoodOfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodOfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodOfferingCountAggregateInputType | true
    }

  export interface FoodOfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodOffering'], meta: { name: 'FoodOffering' } }
    /**
     * Find zero or one FoodOffering that matches the filter.
     * @param {FoodOfferingFindUniqueArgs} args - Arguments to find a FoodOffering
     * @example
     * // Get one FoodOffering
     * const foodOffering = await prisma.foodOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodOfferingFindUniqueArgs>(args: SelectSubset<T, FoodOfferingFindUniqueArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodOffering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodOfferingFindUniqueOrThrowArgs} args - Arguments to find a FoodOffering
     * @example
     * // Get one FoodOffering
     * const foodOffering = await prisma.foodOffering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodOfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodOfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingFindFirstArgs} args - Arguments to find a FoodOffering
     * @example
     * // Get one FoodOffering
     * const foodOffering = await prisma.foodOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodOfferingFindFirstArgs>(args?: SelectSubset<T, FoodOfferingFindFirstArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodOffering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingFindFirstOrThrowArgs} args - Arguments to find a FoodOffering
     * @example
     * // Get one FoodOffering
     * const foodOffering = await prisma.foodOffering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodOfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodOfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodOfferings
     * const foodOfferings = await prisma.foodOffering.findMany()
     * 
     * // Get first 10 FoodOfferings
     * const foodOfferings = await prisma.foodOffering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodOfferingWithIdOnly = await prisma.foodOffering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodOfferingFindManyArgs>(args?: SelectSubset<T, FoodOfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodOffering.
     * @param {FoodOfferingCreateArgs} args - Arguments to create a FoodOffering.
     * @example
     * // Create one FoodOffering
     * const FoodOffering = await prisma.foodOffering.create({
     *   data: {
     *     // ... data to create a FoodOffering
     *   }
     * })
     * 
     */
    create<T extends FoodOfferingCreateArgs>(args: SelectSubset<T, FoodOfferingCreateArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodOfferings.
     * @param {FoodOfferingCreateManyArgs} args - Arguments to create many FoodOfferings.
     * @example
     * // Create many FoodOfferings
     * const foodOffering = await prisma.foodOffering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodOfferingCreateManyArgs>(args?: SelectSubset<T, FoodOfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodOfferings and returns the data saved in the database.
     * @param {FoodOfferingCreateManyAndReturnArgs} args - Arguments to create many FoodOfferings.
     * @example
     * // Create many FoodOfferings
     * const foodOffering = await prisma.foodOffering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodOfferings and only return the `id`
     * const foodOfferingWithIdOnly = await prisma.foodOffering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodOfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodOfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodOffering.
     * @param {FoodOfferingDeleteArgs} args - Arguments to delete one FoodOffering.
     * @example
     * // Delete one FoodOffering
     * const FoodOffering = await prisma.foodOffering.delete({
     *   where: {
     *     // ... filter to delete one FoodOffering
     *   }
     * })
     * 
     */
    delete<T extends FoodOfferingDeleteArgs>(args: SelectSubset<T, FoodOfferingDeleteArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodOffering.
     * @param {FoodOfferingUpdateArgs} args - Arguments to update one FoodOffering.
     * @example
     * // Update one FoodOffering
     * const foodOffering = await prisma.foodOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodOfferingUpdateArgs>(args: SelectSubset<T, FoodOfferingUpdateArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodOfferings.
     * @param {FoodOfferingDeleteManyArgs} args - Arguments to filter FoodOfferings to delete.
     * @example
     * // Delete a few FoodOfferings
     * const { count } = await prisma.foodOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodOfferingDeleteManyArgs>(args?: SelectSubset<T, FoodOfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodOfferings
     * const foodOffering = await prisma.foodOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodOfferingUpdateManyArgs>(args: SelectSubset<T, FoodOfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodOfferings and returns the data updated in the database.
     * @param {FoodOfferingUpdateManyAndReturnArgs} args - Arguments to update many FoodOfferings.
     * @example
     * // Update many FoodOfferings
     * const foodOffering = await prisma.foodOffering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodOfferings and only return the `id`
     * const foodOfferingWithIdOnly = await prisma.foodOffering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodOfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodOfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodOffering.
     * @param {FoodOfferingUpsertArgs} args - Arguments to update or create a FoodOffering.
     * @example
     * // Update or create a FoodOffering
     * const foodOffering = await prisma.foodOffering.upsert({
     *   create: {
     *     // ... data to create a FoodOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodOffering we want to update
     *   }
     * })
     */
    upsert<T extends FoodOfferingUpsertArgs>(args: SelectSubset<T, FoodOfferingUpsertArgs<ExtArgs>>): Prisma__FoodOfferingClient<$Result.GetResult<Prisma.$FoodOfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingCountArgs} args - Arguments to filter FoodOfferings to count.
     * @example
     * // Count the number of FoodOfferings
     * const count = await prisma.foodOffering.count({
     *   where: {
     *     // ... the filter for the FoodOfferings we want to count
     *   }
     * })
    **/
    count<T extends FoodOfferingCountArgs>(
      args?: Subset<T, FoodOfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodOfferingAggregateArgs>(args: Subset<T, FoodOfferingAggregateArgs>): Prisma.PrismaPromise<GetFoodOfferingAggregateType<T>>

    /**
     * Group by FoodOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodOfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodOfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodOfferingGroupByArgs['orderBy'] }
        : { orderBy?: FoodOfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodOfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodOffering model
   */
  readonly fields: FoodOfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodOfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bar<T extends BarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarDefaultArgs<ExtArgs>>): Prisma__BarClient<$Result.GetResult<Prisma.$BarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodOffering model
   */
  interface FoodOfferingFieldRefs {
    readonly id: FieldRef<"FoodOffering", 'String'>
    readonly barId: FieldRef<"FoodOffering", 'String'>
    readonly name: FieldRef<"FoodOffering", 'String'>
    readonly description: FieldRef<"FoodOffering", 'String'>
    readonly specialDays: FieldRef<"FoodOffering", 'Int[]'>
    readonly isSpecial: FieldRef<"FoodOffering", 'Boolean'>
    readonly active: FieldRef<"FoodOffering", 'Boolean'>
    readonly createdAt: FieldRef<"FoodOffering", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodOffering", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodOffering findUnique
   */
  export type FoodOfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * Filter, which FoodOffering to fetch.
     */
    where: FoodOfferingWhereUniqueInput
  }

  /**
   * FoodOffering findUniqueOrThrow
   */
  export type FoodOfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * Filter, which FoodOffering to fetch.
     */
    where: FoodOfferingWhereUniqueInput
  }

  /**
   * FoodOffering findFirst
   */
  export type FoodOfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * Filter, which FoodOffering to fetch.
     */
    where?: FoodOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodOfferings to fetch.
     */
    orderBy?: FoodOfferingOrderByWithRelationInput | FoodOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodOfferings.
     */
    cursor?: FoodOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodOfferings.
     */
    distinct?: FoodOfferingScalarFieldEnum | FoodOfferingScalarFieldEnum[]
  }

  /**
   * FoodOffering findFirstOrThrow
   */
  export type FoodOfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * Filter, which FoodOffering to fetch.
     */
    where?: FoodOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodOfferings to fetch.
     */
    orderBy?: FoodOfferingOrderByWithRelationInput | FoodOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodOfferings.
     */
    cursor?: FoodOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodOfferings.
     */
    distinct?: FoodOfferingScalarFieldEnum | FoodOfferingScalarFieldEnum[]
  }

  /**
   * FoodOffering findMany
   */
  export type FoodOfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * Filter, which FoodOfferings to fetch.
     */
    where?: FoodOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodOfferings to fetch.
     */
    orderBy?: FoodOfferingOrderByWithRelationInput | FoodOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodOfferings.
     */
    cursor?: FoodOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodOfferings.
     */
    skip?: number
    distinct?: FoodOfferingScalarFieldEnum | FoodOfferingScalarFieldEnum[]
  }

  /**
   * FoodOffering create
   */
  export type FoodOfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodOffering.
     */
    data: XOR<FoodOfferingCreateInput, FoodOfferingUncheckedCreateInput>
  }

  /**
   * FoodOffering createMany
   */
  export type FoodOfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodOfferings.
     */
    data: FoodOfferingCreateManyInput | FoodOfferingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodOffering createManyAndReturn
   */
  export type FoodOfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * The data used to create many FoodOfferings.
     */
    data: FoodOfferingCreateManyInput | FoodOfferingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodOffering update
   */
  export type FoodOfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodOffering.
     */
    data: XOR<FoodOfferingUpdateInput, FoodOfferingUncheckedUpdateInput>
    /**
     * Choose, which FoodOffering to update.
     */
    where: FoodOfferingWhereUniqueInput
  }

  /**
   * FoodOffering updateMany
   */
  export type FoodOfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodOfferings.
     */
    data: XOR<FoodOfferingUpdateManyMutationInput, FoodOfferingUncheckedUpdateManyInput>
    /**
     * Filter which FoodOfferings to update
     */
    where?: FoodOfferingWhereInput
    /**
     * Limit how many FoodOfferings to update.
     */
    limit?: number
  }

  /**
   * FoodOffering updateManyAndReturn
   */
  export type FoodOfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * The data used to update FoodOfferings.
     */
    data: XOR<FoodOfferingUpdateManyMutationInput, FoodOfferingUncheckedUpdateManyInput>
    /**
     * Filter which FoodOfferings to update
     */
    where?: FoodOfferingWhereInput
    /**
     * Limit how many FoodOfferings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodOffering upsert
   */
  export type FoodOfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodOffering to update in case it exists.
     */
    where: FoodOfferingWhereUniqueInput
    /**
     * In case the FoodOffering found by the `where` argument doesn't exist, create a new FoodOffering with this data.
     */
    create: XOR<FoodOfferingCreateInput, FoodOfferingUncheckedCreateInput>
    /**
     * In case the FoodOffering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodOfferingUpdateInput, FoodOfferingUncheckedUpdateInput>
  }

  /**
   * FoodOffering delete
   */
  export type FoodOfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
    /**
     * Filter which FoodOffering to delete.
     */
    where: FoodOfferingWhereUniqueInput
  }

  /**
   * FoodOffering deleteMany
   */
  export type FoodOfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodOfferings to delete
     */
    where?: FoodOfferingWhereInput
    /**
     * Limit how many FoodOfferings to delete.
     */
    limit?: number
  }

  /**
   * FoodOffering without action
   */
  export type FoodOfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodOffering
     */
    select?: FoodOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodOffering
     */
    omit?: FoodOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodOfferingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    disabled: 'disabled',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OwnerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    phone: 'phone',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    allowFreeListings: 'allowFreeListings',
    role: 'role'
  };

  export type OwnerScalarFieldEnum = (typeof OwnerScalarFieldEnum)[keyof typeof OwnerScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    plan: 'plan',
    status: 'status',
    paypalCustomerId: 'paypalCustomerId',
    paypalSubscriptionId: 'paypalSubscriptionId',
    priceId: 'priceId',
    currentPeriodEnd: 'currentPeriodEnd',
    trialEndsAt: 'trialEndsAt',
    trialReminderSentAt: 'trialReminderSentAt',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const BarScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    address: 'address',
    city: 'city',
    cityNormalized: 'cityNormalized',
    state: 'state',
    zipCode: 'zipCode',
    barType: 'barType',
    subscriptionTier: 'subscriptionTier',
    inventoryAddOnEnabled: 'inventoryAddOnEnabled',
    checkInReward: 'checkInReward',
    neighborhood: 'neighborhood',
    neighborhoodNormalized: 'neighborhoodNormalized',
    latitude: 'latitude',
    longitude: 'longitude',
    phone: 'phone',
    website: 'website',
    logo: 'logo',
    photos: 'photos',
    hours: 'hours',
    isActive: 'isActive',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileViews: 'profileViews',
    searchAppearances: 'searchAppearances'
  };

  export type BarScalarFieldEnum = (typeof BarScalarFieldEnum)[keyof typeof BarScalarFieldEnum]


  export const OfferingScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    dayOfWeek: 'dayOfWeek',
    category: 'category',
    customTitle: 'customTitle',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    recurrence: 'recurrence',
    startDate: 'startDate',
    endDate: 'endDate',
    tags: 'tags',
    coverCharge: 'coverCharge',
    prize: 'prize',
    ageRestriction: 'ageRestriction',
    isActive: 'isActive',
    isSpecial: 'isSpecial',
    isNew: 'isNew',
    specialExpiresAt: 'specialExpiresAt',
    newUntil: 'newUntil',
    expiresAt: 'expiresAt',
    clickCount: 'clickCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferingScalarFieldEnum = (typeof OfferingScalarFieldEnum)[keyof typeof OfferingScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    title: 'title',
    description: 'description',
    category: 'category',
    startDate: 'startDate',
    endDate: 'endDate',
    startTime: 'startTime',
    endTime: 'endTime',
    isRecurring: 'isRecurring',
    recurrenceRule: 'recurrenceRule',
    recurrence: 'recurrence',
    tags: 'tags',
    isActive: 'isActive',
    isSpecial: 'isSpecial',
    isNew: 'isNew',
    specialExpiresAt: 'specialExpiresAt',
    newUntil: 'newUntil',
    autoExpire: 'autoExpire',
    coverCharge: 'coverCharge',
    prize: 'prize',
    ageRestriction: 'ageRestriction',
    clickCount: 'clickCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    barId: 'barId',
    createdAt: 'createdAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const ActivityCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    icon: 'icon',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ActivityCategoryScalarFieldEnum = (typeof ActivityCategoryScalarFieldEnum)[keyof typeof ActivityCategoryScalarFieldEnum]


  export const CategoryRequestScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    ownerId: 'ownerId',
    requestedByEmail: 'requestedByEmail',
    requestedByName: 'requestedByName',
    category: 'category',
    status: 'status',
    reviewedAt: 'reviewedAt',
    reviewedByEmail: 'reviewedByEmail',
    createdAt: 'createdAt'
  };

  export type CategoryRequestScalarFieldEnum = (typeof CategoryRequestScalarFieldEnum)[keyof typeof CategoryRequestScalarFieldEnum]


  export const OwnerPasswordResetScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type OwnerPasswordResetScalarFieldEnum = (typeof OwnerPasswordResetScalarFieldEnum)[keyof typeof OwnerPasswordResetScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    isActive: 'isActive',
    maxRedemptions: 'maxRedemptions',
    usedCount: 'usedCount',
    expiresAt: 'expiresAt',
    grantPlan: 'grantPlan',
    grantMonths: 'grantMonths',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const PromoRedemptionScalarFieldEnum: {
    id: 'id',
    promoCodeId: 'promoCodeId',
    ownerId: 'ownerId',
    redeemedAt: 'redeemedAt'
  };

  export type PromoRedemptionScalarFieldEnum = (typeof PromoRedemptionScalarFieldEnum)[keyof typeof PromoRedemptionScalarFieldEnum]


  export const BarAnalyticsScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    date: 'date',
    dayOfWeek: 'dayOfWeek',
    profileViews: 'profileViews',
    profileClicks: 'profileClicks',
    searchAppears: 'searchAppears',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BarAnalyticsScalarFieldEnum = (typeof BarAnalyticsScalarFieldEnum)[keyof typeof BarAnalyticsScalarFieldEnum]


  export const SearchQueryScalarFieldEnum: {
    id: 'id',
    query: 'query',
    location: 'location',
    category: 'category',
    dayOfWeek: 'dayOfWeek',
    count: 'count',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SearchQueryScalarFieldEnum = (typeof SearchQueryScalarFieldEnum)[keyof typeof SearchQueryScalarFieldEnum]


  export const BarClickScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    source: 'source',
    query: 'query',
    dayOfWeek: 'dayOfWeek',
    createdAt: 'createdAt'
  };

  export type BarClickScalarFieldEnum = (typeof BarClickScalarFieldEnum)[keyof typeof BarClickScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    icon: 'icon',
    tier: 'tier',
    category: 'category',
    requirement: 'requirement',
    color: 'color',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const BarBadgeScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    badgeKey: 'badgeKey',
    awardedAt: 'awardedAt',
    progress: 'progress',
    metadata: 'metadata'
  };

  export type BarBadgeScalarFieldEnum = (typeof BarBadgeScalarFieldEnum)[keyof typeof BarBadgeScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    name: 'name',
    category: 'category',
    bottleSizeMl: 'bottleSizeMl',
    startingQtyBottles: 'startingQtyBottles',
    costPerBottle: 'costPerBottle',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryImportScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    fileName: 'fileName',
    rowsImported: 'rowsImported',
    mapping: 'mapping',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type InventoryImportScalarFieldEnum = (typeof InventoryImportScalarFieldEnum)[keyof typeof InventoryImportScalarFieldEnum]


  export const ShiftUsageScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    userId: 'userId',
    shiftTime: 'shiftTime',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ShiftUsageScalarFieldEnum = (typeof ShiftUsageScalarFieldEnum)[keyof typeof ShiftUsageScalarFieldEnum]


  export const ShiftUsageItemScalarFieldEnum: {
    id: 'id',
    shiftUsageId: 'shiftUsageId',
    inventoryItemId: 'inventoryItemId',
    quantityUsed: 'quantityUsed',
    notes: 'notes'
  };

  export type ShiftUsageItemScalarFieldEnum = (typeof ShiftUsageItemScalarFieldEnum)[keyof typeof ShiftUsageItemScalarFieldEnum]


  export const InventorySnapshotScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    userId: 'userId',
    snapshotDate: 'snapshotDate',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type InventorySnapshotScalarFieldEnum = (typeof InventorySnapshotScalarFieldEnum)[keyof typeof InventorySnapshotScalarFieldEnum]


  export const InventorySnapshotItemScalarFieldEnum: {
    id: 'id',
    snapshotId: 'snapshotId',
    inventoryItemId: 'inventoryItemId',
    quantityOnHand: 'quantityOnHand',
    notes: 'notes'
  };

  export type InventorySnapshotItemScalarFieldEnum = (typeof InventorySnapshotItemScalarFieldEnum)[keyof typeof InventorySnapshotItemScalarFieldEnum]


  export const BottlePhotoScalarFieldEnum: {
    id: 'id',
    snapshotItemId: 'snapshotItemId',
    imageUrl: 'imageUrl',
    estimatedPct: 'estimatedPct',
    estimatedMl: 'estimatedMl',
    modelVersion: 'modelVersion',
    createdAt: 'createdAt'
  };

  export type BottlePhotoScalarFieldEnum = (typeof BottlePhotoScalarFieldEnum)[keyof typeof BottlePhotoScalarFieldEnum]


  export const CostingProfileScalarFieldEnum: {
    id: 'id',
    inventoryItemId: 'inventoryItemId',
    pourSizeOz: 'pourSizeOz',
    menuPrice: 'menuPrice',
    costPerPour: 'costPerPour',
    marginPct: 'marginPct',
    profitPerBottle: 'profitPerBottle',
    createdAt: 'createdAt'
  };

  export type CostingProfileScalarFieldEnum = (typeof CostingProfileScalarFieldEnum)[keyof typeof CostingProfileScalarFieldEnum]


  export const VarianceAlertScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    inventoryItemId: 'inventoryItemId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    expectedMl: 'expectedMl',
    observedMl: 'observedMl',
    varianceMl: 'varianceMl',
    variancePct: 'variancePct',
    severity: 'severity',
    reasonHint: 'reasonHint',
    createdAt: 'createdAt'
  };

  export type VarianceAlertScalarFieldEnum = (typeof VarianceAlertScalarFieldEnum)[keyof typeof VarianceAlertScalarFieldEnum]


  export const BarLicenseScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    ownerId: 'ownerId',
    status: 'status',
    priceCents: 'priceCents',
    currency: 'currency',
    billingCycle: 'billingCycle',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BarLicenseScalarFieldEnum = (typeof BarLicenseScalarFieldEnum)[keyof typeof BarLicenseScalarFieldEnum]


  export const BarVisitScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    userId: 'userId',
    source: 'source',
    verificationMethod: 'verificationMethod',
    clickId: 'clickId',
    promoCodeId: 'promoCodeId',
    metadata: 'metadata',
    visitedAt: 'visitedAt',
    createdAt: 'createdAt'
  };

  export type BarVisitScalarFieldEnum = (typeof BarVisitScalarFieldEnum)[keyof typeof BarVisitScalarFieldEnum]


  export const BarMembershipScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BarMembershipScalarFieldEnum = (typeof BarMembershipScalarFieldEnum)[keyof typeof BarMembershipScalarFieldEnum]


  export const PatronSearchEventScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    query: 'query',
    category: 'category',
    city: 'city',
    createdAt: 'createdAt'
  };

  export type PatronSearchEventScalarFieldEnum = (typeof PatronSearchEventScalarFieldEnum)[keyof typeof PatronSearchEventScalarFieldEnum]


  export const BarActionScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type BarActionScalarFieldEnum = (typeof BarActionScalarFieldEnum)[keyof typeof BarActionScalarFieldEnum]


  export const BarFollowerScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    patronEmail: 'patronEmail',
    createdAt: 'createdAt'
  };

  export type BarFollowerScalarFieldEnum = (typeof BarFollowerScalarFieldEnum)[keyof typeof BarFollowerScalarFieldEnum]


  export const BoostScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    eventId: 'eventId',
    startAt: 'startAt',
    endAt: 'endAt',
    budgetCents: 'budgetCents',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type BoostScalarFieldEnum = (typeof BoostScalarFieldEnum)[keyof typeof BoostScalarFieldEnum]


  export const BoostMetricScalarFieldEnum: {
    id: 'id',
    boostId: 'boostId',
    date: 'date',
    impressions: 'impressions',
    clicks: 'clicks'
  };

  export type BoostMetricScalarFieldEnum = (typeof BoostMetricScalarFieldEnum)[keyof typeof BoostMetricScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    unitType: 'unitType',
    sizeMl: 'sizeMl',
    upc: 'upc',
    isActive: 'isActive'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const BarProductScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    productId: 'productId',
    customName: 'customName',
    parLevel: 'parLevel',
    reorderThreshold: 'reorderThreshold',
    preferredVendor: 'preferredVendor',
    isActive: 'isActive'
  };

  export type BarProductScalarFieldEnum = (typeof BarProductScalarFieldEnum)[keyof typeof BarProductScalarFieldEnum]


  export const InventoryScanSessionScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    createdByUserId: 'createdByUserId',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type InventoryScanSessionScalarFieldEnum = (typeof InventoryScanSessionScalarFieldEnum)[keyof typeof InventoryScanSessionScalarFieldEnum]


  export const InventoryScanDetectionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    productGuessText: 'productGuessText',
    productId: 'productId',
    bbox: 'bbox',
    confidence: 'confidence',
    remainingBucket: 'remainingBucket',
    sizeMlGuess: 'sizeMlGuess'
  };

  export type InventoryScanDetectionScalarFieldEnum = (typeof InventoryScanDetectionScalarFieldEnum)[keyof typeof InventoryScanDetectionScalarFieldEnum]


  export const InventoryCountScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    productId: 'productId',
    countedAt: 'countedAt',
    quantity: 'quantity',
    unit: 'unit',
    remainingPercent: 'remainingPercent',
    remainingBucket: 'remainingBucket',
    method: 'method',
    confidence: 'confidence',
    notes: 'notes'
  };

  export type InventoryCountScalarFieldEnum = (typeof InventoryCountScalarFieldEnum)[keyof typeof InventoryCountScalarFieldEnum]


  export const AdminAuditScalarFieldEnum: {
    id: 'id',
    adminEmail: 'adminEmail',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    before: 'before',
    after: 'after',
    createdAt: 'createdAt'
  };

  export type AdminAuditScalarFieldEnum = (typeof AdminAuditScalarFieldEnum)[keyof typeof AdminAuditScalarFieldEnum]


  export const AdminNoteScalarFieldEnum: {
    id: 'id',
    adminEmail: 'adminEmail',
    barId: 'barId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AdminNoteScalarFieldEnum = (typeof AdminNoteScalarFieldEnum)[keyof typeof AdminNoteScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    userEmail: 'userEmail',
    userId: 'userId',
    subject: 'subject',
    status: 'status',
    priority: 'priority',
    message: 'message',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const StaticOfferingScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    name: 'name',
    icon: 'icon',
    description: 'description',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaticOfferingScalarFieldEnum = (typeof StaticOfferingScalarFieldEnum)[keyof typeof StaticOfferingScalarFieldEnum]


  export const DrinkSpecialScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    name: 'name',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    daysOfWeek: 'daysOfWeek',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DrinkSpecialScalarFieldEnum = (typeof DrinkSpecialScalarFieldEnum)[keyof typeof DrinkSpecialScalarFieldEnum]


  export const FoodOfferingScalarFieldEnum: {
    id: 'id',
    barId: 'barId',
    name: 'name',
    description: 'description',
    specialDays: 'specialDays',
    isSpecial: 'isSpecial',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodOfferingScalarFieldEnum = (typeof FoodOfferingScalarFieldEnum)[keyof typeof FoodOfferingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OwnerRole'
   */
  export type EnumOwnerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnerRole'>
    


  /**
   * Reference to a field of type 'OwnerRole[]'
   */
  export type ListEnumOwnerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnerRole[]'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Recurrence'
   */
  export type EnumRecurrenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Recurrence'>
    


  /**
   * Reference to a field of type 'Recurrence[]'
   */
  export type ListEnumRecurrenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Recurrence[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'CategoryRequestStatus'
   */
  export type EnumCategoryRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryRequestStatus'>
    


  /**
   * Reference to a field of type 'CategoryRequestStatus[]'
   */
  export type ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryRequestStatus[]'>
    


  /**
   * Reference to a field of type 'BadgeTier'
   */
  export type EnumBadgeTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeTier'>
    


  /**
   * Reference to a field of type 'BadgeTier[]'
   */
  export type ListEnumBadgeTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeTier[]'>
    


  /**
   * Reference to a field of type 'BadgeCategory'
   */
  export type EnumBadgeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeCategory'>
    


  /**
   * Reference to a field of type 'BadgeCategory[]'
   */
  export type ListEnumBadgeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeCategory[]'>
    


  /**
   * Reference to a field of type 'BarMemberRole'
   */
  export type EnumBarMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BarMemberRole'>
    


  /**
   * Reference to a field of type 'BarMemberRole[]'
   */
  export type ListEnumBarMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BarMemberRole[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    disabled?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    favorites?: FavoriteListRelationFilter
    visits?: BarVisitListRelationFilter
    inventoryImports?: InventoryImportListRelationFilter
    shiftUsages?: ShiftUsageListRelationFilter
    inventorySnapshots?: InventorySnapshotListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disabled?: SortOrder
    role?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    visits?: BarVisitOrderByRelationAggregateInput
    inventoryImports?: InventoryImportOrderByRelationAggregateInput
    shiftUsages?: ShiftUsageOrderByRelationAggregateInput
    inventorySnapshots?: InventorySnapshotOrderByRelationAggregateInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    disabled?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    favorites?: FavoriteListRelationFilter
    visits?: BarVisitListRelationFilter
    inventoryImports?: InventoryImportListRelationFilter
    shiftUsages?: ShiftUsageListRelationFilter
    inventorySnapshots?: InventorySnapshotListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disabled?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    disabled?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type OwnerWhereInput = {
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    id?: StringFilter<"Owner"> | string
    email?: StringFilter<"Owner"> | string
    name?: StringFilter<"Owner"> | string
    password?: StringFilter<"Owner"> | string
    phone?: StringNullableFilter<"Owner"> | string | null
    emailVerified?: DateTimeNullableFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    updatedAt?: DateTimeFilter<"Owner"> | Date | string
    allowFreeListings?: BoolFilter<"Owner"> | boolean
    role?: EnumOwnerRoleFilter<"Owner"> | $Enums.OwnerRole
    bars?: BarListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    barLicenses?: BarLicenseListRelationFilter
    promoRedemptions?: PromoRedemptionListRelationFilter
    categoryRequests?: CategoryRequestListRelationFilter
    passwordResets?: OwnerPasswordResetListRelationFilter
  }

  export type OwnerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    allowFreeListings?: SortOrder
    role?: SortOrder
    bars?: BarOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    barLicenses?: BarLicenseOrderByRelationAggregateInput
    promoRedemptions?: PromoRedemptionOrderByRelationAggregateInput
    categoryRequests?: CategoryRequestOrderByRelationAggregateInput
    passwordResets?: OwnerPasswordResetOrderByRelationAggregateInput
  }

  export type OwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    name?: StringFilter<"Owner"> | string
    password?: StringFilter<"Owner"> | string
    phone?: StringNullableFilter<"Owner"> | string | null
    emailVerified?: DateTimeNullableFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    updatedAt?: DateTimeFilter<"Owner"> | Date | string
    allowFreeListings?: BoolFilter<"Owner"> | boolean
    role?: EnumOwnerRoleFilter<"Owner"> | $Enums.OwnerRole
    bars?: BarListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    barLicenses?: BarLicenseListRelationFilter
    promoRedemptions?: PromoRedemptionListRelationFilter
    categoryRequests?: CategoryRequestListRelationFilter
    passwordResets?: OwnerPasswordResetListRelationFilter
  }, "id" | "email">

  export type OwnerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    allowFreeListings?: SortOrder
    role?: SortOrder
    _count?: OwnerCountOrderByAggregateInput
    _max?: OwnerMaxOrderByAggregateInput
    _min?: OwnerMinOrderByAggregateInput
  }

  export type OwnerScalarWhereWithAggregatesInput = {
    AND?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    OR?: OwnerScalarWhereWithAggregatesInput[]
    NOT?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Owner"> | string
    email?: StringWithAggregatesFilter<"Owner"> | string
    name?: StringWithAggregatesFilter<"Owner"> | string
    password?: StringWithAggregatesFilter<"Owner"> | string
    phone?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"Owner"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
    allowFreeListings?: BoolWithAggregatesFilter<"Owner"> | boolean
    role?: EnumOwnerRoleWithAggregatesFilter<"Owner"> | $Enums.OwnerRole
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    ownerId?: StringFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    paypalCustomerId?: StringNullableFilter<"Subscription"> | string | null
    paypalSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    priceId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialReminderSentAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    paypalCustomerId?: SortOrderInput | SortOrder
    paypalSubscriptionId?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    trialReminderSentAt?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: OwnerOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    plan?: EnumSubscriptionPlanFilter<"Subscription"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    paypalCustomerId?: StringNullableFilter<"Subscription"> | string | null
    paypalSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    priceId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialReminderSentAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "id" | "ownerId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    paypalCustomerId?: SortOrderInput | SortOrder
    paypalSubscriptionId?: SortOrderInput | SortOrder
    priceId?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    trialReminderSentAt?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    ownerId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    paypalCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    paypalSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    priceId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialReminderSentAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type BarWhereInput = {
    AND?: BarWhereInput | BarWhereInput[]
    OR?: BarWhereInput[]
    NOT?: BarWhereInput | BarWhereInput[]
    id?: StringFilter<"Bar"> | string
    ownerId?: StringFilter<"Bar"> | string
    name?: StringFilter<"Bar"> | string
    slug?: StringFilter<"Bar"> | string
    description?: StringNullableFilter<"Bar"> | string | null
    address?: StringFilter<"Bar"> | string
    city?: StringFilter<"Bar"> | string
    cityNormalized?: StringFilter<"Bar"> | string
    state?: StringFilter<"Bar"> | string
    zipCode?: StringFilter<"Bar"> | string
    barType?: StringNullableFilter<"Bar"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"Bar"> | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFilter<"Bar"> | boolean
    checkInReward?: StringNullableFilter<"Bar"> | string | null
    neighborhood?: StringNullableFilter<"Bar"> | string | null
    neighborhoodNormalized?: StringNullableFilter<"Bar"> | string | null
    latitude?: FloatFilter<"Bar"> | number
    longitude?: FloatFilter<"Bar"> | number
    phone?: StringNullableFilter<"Bar"> | string | null
    website?: StringNullableFilter<"Bar"> | string | null
    logo?: StringNullableFilter<"Bar"> | string | null
    photos?: StringNullableListFilter<"Bar">
    hours?: JsonNullableFilter<"Bar">
    isActive?: BoolFilter<"Bar"> | boolean
    isPublished?: BoolFilter<"Bar"> | boolean
    publishedAt?: DateTimeNullableFilter<"Bar"> | Date | string | null
    createdAt?: DateTimeFilter<"Bar"> | Date | string
    updatedAt?: DateTimeFilter<"Bar"> | Date | string
    profileViews?: IntFilter<"Bar"> | number
    searchAppearances?: IntFilter<"Bar"> | number
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
    offerings?: OfferingListRelationFilter
    events?: EventListRelationFilter
    favorites?: FavoriteListRelationFilter
    analytics?: BarAnalyticsListRelationFilter
    clicks?: BarClickListRelationFilter
    badges?: BarBadgeListRelationFilter
    barLicenses?: BarLicenseListRelationFilter
    shiftUsages?: ShiftUsageListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    inventoryImports?: InventoryImportListRelationFilter
    inventorySnapshots?: InventorySnapshotListRelationFilter
    visits?: BarVisitListRelationFilter
    varianceAlerts?: VarianceAlertListRelationFilter
    staticOfferings?: StaticOfferingListRelationFilter
    drinkSpecials?: DrinkSpecialListRelationFilter
    foodOfferings?: FoodOfferingListRelationFilter
    categoryRequests?: CategoryRequestListRelationFilter
    memberships?: BarMembershipListRelationFilter
    followers?: BarFollowerListRelationFilter
    boosts?: BoostListRelationFilter
    barProducts?: BarProductListRelationFilter
    inventoryScanSessions?: InventoryScanSessionListRelationFilter
    inventoryCounts?: InventoryCountListRelationFilter
    patronSearchEvents?: PatronSearchEventListRelationFilter
    barActions?: BarActionListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }

  export type BarOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    cityNormalized?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    barType?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    inventoryAddOnEnabled?: SortOrder
    checkInReward?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    neighborhoodNormalized?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    photos?: SortOrder
    hours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
    owner?: OwnerOrderByWithRelationInput
    offerings?: OfferingOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    analytics?: BarAnalyticsOrderByRelationAggregateInput
    clicks?: BarClickOrderByRelationAggregateInput
    badges?: BarBadgeOrderByRelationAggregateInput
    barLicenses?: BarLicenseOrderByRelationAggregateInput
    shiftUsages?: ShiftUsageOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    inventoryImports?: InventoryImportOrderByRelationAggregateInput
    inventorySnapshots?: InventorySnapshotOrderByRelationAggregateInput
    visits?: BarVisitOrderByRelationAggregateInput
    varianceAlerts?: VarianceAlertOrderByRelationAggregateInput
    staticOfferings?: StaticOfferingOrderByRelationAggregateInput
    drinkSpecials?: DrinkSpecialOrderByRelationAggregateInput
    foodOfferings?: FoodOfferingOrderByRelationAggregateInput
    categoryRequests?: CategoryRequestOrderByRelationAggregateInput
    memberships?: BarMembershipOrderByRelationAggregateInput
    followers?: BarFollowerOrderByRelationAggregateInput
    boosts?: BoostOrderByRelationAggregateInput
    barProducts?: BarProductOrderByRelationAggregateInput
    inventoryScanSessions?: InventoryScanSessionOrderByRelationAggregateInput
    inventoryCounts?: InventoryCountOrderByRelationAggregateInput
    patronSearchEvents?: PatronSearchEventOrderByRelationAggregateInput
    barActions?: BarActionOrderByRelationAggregateInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type BarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BarWhereInput | BarWhereInput[]
    OR?: BarWhereInput[]
    NOT?: BarWhereInput | BarWhereInput[]
    ownerId?: StringFilter<"Bar"> | string
    name?: StringFilter<"Bar"> | string
    description?: StringNullableFilter<"Bar"> | string | null
    address?: StringFilter<"Bar"> | string
    city?: StringFilter<"Bar"> | string
    cityNormalized?: StringFilter<"Bar"> | string
    state?: StringFilter<"Bar"> | string
    zipCode?: StringFilter<"Bar"> | string
    barType?: StringNullableFilter<"Bar"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"Bar"> | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFilter<"Bar"> | boolean
    checkInReward?: StringNullableFilter<"Bar"> | string | null
    neighborhood?: StringNullableFilter<"Bar"> | string | null
    neighborhoodNormalized?: StringNullableFilter<"Bar"> | string | null
    latitude?: FloatFilter<"Bar"> | number
    longitude?: FloatFilter<"Bar"> | number
    phone?: StringNullableFilter<"Bar"> | string | null
    website?: StringNullableFilter<"Bar"> | string | null
    logo?: StringNullableFilter<"Bar"> | string | null
    photos?: StringNullableListFilter<"Bar">
    hours?: JsonNullableFilter<"Bar">
    isActive?: BoolFilter<"Bar"> | boolean
    isPublished?: BoolFilter<"Bar"> | boolean
    publishedAt?: DateTimeNullableFilter<"Bar"> | Date | string | null
    createdAt?: DateTimeFilter<"Bar"> | Date | string
    updatedAt?: DateTimeFilter<"Bar"> | Date | string
    profileViews?: IntFilter<"Bar"> | number
    searchAppearances?: IntFilter<"Bar"> | number
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
    offerings?: OfferingListRelationFilter
    events?: EventListRelationFilter
    favorites?: FavoriteListRelationFilter
    analytics?: BarAnalyticsListRelationFilter
    clicks?: BarClickListRelationFilter
    badges?: BarBadgeListRelationFilter
    barLicenses?: BarLicenseListRelationFilter
    shiftUsages?: ShiftUsageListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    inventoryImports?: InventoryImportListRelationFilter
    inventorySnapshots?: InventorySnapshotListRelationFilter
    visits?: BarVisitListRelationFilter
    varianceAlerts?: VarianceAlertListRelationFilter
    staticOfferings?: StaticOfferingListRelationFilter
    drinkSpecials?: DrinkSpecialListRelationFilter
    foodOfferings?: FoodOfferingListRelationFilter
    categoryRequests?: CategoryRequestListRelationFilter
    memberships?: BarMembershipListRelationFilter
    followers?: BarFollowerListRelationFilter
    boosts?: BoostListRelationFilter
    barProducts?: BarProductListRelationFilter
    inventoryScanSessions?: InventoryScanSessionListRelationFilter
    inventoryCounts?: InventoryCountListRelationFilter
    patronSearchEvents?: PatronSearchEventListRelationFilter
    barActions?: BarActionListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }, "id" | "slug">

  export type BarOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    cityNormalized?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    barType?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    inventoryAddOnEnabled?: SortOrder
    checkInReward?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    neighborhoodNormalized?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    photos?: SortOrder
    hours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
    _count?: BarCountOrderByAggregateInput
    _avg?: BarAvgOrderByAggregateInput
    _max?: BarMaxOrderByAggregateInput
    _min?: BarMinOrderByAggregateInput
    _sum?: BarSumOrderByAggregateInput
  }

  export type BarScalarWhereWithAggregatesInput = {
    AND?: BarScalarWhereWithAggregatesInput | BarScalarWhereWithAggregatesInput[]
    OR?: BarScalarWhereWithAggregatesInput[]
    NOT?: BarScalarWhereWithAggregatesInput | BarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bar"> | string
    ownerId?: StringWithAggregatesFilter<"Bar"> | string
    name?: StringWithAggregatesFilter<"Bar"> | string
    slug?: StringWithAggregatesFilter<"Bar"> | string
    description?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    address?: StringWithAggregatesFilter<"Bar"> | string
    city?: StringWithAggregatesFilter<"Bar"> | string
    cityNormalized?: StringWithAggregatesFilter<"Bar"> | string
    state?: StringWithAggregatesFilter<"Bar"> | string
    zipCode?: StringWithAggregatesFilter<"Bar"> | string
    barType?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    subscriptionTier?: EnumSubscriptionTierWithAggregatesFilter<"Bar"> | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolWithAggregatesFilter<"Bar"> | boolean
    checkInReward?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    neighborhood?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    neighborhoodNormalized?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    latitude?: FloatWithAggregatesFilter<"Bar"> | number
    longitude?: FloatWithAggregatesFilter<"Bar"> | number
    phone?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    website?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Bar"> | string | null
    photos?: StringNullableListFilter<"Bar">
    hours?: JsonNullableWithAggregatesFilter<"Bar">
    isActive?: BoolWithAggregatesFilter<"Bar"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Bar"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Bar"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Bar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bar"> | Date | string
    profileViews?: IntWithAggregatesFilter<"Bar"> | number
    searchAppearances?: IntWithAggregatesFilter<"Bar"> | number
  }

  export type OfferingWhereInput = {
    AND?: OfferingWhereInput | OfferingWhereInput[]
    OR?: OfferingWhereInput[]
    NOT?: OfferingWhereInput | OfferingWhereInput[]
    id?: StringFilter<"Offering"> | string
    barId?: StringFilter<"Offering"> | string
    dayOfWeek?: IntFilter<"Offering"> | number
    category?: StringFilter<"Offering"> | string
    customTitle?: StringNullableFilter<"Offering"> | string | null
    description?: StringNullableFilter<"Offering"> | string | null
    startTime?: StringFilter<"Offering"> | string
    endTime?: StringNullableFilter<"Offering"> | string | null
    recurrence?: EnumRecurrenceFilter<"Offering"> | $Enums.Recurrence
    startDate?: DateTimeNullableFilter<"Offering"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Offering"> | Date | string | null
    tags?: StringNullableListFilter<"Offering">
    coverCharge?: DecimalNullableFilter<"Offering"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableFilter<"Offering"> | string | null
    ageRestriction?: IntNullableFilter<"Offering"> | number | null
    isActive?: BoolFilter<"Offering"> | boolean
    isSpecial?: BoolFilter<"Offering"> | boolean
    isNew?: BoolFilter<"Offering"> | boolean
    specialExpiresAt?: DateTimeNullableFilter<"Offering"> | Date | string | null
    newUntil?: DateTimeNullableFilter<"Offering"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Offering"> | Date | string | null
    clickCount?: IntFilter<"Offering"> | number
    createdAt?: DateTimeFilter<"Offering"> | Date | string
    updatedAt?: DateTimeFilter<"Offering"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type OfferingOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    dayOfWeek?: SortOrder
    category?: SortOrder
    customTitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    recurrence?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    tags?: SortOrder
    coverCharge?: SortOrderInput | SortOrder
    prize?: SortOrderInput | SortOrder
    ageRestriction?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrderInput | SortOrder
    newUntil?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type OfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferingWhereInput | OfferingWhereInput[]
    OR?: OfferingWhereInput[]
    NOT?: OfferingWhereInput | OfferingWhereInput[]
    barId?: StringFilter<"Offering"> | string
    dayOfWeek?: IntFilter<"Offering"> | number
    category?: StringFilter<"Offering"> | string
    customTitle?: StringNullableFilter<"Offering"> | string | null
    description?: StringNullableFilter<"Offering"> | string | null
    startTime?: StringFilter<"Offering"> | string
    endTime?: StringNullableFilter<"Offering"> | string | null
    recurrence?: EnumRecurrenceFilter<"Offering"> | $Enums.Recurrence
    startDate?: DateTimeNullableFilter<"Offering"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Offering"> | Date | string | null
    tags?: StringNullableListFilter<"Offering">
    coverCharge?: DecimalNullableFilter<"Offering"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableFilter<"Offering"> | string | null
    ageRestriction?: IntNullableFilter<"Offering"> | number | null
    isActive?: BoolFilter<"Offering"> | boolean
    isSpecial?: BoolFilter<"Offering"> | boolean
    isNew?: BoolFilter<"Offering"> | boolean
    specialExpiresAt?: DateTimeNullableFilter<"Offering"> | Date | string | null
    newUntil?: DateTimeNullableFilter<"Offering"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Offering"> | Date | string | null
    clickCount?: IntFilter<"Offering"> | number
    createdAt?: DateTimeFilter<"Offering"> | Date | string
    updatedAt?: DateTimeFilter<"Offering"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type OfferingOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    dayOfWeek?: SortOrder
    category?: SortOrder
    customTitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    recurrence?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    tags?: SortOrder
    coverCharge?: SortOrderInput | SortOrder
    prize?: SortOrderInput | SortOrder
    ageRestriction?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrderInput | SortOrder
    newUntil?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferingCountOrderByAggregateInput
    _avg?: OfferingAvgOrderByAggregateInput
    _max?: OfferingMaxOrderByAggregateInput
    _min?: OfferingMinOrderByAggregateInput
    _sum?: OfferingSumOrderByAggregateInput
  }

  export type OfferingScalarWhereWithAggregatesInput = {
    AND?: OfferingScalarWhereWithAggregatesInput | OfferingScalarWhereWithAggregatesInput[]
    OR?: OfferingScalarWhereWithAggregatesInput[]
    NOT?: OfferingScalarWhereWithAggregatesInput | OfferingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offering"> | string
    barId?: StringWithAggregatesFilter<"Offering"> | string
    dayOfWeek?: IntWithAggregatesFilter<"Offering"> | number
    category?: StringWithAggregatesFilter<"Offering"> | string
    customTitle?: StringNullableWithAggregatesFilter<"Offering"> | string | null
    description?: StringNullableWithAggregatesFilter<"Offering"> | string | null
    startTime?: StringWithAggregatesFilter<"Offering"> | string
    endTime?: StringNullableWithAggregatesFilter<"Offering"> | string | null
    recurrence?: EnumRecurrenceWithAggregatesFilter<"Offering"> | $Enums.Recurrence
    startDate?: DateTimeNullableWithAggregatesFilter<"Offering"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Offering"> | Date | string | null
    tags?: StringNullableListFilter<"Offering">
    coverCharge?: DecimalNullableWithAggregatesFilter<"Offering"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableWithAggregatesFilter<"Offering"> | string | null
    ageRestriction?: IntNullableWithAggregatesFilter<"Offering"> | number | null
    isActive?: BoolWithAggregatesFilter<"Offering"> | boolean
    isSpecial?: BoolWithAggregatesFilter<"Offering"> | boolean
    isNew?: BoolWithAggregatesFilter<"Offering"> | boolean
    specialExpiresAt?: DateTimeNullableWithAggregatesFilter<"Offering"> | Date | string | null
    newUntil?: DateTimeNullableWithAggregatesFilter<"Offering"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Offering"> | Date | string | null
    clickCount?: IntWithAggregatesFilter<"Offering"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Offering"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offering"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    barId?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    category?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null
    startTime?: StringFilter<"Event"> | string
    endTime?: StringNullableFilter<"Event"> | string | null
    isRecurring?: BoolFilter<"Event"> | boolean
    recurrenceRule?: StringNullableFilter<"Event"> | string | null
    recurrence?: EnumRecurrenceNullableFilter<"Event"> | $Enums.Recurrence | null
    tags?: StringNullableListFilter<"Event">
    isActive?: BoolFilter<"Event"> | boolean
    isSpecial?: BoolFilter<"Event"> | boolean
    isNew?: BoolFilter<"Event"> | boolean
    specialExpiresAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    newUntil?: DateTimeNullableFilter<"Event"> | Date | string | null
    autoExpire?: BoolFilter<"Event"> | boolean
    coverCharge?: DecimalNullableFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableFilter<"Event"> | string | null
    ageRestriction?: IntNullableFilter<"Event"> | number | null
    clickCount?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    recurrence?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrderInput | SortOrder
    newUntil?: SortOrderInput | SortOrder
    autoExpire?: SortOrder
    coverCharge?: SortOrderInput | SortOrder
    prize?: SortOrderInput | SortOrder
    ageRestriction?: SortOrderInput | SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    barId?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    category?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null
    startTime?: StringFilter<"Event"> | string
    endTime?: StringNullableFilter<"Event"> | string | null
    isRecurring?: BoolFilter<"Event"> | boolean
    recurrenceRule?: StringNullableFilter<"Event"> | string | null
    recurrence?: EnumRecurrenceNullableFilter<"Event"> | $Enums.Recurrence | null
    tags?: StringNullableListFilter<"Event">
    isActive?: BoolFilter<"Event"> | boolean
    isSpecial?: BoolFilter<"Event"> | boolean
    isNew?: BoolFilter<"Event"> | boolean
    specialExpiresAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    newUntil?: DateTimeNullableFilter<"Event"> | Date | string | null
    autoExpire?: BoolFilter<"Event"> | boolean
    coverCharge?: DecimalNullableFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableFilter<"Event"> | string | null
    ageRestriction?: IntNullableFilter<"Event"> | number | null
    clickCount?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    recurrence?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrderInput | SortOrder
    newUntil?: SortOrderInput | SortOrder
    autoExpire?: SortOrder
    coverCharge?: SortOrderInput | SortOrder
    prize?: SortOrderInput | SortOrder
    ageRestriction?: SortOrderInput | SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    barId?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    category?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    startTime?: StringWithAggregatesFilter<"Event"> | string
    endTime?: StringNullableWithAggregatesFilter<"Event"> | string | null
    isRecurring?: BoolWithAggregatesFilter<"Event"> | boolean
    recurrenceRule?: StringNullableWithAggregatesFilter<"Event"> | string | null
    recurrence?: EnumRecurrenceNullableWithAggregatesFilter<"Event"> | $Enums.Recurrence | null
    tags?: StringNullableListFilter<"Event">
    isActive?: BoolWithAggregatesFilter<"Event"> | boolean
    isSpecial?: BoolWithAggregatesFilter<"Event"> | boolean
    isNew?: BoolWithAggregatesFilter<"Event"> | boolean
    specialExpiresAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    newUntil?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    autoExpire?: BoolWithAggregatesFilter<"Event"> | boolean
    coverCharge?: DecimalNullableWithAggregatesFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableWithAggregatesFilter<"Event"> | string | null
    ageRestriction?: IntNullableWithAggregatesFilter<"Event"> | number | null
    clickCount?: IntWithAggregatesFilter<"Event"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    barId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    barId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bar?: BarOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_barId?: FavoriteUserIdBarIdCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: StringFilter<"Favorite"> | string
    barId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id" | "userId_barId">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    barId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite"> | string
    userId?: StringWithAggregatesFilter<"Favorite"> | string
    barId?: StringWithAggregatesFilter<"Favorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type ActivityCategoryWhereInput = {
    AND?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    OR?: ActivityCategoryWhereInput[]
    NOT?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    id?: StringFilter<"ActivityCategory"> | string
    name?: StringFilter<"ActivityCategory"> | string
    displayName?: StringFilter<"ActivityCategory"> | string
    icon?: StringNullableFilter<"ActivityCategory"> | string | null
    sortOrder?: IntFilter<"ActivityCategory"> | number
    isActive?: BoolFilter<"ActivityCategory"> | boolean
    createdAt?: DateTimeFilter<"ActivityCategory"> | Date | string
  }

  export type ActivityCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    OR?: ActivityCategoryWhereInput[]
    NOT?: ActivityCategoryWhereInput | ActivityCategoryWhereInput[]
    displayName?: StringFilter<"ActivityCategory"> | string
    icon?: StringNullableFilter<"ActivityCategory"> | string | null
    sortOrder?: IntFilter<"ActivityCategory"> | number
    isActive?: BoolFilter<"ActivityCategory"> | boolean
    createdAt?: DateTimeFilter<"ActivityCategory"> | Date | string
  }, "id" | "name">

  export type ActivityCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityCategoryCountOrderByAggregateInput
    _avg?: ActivityCategoryAvgOrderByAggregateInput
    _max?: ActivityCategoryMaxOrderByAggregateInput
    _min?: ActivityCategoryMinOrderByAggregateInput
    _sum?: ActivityCategorySumOrderByAggregateInput
  }

  export type ActivityCategoryScalarWhereWithAggregatesInput = {
    AND?: ActivityCategoryScalarWhereWithAggregatesInput | ActivityCategoryScalarWhereWithAggregatesInput[]
    OR?: ActivityCategoryScalarWhereWithAggregatesInput[]
    NOT?: ActivityCategoryScalarWhereWithAggregatesInput | ActivityCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityCategory"> | string
    name?: StringWithAggregatesFilter<"ActivityCategory"> | string
    displayName?: StringWithAggregatesFilter<"ActivityCategory"> | string
    icon?: StringNullableWithAggregatesFilter<"ActivityCategory"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ActivityCategory"> | number
    isActive?: BoolWithAggregatesFilter<"ActivityCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ActivityCategory"> | Date | string
  }

  export type CategoryRequestWhereInput = {
    AND?: CategoryRequestWhereInput | CategoryRequestWhereInput[]
    OR?: CategoryRequestWhereInput[]
    NOT?: CategoryRequestWhereInput | CategoryRequestWhereInput[]
    id?: StringFilter<"CategoryRequest"> | string
    barId?: StringFilter<"CategoryRequest"> | string
    ownerId?: StringFilter<"CategoryRequest"> | string
    requestedByEmail?: StringFilter<"CategoryRequest"> | string
    requestedByName?: StringNullableFilter<"CategoryRequest"> | string | null
    category?: StringFilter<"CategoryRequest"> | string
    status?: EnumCategoryRequestStatusFilter<"CategoryRequest"> | $Enums.CategoryRequestStatus
    reviewedAt?: DateTimeNullableFilter<"CategoryRequest"> | Date | string | null
    reviewedByEmail?: StringNullableFilter<"CategoryRequest"> | string | null
    createdAt?: DateTimeFilter<"CategoryRequest"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type CategoryRequestOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    requestedByEmail?: SortOrder
    requestedByName?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedByEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    owner?: OwnerOrderByWithRelationInput
  }

  export type CategoryRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryRequestWhereInput | CategoryRequestWhereInput[]
    OR?: CategoryRequestWhereInput[]
    NOT?: CategoryRequestWhereInput | CategoryRequestWhereInput[]
    barId?: StringFilter<"CategoryRequest"> | string
    ownerId?: StringFilter<"CategoryRequest"> | string
    requestedByEmail?: StringFilter<"CategoryRequest"> | string
    requestedByName?: StringNullableFilter<"CategoryRequest"> | string | null
    category?: StringFilter<"CategoryRequest"> | string
    status?: EnumCategoryRequestStatusFilter<"CategoryRequest"> | $Enums.CategoryRequestStatus
    reviewedAt?: DateTimeNullableFilter<"CategoryRequest"> | Date | string | null
    reviewedByEmail?: StringNullableFilter<"CategoryRequest"> | string | null
    createdAt?: DateTimeFilter<"CategoryRequest"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "id">

  export type CategoryRequestOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    requestedByEmail?: SortOrder
    requestedByName?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedByEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CategoryRequestCountOrderByAggregateInput
    _max?: CategoryRequestMaxOrderByAggregateInput
    _min?: CategoryRequestMinOrderByAggregateInput
  }

  export type CategoryRequestScalarWhereWithAggregatesInput = {
    AND?: CategoryRequestScalarWhereWithAggregatesInput | CategoryRequestScalarWhereWithAggregatesInput[]
    OR?: CategoryRequestScalarWhereWithAggregatesInput[]
    NOT?: CategoryRequestScalarWhereWithAggregatesInput | CategoryRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryRequest"> | string
    barId?: StringWithAggregatesFilter<"CategoryRequest"> | string
    ownerId?: StringWithAggregatesFilter<"CategoryRequest"> | string
    requestedByEmail?: StringWithAggregatesFilter<"CategoryRequest"> | string
    requestedByName?: StringNullableWithAggregatesFilter<"CategoryRequest"> | string | null
    category?: StringWithAggregatesFilter<"CategoryRequest"> | string
    status?: EnumCategoryRequestStatusWithAggregatesFilter<"CategoryRequest"> | $Enums.CategoryRequestStatus
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"CategoryRequest"> | Date | string | null
    reviewedByEmail?: StringNullableWithAggregatesFilter<"CategoryRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CategoryRequest"> | Date | string
  }

  export type OwnerPasswordResetWhereInput = {
    AND?: OwnerPasswordResetWhereInput | OwnerPasswordResetWhereInput[]
    OR?: OwnerPasswordResetWhereInput[]
    NOT?: OwnerPasswordResetWhereInput | OwnerPasswordResetWhereInput[]
    id?: StringFilter<"OwnerPasswordReset"> | string
    ownerId?: StringFilter<"OwnerPasswordReset"> | string
    tokenHash?: StringFilter<"OwnerPasswordReset"> | string
    expiresAt?: DateTimeFilter<"OwnerPasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"OwnerPasswordReset"> | Date | string | null
    createdAt?: DateTimeFilter<"OwnerPasswordReset"> | Date | string
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type OwnerPasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    owner?: OwnerOrderByWithRelationInput
  }

  export type OwnerPasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: OwnerPasswordResetWhereInput | OwnerPasswordResetWhereInput[]
    OR?: OwnerPasswordResetWhereInput[]
    NOT?: OwnerPasswordResetWhereInput | OwnerPasswordResetWhereInput[]
    ownerId?: StringFilter<"OwnerPasswordReset"> | string
    expiresAt?: DateTimeFilter<"OwnerPasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"OwnerPasswordReset"> | Date | string | null
    createdAt?: DateTimeFilter<"OwnerPasswordReset"> | Date | string
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "id" | "tokenHash">

  export type OwnerPasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OwnerPasswordResetCountOrderByAggregateInput
    _max?: OwnerPasswordResetMaxOrderByAggregateInput
    _min?: OwnerPasswordResetMinOrderByAggregateInput
  }

  export type OwnerPasswordResetScalarWhereWithAggregatesInput = {
    AND?: OwnerPasswordResetScalarWhereWithAggregatesInput | OwnerPasswordResetScalarWhereWithAggregatesInput[]
    OR?: OwnerPasswordResetScalarWhereWithAggregatesInput[]
    NOT?: OwnerPasswordResetScalarWhereWithAggregatesInput | OwnerPasswordResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OwnerPasswordReset"> | string
    ownerId?: StringWithAggregatesFilter<"OwnerPasswordReset"> | string
    tokenHash?: StringWithAggregatesFilter<"OwnerPasswordReset"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"OwnerPasswordReset"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"OwnerPasswordReset"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OwnerPasswordReset"> | Date | string
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    maxRedemptions?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    grantPlan?: EnumSubscriptionPlanNullableFilter<"PromoCode"> | $Enums.SubscriptionPlan | null
    grantMonths?: IntNullableFilter<"PromoCode"> | number | null
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
    redemptions?: PromoRedemptionListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    grantPlan?: SortOrderInput | SortOrder
    grantMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    redemptions?: PromoRedemptionOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    description?: StringNullableFilter<"PromoCode"> | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    maxRedemptions?: IntNullableFilter<"PromoCode"> | number | null
    usedCount?: IntFilter<"PromoCode"> | number
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    grantPlan?: EnumSubscriptionPlanNullableFilter<"PromoCode"> | $Enums.SubscriptionPlan | null
    grantMonths?: IntNullableFilter<"PromoCode"> | number | null
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
    redemptions?: PromoRedemptionListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    grantPlan?: SortOrderInput | SortOrder
    grantMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    isActive?: BoolWithAggregatesFilter<"PromoCode"> | boolean
    maxRedemptions?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"PromoCode"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
    grantPlan?: EnumSubscriptionPlanNullableWithAggregatesFilter<"PromoCode"> | $Enums.SubscriptionPlan | null
    grantMonths?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type PromoRedemptionWhereInput = {
    AND?: PromoRedemptionWhereInput | PromoRedemptionWhereInput[]
    OR?: PromoRedemptionWhereInput[]
    NOT?: PromoRedemptionWhereInput | PromoRedemptionWhereInput[]
    id?: StringFilter<"PromoRedemption"> | string
    promoCodeId?: StringFilter<"PromoRedemption"> | string
    ownerId?: StringFilter<"PromoRedemption"> | string
    redeemedAt?: DateTimeFilter<"PromoRedemption"> | Date | string
    promoCode?: XOR<PromoCodeScalarRelationFilter, PromoCodeWhereInput>
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type PromoRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    ownerId?: SortOrder
    redeemedAt?: SortOrder
    promoCode?: PromoCodeOrderByWithRelationInput
    owner?: OwnerOrderByWithRelationInput
  }

  export type PromoRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promoCodeId_ownerId?: PromoRedemptionPromoCodeIdOwnerIdCompoundUniqueInput
    AND?: PromoRedemptionWhereInput | PromoRedemptionWhereInput[]
    OR?: PromoRedemptionWhereInput[]
    NOT?: PromoRedemptionWhereInput | PromoRedemptionWhereInput[]
    promoCodeId?: StringFilter<"PromoRedemption"> | string
    ownerId?: StringFilter<"PromoRedemption"> | string
    redeemedAt?: DateTimeFilter<"PromoRedemption"> | Date | string
    promoCode?: XOR<PromoCodeScalarRelationFilter, PromoCodeWhereInput>
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "id" | "promoCodeId_ownerId">

  export type PromoRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    ownerId?: SortOrder
    redeemedAt?: SortOrder
    _count?: PromoRedemptionCountOrderByAggregateInput
    _max?: PromoRedemptionMaxOrderByAggregateInput
    _min?: PromoRedemptionMinOrderByAggregateInput
  }

  export type PromoRedemptionScalarWhereWithAggregatesInput = {
    AND?: PromoRedemptionScalarWhereWithAggregatesInput | PromoRedemptionScalarWhereWithAggregatesInput[]
    OR?: PromoRedemptionScalarWhereWithAggregatesInput[]
    NOT?: PromoRedemptionScalarWhereWithAggregatesInput | PromoRedemptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoRedemption"> | string
    promoCodeId?: StringWithAggregatesFilter<"PromoRedemption"> | string
    ownerId?: StringWithAggregatesFilter<"PromoRedemption"> | string
    redeemedAt?: DateTimeWithAggregatesFilter<"PromoRedemption"> | Date | string
  }

  export type BarAnalyticsWhereInput = {
    AND?: BarAnalyticsWhereInput | BarAnalyticsWhereInput[]
    OR?: BarAnalyticsWhereInput[]
    NOT?: BarAnalyticsWhereInput | BarAnalyticsWhereInput[]
    id?: StringFilter<"BarAnalytics"> | string
    barId?: StringFilter<"BarAnalytics"> | string
    date?: DateTimeFilter<"BarAnalytics"> | Date | string
    dayOfWeek?: IntFilter<"BarAnalytics"> | number
    profileViews?: IntFilter<"BarAnalytics"> | number
    profileClicks?: IntFilter<"BarAnalytics"> | number
    searchAppears?: IntFilter<"BarAnalytics"> | number
    createdAt?: DateTimeFilter<"BarAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"BarAnalytics"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type BarAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type BarAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barId_date?: BarAnalyticsBarIdDateCompoundUniqueInput
    AND?: BarAnalyticsWhereInput | BarAnalyticsWhereInput[]
    OR?: BarAnalyticsWhereInput[]
    NOT?: BarAnalyticsWhereInput | BarAnalyticsWhereInput[]
    barId?: StringFilter<"BarAnalytics"> | string
    date?: DateTimeFilter<"BarAnalytics"> | Date | string
    dayOfWeek?: IntFilter<"BarAnalytics"> | number
    profileViews?: IntFilter<"BarAnalytics"> | number
    profileClicks?: IntFilter<"BarAnalytics"> | number
    searchAppears?: IntFilter<"BarAnalytics"> | number
    createdAt?: DateTimeFilter<"BarAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"BarAnalytics"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id" | "barId_date">

  export type BarAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BarAnalyticsCountOrderByAggregateInput
    _avg?: BarAnalyticsAvgOrderByAggregateInput
    _max?: BarAnalyticsMaxOrderByAggregateInput
    _min?: BarAnalyticsMinOrderByAggregateInput
    _sum?: BarAnalyticsSumOrderByAggregateInput
  }

  export type BarAnalyticsScalarWhereWithAggregatesInput = {
    AND?: BarAnalyticsScalarWhereWithAggregatesInput | BarAnalyticsScalarWhereWithAggregatesInput[]
    OR?: BarAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: BarAnalyticsScalarWhereWithAggregatesInput | BarAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarAnalytics"> | string
    barId?: StringWithAggregatesFilter<"BarAnalytics"> | string
    date?: DateTimeWithAggregatesFilter<"BarAnalytics"> | Date | string
    dayOfWeek?: IntWithAggregatesFilter<"BarAnalytics"> | number
    profileViews?: IntWithAggregatesFilter<"BarAnalytics"> | number
    profileClicks?: IntWithAggregatesFilter<"BarAnalytics"> | number
    searchAppears?: IntWithAggregatesFilter<"BarAnalytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BarAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BarAnalytics"> | Date | string
  }

  export type SearchQueryWhereInput = {
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    location?: StringNullableFilter<"SearchQuery"> | string | null
    category?: StringNullableFilter<"SearchQuery"> | string | null
    dayOfWeek?: IntFilter<"SearchQuery"> | number
    count?: IntFilter<"SearchQuery"> | number
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }

  export type SearchQueryOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    location?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    query_location_category?: SearchQueryQueryLocationCategoryCompoundUniqueInput
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    query?: StringFilter<"SearchQuery"> | string
    location?: StringNullableFilter<"SearchQuery"> | string | null
    category?: StringNullableFilter<"SearchQuery"> | string | null
    dayOfWeek?: IntFilter<"SearchQuery"> | number
    count?: IntFilter<"SearchQuery"> | number
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    updatedAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }, "id" | "query_location_category">

  export type SearchQueryOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    location?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SearchQueryCountOrderByAggregateInput
    _avg?: SearchQueryAvgOrderByAggregateInput
    _max?: SearchQueryMaxOrderByAggregateInput
    _min?: SearchQueryMinOrderByAggregateInput
    _sum?: SearchQuerySumOrderByAggregateInput
  }

  export type SearchQueryScalarWhereWithAggregatesInput = {
    AND?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    OR?: SearchQueryScalarWhereWithAggregatesInput[]
    NOT?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchQuery"> | string
    query?: StringWithAggregatesFilter<"SearchQuery"> | string
    location?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    category?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    dayOfWeek?: IntWithAggregatesFilter<"SearchQuery"> | number
    count?: IntWithAggregatesFilter<"SearchQuery"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
  }

  export type BarClickWhereInput = {
    AND?: BarClickWhereInput | BarClickWhereInput[]
    OR?: BarClickWhereInput[]
    NOT?: BarClickWhereInput | BarClickWhereInput[]
    id?: StringFilter<"BarClick"> | string
    barId?: StringFilter<"BarClick"> | string
    source?: StringFilter<"BarClick"> | string
    query?: StringNullableFilter<"BarClick"> | string | null
    dayOfWeek?: IntFilter<"BarClick"> | number
    createdAt?: DateTimeFilter<"BarClick"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type BarClickOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    source?: SortOrder
    query?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type BarClickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BarClickWhereInput | BarClickWhereInput[]
    OR?: BarClickWhereInput[]
    NOT?: BarClickWhereInput | BarClickWhereInput[]
    barId?: StringFilter<"BarClick"> | string
    source?: StringFilter<"BarClick"> | string
    query?: StringNullableFilter<"BarClick"> | string | null
    dayOfWeek?: IntFilter<"BarClick"> | number
    createdAt?: DateTimeFilter<"BarClick"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type BarClickOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    source?: SortOrder
    query?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    _count?: BarClickCountOrderByAggregateInput
    _avg?: BarClickAvgOrderByAggregateInput
    _max?: BarClickMaxOrderByAggregateInput
    _min?: BarClickMinOrderByAggregateInput
    _sum?: BarClickSumOrderByAggregateInput
  }

  export type BarClickScalarWhereWithAggregatesInput = {
    AND?: BarClickScalarWhereWithAggregatesInput | BarClickScalarWhereWithAggregatesInput[]
    OR?: BarClickScalarWhereWithAggregatesInput[]
    NOT?: BarClickScalarWhereWithAggregatesInput | BarClickScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarClick"> | string
    barId?: StringWithAggregatesFilter<"BarClick"> | string
    source?: StringWithAggregatesFilter<"BarClick"> | string
    query?: StringNullableWithAggregatesFilter<"BarClick"> | string | null
    dayOfWeek?: IntWithAggregatesFilter<"BarClick"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BarClick"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    key?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    tier?: EnumBadgeTierFilter<"Badge"> | $Enums.BadgeTier
    category?: EnumBadgeCategoryFilter<"Badge"> | $Enums.BadgeCategory
    requirement?: StringFilter<"Badge"> | string
    color?: StringFilter<"Badge"> | string
    isActive?: BoolFilter<"Badge"> | boolean
    sortOrder?: IntFilter<"Badge"> | number
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    barBadges?: BarBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    tier?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    barBadges?: BarBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    tier?: EnumBadgeTierFilter<"Badge"> | $Enums.BadgeTier
    category?: EnumBadgeCategoryFilter<"Badge"> | $Enums.BadgeCategory
    requirement?: StringFilter<"Badge"> | string
    color?: StringFilter<"Badge"> | string
    isActive?: BoolFilter<"Badge"> | boolean
    sortOrder?: IntFilter<"Badge"> | number
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    barBadges?: BarBadgeListRelationFilter
  }, "id" | "key">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    tier?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    key?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    icon?: StringWithAggregatesFilter<"Badge"> | string
    tier?: EnumBadgeTierWithAggregatesFilter<"Badge"> | $Enums.BadgeTier
    category?: EnumBadgeCategoryWithAggregatesFilter<"Badge"> | $Enums.BadgeCategory
    requirement?: StringWithAggregatesFilter<"Badge"> | string
    color?: StringWithAggregatesFilter<"Badge"> | string
    isActive?: BoolWithAggregatesFilter<"Badge"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Badge"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type BarBadgeWhereInput = {
    AND?: BarBadgeWhereInput | BarBadgeWhereInput[]
    OR?: BarBadgeWhereInput[]
    NOT?: BarBadgeWhereInput | BarBadgeWhereInput[]
    id?: StringFilter<"BarBadge"> | string
    barId?: StringFilter<"BarBadge"> | string
    badgeKey?: StringFilter<"BarBadge"> | string
    awardedAt?: DateTimeFilter<"BarBadge"> | Date | string
    progress?: JsonNullableFilter<"BarBadge">
    metadata?: JsonNullableFilter<"BarBadge">
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }

  export type BarBadgeOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    badgeKey?: SortOrder
    awardedAt?: SortOrder
    progress?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    bar?: BarOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type BarBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barId_badgeKey?: BarBadgeBarIdBadgeKeyCompoundUniqueInput
    AND?: BarBadgeWhereInput | BarBadgeWhereInput[]
    OR?: BarBadgeWhereInput[]
    NOT?: BarBadgeWhereInput | BarBadgeWhereInput[]
    barId?: StringFilter<"BarBadge"> | string
    badgeKey?: StringFilter<"BarBadge"> | string
    awardedAt?: DateTimeFilter<"BarBadge"> | Date | string
    progress?: JsonNullableFilter<"BarBadge">
    metadata?: JsonNullableFilter<"BarBadge">
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }, "id" | "barId_badgeKey">

  export type BarBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    badgeKey?: SortOrder
    awardedAt?: SortOrder
    progress?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: BarBadgeCountOrderByAggregateInput
    _max?: BarBadgeMaxOrderByAggregateInput
    _min?: BarBadgeMinOrderByAggregateInput
  }

  export type BarBadgeScalarWhereWithAggregatesInput = {
    AND?: BarBadgeScalarWhereWithAggregatesInput | BarBadgeScalarWhereWithAggregatesInput[]
    OR?: BarBadgeScalarWhereWithAggregatesInput[]
    NOT?: BarBadgeScalarWhereWithAggregatesInput | BarBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarBadge"> | string
    barId?: StringWithAggregatesFilter<"BarBadge"> | string
    badgeKey?: StringWithAggregatesFilter<"BarBadge"> | string
    awardedAt?: DateTimeWithAggregatesFilter<"BarBadge"> | Date | string
    progress?: JsonNullableWithAggregatesFilter<"BarBadge">
    metadata?: JsonNullableWithAggregatesFilter<"BarBadge">
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    barId?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: StringNullableFilter<"InventoryItem"> | string | null
    bottleSizeMl?: IntFilter<"InventoryItem"> | number
    startingQtyBottles?: IntFilter<"InventoryItem"> | number
    costPerBottle?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    snapshotItems?: InventorySnapshotItemListRelationFilter
    shiftUsageItems?: ShiftUsageItemListRelationFilter
    costingProfiles?: CostingProfileListRelationFilter
    varianceAlerts?: VarianceAlertListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    snapshotItems?: InventorySnapshotItemOrderByRelationAggregateInput
    shiftUsageItems?: ShiftUsageItemOrderByRelationAggregateInput
    costingProfiles?: CostingProfileOrderByRelationAggregateInput
    varianceAlerts?: VarianceAlertOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    barId?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: StringNullableFilter<"InventoryItem"> | string | null
    bottleSizeMl?: IntFilter<"InventoryItem"> | number
    startingQtyBottles?: IntFilter<"InventoryItem"> | number
    costPerBottle?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    snapshotItems?: InventorySnapshotItemListRelationFilter
    shiftUsageItems?: ShiftUsageItemListRelationFilter
    costingProfiles?: CostingProfileListRelationFilter
    varianceAlerts?: VarianceAlertListRelationFilter
  }, "id">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    barId?: StringWithAggregatesFilter<"InventoryItem"> | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    category?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    bottleSizeMl?: IntWithAggregatesFilter<"InventoryItem"> | number
    startingQtyBottles?: IntWithAggregatesFilter<"InventoryItem"> | number
    costPerBottle?: DecimalNullableWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type InventoryImportWhereInput = {
    AND?: InventoryImportWhereInput | InventoryImportWhereInput[]
    OR?: InventoryImportWhereInput[]
    NOT?: InventoryImportWhereInput | InventoryImportWhereInput[]
    id?: StringFilter<"InventoryImport"> | string
    barId?: StringFilter<"InventoryImport"> | string
    fileName?: StringFilter<"InventoryImport"> | string
    rowsImported?: IntFilter<"InventoryImport"> | number
    mapping?: JsonNullableFilter<"InventoryImport">
    createdById?: StringNullableFilter<"InventoryImport"> | string | null
    createdAt?: DateTimeFilter<"InventoryImport"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InventoryImportOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    fileName?: SortOrder
    rowsImported?: SortOrder
    mapping?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type InventoryImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryImportWhereInput | InventoryImportWhereInput[]
    OR?: InventoryImportWhereInput[]
    NOT?: InventoryImportWhereInput | InventoryImportWhereInput[]
    barId?: StringFilter<"InventoryImport"> | string
    fileName?: StringFilter<"InventoryImport"> | string
    rowsImported?: IntFilter<"InventoryImport"> | number
    mapping?: JsonNullableFilter<"InventoryImport">
    createdById?: StringNullableFilter<"InventoryImport"> | string | null
    createdAt?: DateTimeFilter<"InventoryImport"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InventoryImportOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    fileName?: SortOrder
    rowsImported?: SortOrder
    mapping?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryImportCountOrderByAggregateInput
    _avg?: InventoryImportAvgOrderByAggregateInput
    _max?: InventoryImportMaxOrderByAggregateInput
    _min?: InventoryImportMinOrderByAggregateInput
    _sum?: InventoryImportSumOrderByAggregateInput
  }

  export type InventoryImportScalarWhereWithAggregatesInput = {
    AND?: InventoryImportScalarWhereWithAggregatesInput | InventoryImportScalarWhereWithAggregatesInput[]
    OR?: InventoryImportScalarWhereWithAggregatesInput[]
    NOT?: InventoryImportScalarWhereWithAggregatesInput | InventoryImportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryImport"> | string
    barId?: StringWithAggregatesFilter<"InventoryImport"> | string
    fileName?: StringWithAggregatesFilter<"InventoryImport"> | string
    rowsImported?: IntWithAggregatesFilter<"InventoryImport"> | number
    mapping?: JsonNullableWithAggregatesFilter<"InventoryImport">
    createdById?: StringNullableWithAggregatesFilter<"InventoryImport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryImport"> | Date | string
  }

  export type ShiftUsageWhereInput = {
    AND?: ShiftUsageWhereInput | ShiftUsageWhereInput[]
    OR?: ShiftUsageWhereInput[]
    NOT?: ShiftUsageWhereInput | ShiftUsageWhereInput[]
    id?: StringFilter<"ShiftUsage"> | string
    barId?: StringFilter<"ShiftUsage"> | string
    userId?: StringNullableFilter<"ShiftUsage"> | string | null
    shiftTime?: DateTimeFilter<"ShiftUsage"> | Date | string
    notes?: StringNullableFilter<"ShiftUsage"> | string | null
    createdAt?: DateTimeFilter<"ShiftUsage"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: ShiftUsageItemListRelationFilter
  }

  export type ShiftUsageOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrderInput | SortOrder
    shiftTime?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    items?: ShiftUsageItemOrderByRelationAggregateInput
  }

  export type ShiftUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftUsageWhereInput | ShiftUsageWhereInput[]
    OR?: ShiftUsageWhereInput[]
    NOT?: ShiftUsageWhereInput | ShiftUsageWhereInput[]
    barId?: StringFilter<"ShiftUsage"> | string
    userId?: StringNullableFilter<"ShiftUsage"> | string | null
    shiftTime?: DateTimeFilter<"ShiftUsage"> | Date | string
    notes?: StringNullableFilter<"ShiftUsage"> | string | null
    createdAt?: DateTimeFilter<"ShiftUsage"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: ShiftUsageItemListRelationFilter
  }, "id">

  export type ShiftUsageOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrderInput | SortOrder
    shiftTime?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ShiftUsageCountOrderByAggregateInput
    _max?: ShiftUsageMaxOrderByAggregateInput
    _min?: ShiftUsageMinOrderByAggregateInput
  }

  export type ShiftUsageScalarWhereWithAggregatesInput = {
    AND?: ShiftUsageScalarWhereWithAggregatesInput | ShiftUsageScalarWhereWithAggregatesInput[]
    OR?: ShiftUsageScalarWhereWithAggregatesInput[]
    NOT?: ShiftUsageScalarWhereWithAggregatesInput | ShiftUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftUsage"> | string
    barId?: StringWithAggregatesFilter<"ShiftUsage"> | string
    userId?: StringNullableWithAggregatesFilter<"ShiftUsage"> | string | null
    shiftTime?: DateTimeWithAggregatesFilter<"ShiftUsage"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ShiftUsage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShiftUsage"> | Date | string
  }

  export type ShiftUsageItemWhereInput = {
    AND?: ShiftUsageItemWhereInput | ShiftUsageItemWhereInput[]
    OR?: ShiftUsageItemWhereInput[]
    NOT?: ShiftUsageItemWhereInput | ShiftUsageItemWhereInput[]
    id?: StringFilter<"ShiftUsageItem"> | string
    shiftUsageId?: StringFilter<"ShiftUsageItem"> | string
    inventoryItemId?: StringFilter<"ShiftUsageItem"> | string
    quantityUsed?: DecimalFilter<"ShiftUsageItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ShiftUsageItem"> | string | null
    shiftUsage?: XOR<ShiftUsageScalarRelationFilter, ShiftUsageWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type ShiftUsageItemOrderByWithRelationInput = {
    id?: SortOrder
    shiftUsageId?: SortOrder
    inventoryItemId?: SortOrder
    quantityUsed?: SortOrder
    notes?: SortOrderInput | SortOrder
    shiftUsage?: ShiftUsageOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
  }

  export type ShiftUsageItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftUsageItemWhereInput | ShiftUsageItemWhereInput[]
    OR?: ShiftUsageItemWhereInput[]
    NOT?: ShiftUsageItemWhereInput | ShiftUsageItemWhereInput[]
    shiftUsageId?: StringFilter<"ShiftUsageItem"> | string
    inventoryItemId?: StringFilter<"ShiftUsageItem"> | string
    quantityUsed?: DecimalFilter<"ShiftUsageItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ShiftUsageItem"> | string | null
    shiftUsage?: XOR<ShiftUsageScalarRelationFilter, ShiftUsageWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type ShiftUsageItemOrderByWithAggregationInput = {
    id?: SortOrder
    shiftUsageId?: SortOrder
    inventoryItemId?: SortOrder
    quantityUsed?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ShiftUsageItemCountOrderByAggregateInput
    _avg?: ShiftUsageItemAvgOrderByAggregateInput
    _max?: ShiftUsageItemMaxOrderByAggregateInput
    _min?: ShiftUsageItemMinOrderByAggregateInput
    _sum?: ShiftUsageItemSumOrderByAggregateInput
  }

  export type ShiftUsageItemScalarWhereWithAggregatesInput = {
    AND?: ShiftUsageItemScalarWhereWithAggregatesInput | ShiftUsageItemScalarWhereWithAggregatesInput[]
    OR?: ShiftUsageItemScalarWhereWithAggregatesInput[]
    NOT?: ShiftUsageItemScalarWhereWithAggregatesInput | ShiftUsageItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftUsageItem"> | string
    shiftUsageId?: StringWithAggregatesFilter<"ShiftUsageItem"> | string
    inventoryItemId?: StringWithAggregatesFilter<"ShiftUsageItem"> | string
    quantityUsed?: DecimalWithAggregatesFilter<"ShiftUsageItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"ShiftUsageItem"> | string | null
  }

  export type InventorySnapshotWhereInput = {
    AND?: InventorySnapshotWhereInput | InventorySnapshotWhereInput[]
    OR?: InventorySnapshotWhereInput[]
    NOT?: InventorySnapshotWhereInput | InventorySnapshotWhereInput[]
    id?: StringFilter<"InventorySnapshot"> | string
    barId?: StringFilter<"InventorySnapshot"> | string
    userId?: StringNullableFilter<"InventorySnapshot"> | string | null
    snapshotDate?: DateTimeFilter<"InventorySnapshot"> | Date | string
    notes?: StringNullableFilter<"InventorySnapshot"> | string | null
    createdAt?: DateTimeFilter<"InventorySnapshot"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: InventorySnapshotItemListRelationFilter
  }

  export type InventorySnapshotOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrderInput | SortOrder
    snapshotDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    items?: InventorySnapshotItemOrderByRelationAggregateInput
  }

  export type InventorySnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventorySnapshotWhereInput | InventorySnapshotWhereInput[]
    OR?: InventorySnapshotWhereInput[]
    NOT?: InventorySnapshotWhereInput | InventorySnapshotWhereInput[]
    barId?: StringFilter<"InventorySnapshot"> | string
    userId?: StringNullableFilter<"InventorySnapshot"> | string | null
    snapshotDate?: DateTimeFilter<"InventorySnapshot"> | Date | string
    notes?: StringNullableFilter<"InventorySnapshot"> | string | null
    createdAt?: DateTimeFilter<"InventorySnapshot"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: InventorySnapshotItemListRelationFilter
  }, "id">

  export type InventorySnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrderInput | SortOrder
    snapshotDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventorySnapshotCountOrderByAggregateInput
    _max?: InventorySnapshotMaxOrderByAggregateInput
    _min?: InventorySnapshotMinOrderByAggregateInput
  }

  export type InventorySnapshotScalarWhereWithAggregatesInput = {
    AND?: InventorySnapshotScalarWhereWithAggregatesInput | InventorySnapshotScalarWhereWithAggregatesInput[]
    OR?: InventorySnapshotScalarWhereWithAggregatesInput[]
    NOT?: InventorySnapshotScalarWhereWithAggregatesInput | InventorySnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventorySnapshot"> | string
    barId?: StringWithAggregatesFilter<"InventorySnapshot"> | string
    userId?: StringNullableWithAggregatesFilter<"InventorySnapshot"> | string | null
    snapshotDate?: DateTimeWithAggregatesFilter<"InventorySnapshot"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"InventorySnapshot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventorySnapshot"> | Date | string
  }

  export type InventorySnapshotItemWhereInput = {
    AND?: InventorySnapshotItemWhereInput | InventorySnapshotItemWhereInput[]
    OR?: InventorySnapshotItemWhereInput[]
    NOT?: InventorySnapshotItemWhereInput | InventorySnapshotItemWhereInput[]
    id?: StringFilter<"InventorySnapshotItem"> | string
    snapshotId?: StringFilter<"InventorySnapshotItem"> | string
    inventoryItemId?: StringFilter<"InventorySnapshotItem"> | string
    quantityOnHand?: DecimalFilter<"InventorySnapshotItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"InventorySnapshotItem"> | string | null
    snapshot?: XOR<InventorySnapshotScalarRelationFilter, InventorySnapshotWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    bottlePhoto?: XOR<BottlePhotoNullableScalarRelationFilter, BottlePhotoWhereInput> | null
  }

  export type InventorySnapshotItemOrderByWithRelationInput = {
    id?: SortOrder
    snapshotId?: SortOrder
    inventoryItemId?: SortOrder
    quantityOnHand?: SortOrder
    notes?: SortOrderInput | SortOrder
    snapshot?: InventorySnapshotOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
    bottlePhoto?: BottlePhotoOrderByWithRelationInput
  }

  export type InventorySnapshotItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventorySnapshotItemWhereInput | InventorySnapshotItemWhereInput[]
    OR?: InventorySnapshotItemWhereInput[]
    NOT?: InventorySnapshotItemWhereInput | InventorySnapshotItemWhereInput[]
    snapshotId?: StringFilter<"InventorySnapshotItem"> | string
    inventoryItemId?: StringFilter<"InventorySnapshotItem"> | string
    quantityOnHand?: DecimalFilter<"InventorySnapshotItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"InventorySnapshotItem"> | string | null
    snapshot?: XOR<InventorySnapshotScalarRelationFilter, InventorySnapshotWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    bottlePhoto?: XOR<BottlePhotoNullableScalarRelationFilter, BottlePhotoWhereInput> | null
  }, "id">

  export type InventorySnapshotItemOrderByWithAggregationInput = {
    id?: SortOrder
    snapshotId?: SortOrder
    inventoryItemId?: SortOrder
    quantityOnHand?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: InventorySnapshotItemCountOrderByAggregateInput
    _avg?: InventorySnapshotItemAvgOrderByAggregateInput
    _max?: InventorySnapshotItemMaxOrderByAggregateInput
    _min?: InventorySnapshotItemMinOrderByAggregateInput
    _sum?: InventorySnapshotItemSumOrderByAggregateInput
  }

  export type InventorySnapshotItemScalarWhereWithAggregatesInput = {
    AND?: InventorySnapshotItemScalarWhereWithAggregatesInput | InventorySnapshotItemScalarWhereWithAggregatesInput[]
    OR?: InventorySnapshotItemScalarWhereWithAggregatesInput[]
    NOT?: InventorySnapshotItemScalarWhereWithAggregatesInput | InventorySnapshotItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventorySnapshotItem"> | string
    snapshotId?: StringWithAggregatesFilter<"InventorySnapshotItem"> | string
    inventoryItemId?: StringWithAggregatesFilter<"InventorySnapshotItem"> | string
    quantityOnHand?: DecimalWithAggregatesFilter<"InventorySnapshotItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"InventorySnapshotItem"> | string | null
  }

  export type BottlePhotoWhereInput = {
    AND?: BottlePhotoWhereInput | BottlePhotoWhereInput[]
    OR?: BottlePhotoWhereInput[]
    NOT?: BottlePhotoWhereInput | BottlePhotoWhereInput[]
    id?: StringFilter<"BottlePhoto"> | string
    snapshotItemId?: StringFilter<"BottlePhoto"> | string
    imageUrl?: StringFilter<"BottlePhoto"> | string
    estimatedPct?: DecimalNullableFilter<"BottlePhoto"> | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: DecimalNullableFilter<"BottlePhoto"> | Decimal | DecimalJsLike | number | string | null
    modelVersion?: StringNullableFilter<"BottlePhoto"> | string | null
    createdAt?: DateTimeFilter<"BottlePhoto"> | Date | string
    snapshotItem?: XOR<InventorySnapshotItemScalarRelationFilter, InventorySnapshotItemWhereInput>
  }

  export type BottlePhotoOrderByWithRelationInput = {
    id?: SortOrder
    snapshotItemId?: SortOrder
    imageUrl?: SortOrder
    estimatedPct?: SortOrderInput | SortOrder
    estimatedMl?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    snapshotItem?: InventorySnapshotItemOrderByWithRelationInput
  }

  export type BottlePhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    snapshotItemId?: string
    AND?: BottlePhotoWhereInput | BottlePhotoWhereInput[]
    OR?: BottlePhotoWhereInput[]
    NOT?: BottlePhotoWhereInput | BottlePhotoWhereInput[]
    imageUrl?: StringFilter<"BottlePhoto"> | string
    estimatedPct?: DecimalNullableFilter<"BottlePhoto"> | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: DecimalNullableFilter<"BottlePhoto"> | Decimal | DecimalJsLike | number | string | null
    modelVersion?: StringNullableFilter<"BottlePhoto"> | string | null
    createdAt?: DateTimeFilter<"BottlePhoto"> | Date | string
    snapshotItem?: XOR<InventorySnapshotItemScalarRelationFilter, InventorySnapshotItemWhereInput>
  }, "id" | "snapshotItemId">

  export type BottlePhotoOrderByWithAggregationInput = {
    id?: SortOrder
    snapshotItemId?: SortOrder
    imageUrl?: SortOrder
    estimatedPct?: SortOrderInput | SortOrder
    estimatedMl?: SortOrderInput | SortOrder
    modelVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BottlePhotoCountOrderByAggregateInput
    _avg?: BottlePhotoAvgOrderByAggregateInput
    _max?: BottlePhotoMaxOrderByAggregateInput
    _min?: BottlePhotoMinOrderByAggregateInput
    _sum?: BottlePhotoSumOrderByAggregateInput
  }

  export type BottlePhotoScalarWhereWithAggregatesInput = {
    AND?: BottlePhotoScalarWhereWithAggregatesInput | BottlePhotoScalarWhereWithAggregatesInput[]
    OR?: BottlePhotoScalarWhereWithAggregatesInput[]
    NOT?: BottlePhotoScalarWhereWithAggregatesInput | BottlePhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BottlePhoto"> | string
    snapshotItemId?: StringWithAggregatesFilter<"BottlePhoto"> | string
    imageUrl?: StringWithAggregatesFilter<"BottlePhoto"> | string
    estimatedPct?: DecimalNullableWithAggregatesFilter<"BottlePhoto"> | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: DecimalNullableWithAggregatesFilter<"BottlePhoto"> | Decimal | DecimalJsLike | number | string | null
    modelVersion?: StringNullableWithAggregatesFilter<"BottlePhoto"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BottlePhoto"> | Date | string
  }

  export type CostingProfileWhereInput = {
    AND?: CostingProfileWhereInput | CostingProfileWhereInput[]
    OR?: CostingProfileWhereInput[]
    NOT?: CostingProfileWhereInput | CostingProfileWhereInput[]
    id?: StringFilter<"CostingProfile"> | string
    inventoryItemId?: StringFilter<"CostingProfile"> | string
    pourSizeOz?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CostingProfile"> | Date | string
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type CostingProfileOrderByWithRelationInput = {
    id?: SortOrder
    inventoryItemId?: SortOrder
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
    createdAt?: SortOrder
    inventoryItem?: InventoryItemOrderByWithRelationInput
  }

  export type CostingProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CostingProfileWhereInput | CostingProfileWhereInput[]
    OR?: CostingProfileWhereInput[]
    NOT?: CostingProfileWhereInput | CostingProfileWhereInput[]
    inventoryItemId?: StringFilter<"CostingProfile"> | string
    pourSizeOz?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CostingProfile"> | Date | string
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type CostingProfileOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryItemId?: SortOrder
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
    createdAt?: SortOrder
    _count?: CostingProfileCountOrderByAggregateInput
    _avg?: CostingProfileAvgOrderByAggregateInput
    _max?: CostingProfileMaxOrderByAggregateInput
    _min?: CostingProfileMinOrderByAggregateInput
    _sum?: CostingProfileSumOrderByAggregateInput
  }

  export type CostingProfileScalarWhereWithAggregatesInput = {
    AND?: CostingProfileScalarWhereWithAggregatesInput | CostingProfileScalarWhereWithAggregatesInput[]
    OR?: CostingProfileScalarWhereWithAggregatesInput[]
    NOT?: CostingProfileScalarWhereWithAggregatesInput | CostingProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostingProfile"> | string
    inventoryItemId?: StringWithAggregatesFilter<"CostingProfile"> | string
    pourSizeOz?: DecimalWithAggregatesFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalWithAggregatesFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalWithAggregatesFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalWithAggregatesFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalWithAggregatesFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"CostingProfile"> | Date | string
  }

  export type VarianceAlertWhereInput = {
    AND?: VarianceAlertWhereInput | VarianceAlertWhereInput[]
    OR?: VarianceAlertWhereInput[]
    NOT?: VarianceAlertWhereInput | VarianceAlertWhereInput[]
    id?: StringFilter<"VarianceAlert"> | string
    barId?: StringFilter<"VarianceAlert"> | string
    inventoryItemId?: StringFilter<"VarianceAlert"> | string
    periodStart?: DateTimeFilter<"VarianceAlert"> | Date | string
    periodEnd?: DateTimeFilter<"VarianceAlert"> | Date | string
    expectedMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    severity?: StringFilter<"VarianceAlert"> | string
    reasonHint?: StringNullableFilter<"VarianceAlert"> | string | null
    createdAt?: DateTimeFilter<"VarianceAlert"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type VarianceAlertOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    inventoryItemId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
    severity?: SortOrder
    reasonHint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
  }

  export type VarianceAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VarianceAlertWhereInput | VarianceAlertWhereInput[]
    OR?: VarianceAlertWhereInput[]
    NOT?: VarianceAlertWhereInput | VarianceAlertWhereInput[]
    barId?: StringFilter<"VarianceAlert"> | string
    inventoryItemId?: StringFilter<"VarianceAlert"> | string
    periodStart?: DateTimeFilter<"VarianceAlert"> | Date | string
    periodEnd?: DateTimeFilter<"VarianceAlert"> | Date | string
    expectedMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    severity?: StringFilter<"VarianceAlert"> | string
    reasonHint?: StringNullableFilter<"VarianceAlert"> | string | null
    createdAt?: DateTimeFilter<"VarianceAlert"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type VarianceAlertOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    inventoryItemId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
    severity?: SortOrder
    reasonHint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VarianceAlertCountOrderByAggregateInput
    _avg?: VarianceAlertAvgOrderByAggregateInput
    _max?: VarianceAlertMaxOrderByAggregateInput
    _min?: VarianceAlertMinOrderByAggregateInput
    _sum?: VarianceAlertSumOrderByAggregateInput
  }

  export type VarianceAlertScalarWhereWithAggregatesInput = {
    AND?: VarianceAlertScalarWhereWithAggregatesInput | VarianceAlertScalarWhereWithAggregatesInput[]
    OR?: VarianceAlertScalarWhereWithAggregatesInput[]
    NOT?: VarianceAlertScalarWhereWithAggregatesInput | VarianceAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VarianceAlert"> | string
    barId?: StringWithAggregatesFilter<"VarianceAlert"> | string
    inventoryItemId?: StringWithAggregatesFilter<"VarianceAlert"> | string
    periodStart?: DateTimeWithAggregatesFilter<"VarianceAlert"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"VarianceAlert"> | Date | string
    expectedMl?: DecimalWithAggregatesFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalWithAggregatesFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalWithAggregatesFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalWithAggregatesFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    severity?: StringWithAggregatesFilter<"VarianceAlert"> | string
    reasonHint?: StringNullableWithAggregatesFilter<"VarianceAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VarianceAlert"> | Date | string
  }

  export type BarLicenseWhereInput = {
    AND?: BarLicenseWhereInput | BarLicenseWhereInput[]
    OR?: BarLicenseWhereInput[]
    NOT?: BarLicenseWhereInput | BarLicenseWhereInput[]
    id?: StringFilter<"BarLicense"> | string
    barId?: StringFilter<"BarLicense"> | string
    ownerId?: StringFilter<"BarLicense"> | string
    status?: StringFilter<"BarLicense"> | string
    priceCents?: IntFilter<"BarLicense"> | number
    currency?: StringFilter<"BarLicense"> | string
    billingCycle?: StringFilter<"BarLicense"> | string
    externalId?: StringNullableFilter<"BarLicense"> | string | null
    createdAt?: DateTimeFilter<"BarLicense"> | Date | string
    updatedAt?: DateTimeFilter<"BarLicense"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type BarLicenseOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    owner?: OwnerOrderByWithRelationInput
  }

  export type BarLicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barId?: string
    AND?: BarLicenseWhereInput | BarLicenseWhereInput[]
    OR?: BarLicenseWhereInput[]
    NOT?: BarLicenseWhereInput | BarLicenseWhereInput[]
    ownerId?: StringFilter<"BarLicense"> | string
    status?: StringFilter<"BarLicense"> | string
    priceCents?: IntFilter<"BarLicense"> | number
    currency?: StringFilter<"BarLicense"> | string
    billingCycle?: StringFilter<"BarLicense"> | string
    externalId?: StringNullableFilter<"BarLicense"> | string | null
    createdAt?: DateTimeFilter<"BarLicense"> | Date | string
    updatedAt?: DateTimeFilter<"BarLicense"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "id" | "barId">

  export type BarLicenseOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BarLicenseCountOrderByAggregateInput
    _avg?: BarLicenseAvgOrderByAggregateInput
    _max?: BarLicenseMaxOrderByAggregateInput
    _min?: BarLicenseMinOrderByAggregateInput
    _sum?: BarLicenseSumOrderByAggregateInput
  }

  export type BarLicenseScalarWhereWithAggregatesInput = {
    AND?: BarLicenseScalarWhereWithAggregatesInput | BarLicenseScalarWhereWithAggregatesInput[]
    OR?: BarLicenseScalarWhereWithAggregatesInput[]
    NOT?: BarLicenseScalarWhereWithAggregatesInput | BarLicenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarLicense"> | string
    barId?: StringWithAggregatesFilter<"BarLicense"> | string
    ownerId?: StringWithAggregatesFilter<"BarLicense"> | string
    status?: StringWithAggregatesFilter<"BarLicense"> | string
    priceCents?: IntWithAggregatesFilter<"BarLicense"> | number
    currency?: StringWithAggregatesFilter<"BarLicense"> | string
    billingCycle?: StringWithAggregatesFilter<"BarLicense"> | string
    externalId?: StringNullableWithAggregatesFilter<"BarLicense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BarLicense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BarLicense"> | Date | string
  }

  export type BarVisitWhereInput = {
    AND?: BarVisitWhereInput | BarVisitWhereInput[]
    OR?: BarVisitWhereInput[]
    NOT?: BarVisitWhereInput | BarVisitWhereInput[]
    id?: StringFilter<"BarVisit"> | string
    barId?: StringFilter<"BarVisit"> | string
    userId?: StringNullableFilter<"BarVisit"> | string | null
    source?: StringFilter<"BarVisit"> | string
    verificationMethod?: StringFilter<"BarVisit"> | string
    clickId?: StringNullableFilter<"BarVisit"> | string | null
    promoCodeId?: StringNullableFilter<"BarVisit"> | string | null
    metadata?: JsonNullableFilter<"BarVisit">
    visitedAt?: DateTimeFilter<"BarVisit"> | Date | string
    createdAt?: DateTimeFilter<"BarVisit"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BarVisitOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrderInput | SortOrder
    source?: SortOrder
    verificationMethod?: SortOrder
    clickId?: SortOrderInput | SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    visitedAt?: SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BarVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BarVisitWhereInput | BarVisitWhereInput[]
    OR?: BarVisitWhereInput[]
    NOT?: BarVisitWhereInput | BarVisitWhereInput[]
    barId?: StringFilter<"BarVisit"> | string
    userId?: StringNullableFilter<"BarVisit"> | string | null
    source?: StringFilter<"BarVisit"> | string
    verificationMethod?: StringFilter<"BarVisit"> | string
    clickId?: StringNullableFilter<"BarVisit"> | string | null
    promoCodeId?: StringNullableFilter<"BarVisit"> | string | null
    metadata?: JsonNullableFilter<"BarVisit">
    visitedAt?: DateTimeFilter<"BarVisit"> | Date | string
    createdAt?: DateTimeFilter<"BarVisit"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type BarVisitOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrderInput | SortOrder
    source?: SortOrder
    verificationMethod?: SortOrder
    clickId?: SortOrderInput | SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    visitedAt?: SortOrder
    createdAt?: SortOrder
    _count?: BarVisitCountOrderByAggregateInput
    _max?: BarVisitMaxOrderByAggregateInput
    _min?: BarVisitMinOrderByAggregateInput
  }

  export type BarVisitScalarWhereWithAggregatesInput = {
    AND?: BarVisitScalarWhereWithAggregatesInput | BarVisitScalarWhereWithAggregatesInput[]
    OR?: BarVisitScalarWhereWithAggregatesInput[]
    NOT?: BarVisitScalarWhereWithAggregatesInput | BarVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarVisit"> | string
    barId?: StringWithAggregatesFilter<"BarVisit"> | string
    userId?: StringNullableWithAggregatesFilter<"BarVisit"> | string | null
    source?: StringWithAggregatesFilter<"BarVisit"> | string
    verificationMethod?: StringWithAggregatesFilter<"BarVisit"> | string
    clickId?: StringNullableWithAggregatesFilter<"BarVisit"> | string | null
    promoCodeId?: StringNullableWithAggregatesFilter<"BarVisit"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"BarVisit">
    visitedAt?: DateTimeWithAggregatesFilter<"BarVisit"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BarVisit"> | Date | string
  }

  export type BarMembershipWhereInput = {
    AND?: BarMembershipWhereInput | BarMembershipWhereInput[]
    OR?: BarMembershipWhereInput[]
    NOT?: BarMembershipWhereInput | BarMembershipWhereInput[]
    id?: StringFilter<"BarMembership"> | string
    barId?: StringFilter<"BarMembership"> | string
    userId?: StringFilter<"BarMembership"> | string
    role?: EnumBarMemberRoleFilter<"BarMembership"> | $Enums.BarMemberRole
    createdAt?: DateTimeFilter<"BarMembership"> | Date | string
    updatedAt?: DateTimeFilter<"BarMembership"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type BarMembershipOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type BarMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BarMembershipWhereInput | BarMembershipWhereInput[]
    OR?: BarMembershipWhereInput[]
    NOT?: BarMembershipWhereInput | BarMembershipWhereInput[]
    barId?: StringFilter<"BarMembership"> | string
    userId?: StringFilter<"BarMembership"> | string
    role?: EnumBarMemberRoleFilter<"BarMembership"> | $Enums.BarMemberRole
    createdAt?: DateTimeFilter<"BarMembership"> | Date | string
    updatedAt?: DateTimeFilter<"BarMembership"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type BarMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BarMembershipCountOrderByAggregateInput
    _max?: BarMembershipMaxOrderByAggregateInput
    _min?: BarMembershipMinOrderByAggregateInput
  }

  export type BarMembershipScalarWhereWithAggregatesInput = {
    AND?: BarMembershipScalarWhereWithAggregatesInput | BarMembershipScalarWhereWithAggregatesInput[]
    OR?: BarMembershipScalarWhereWithAggregatesInput[]
    NOT?: BarMembershipScalarWhereWithAggregatesInput | BarMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarMembership"> | string
    barId?: StringWithAggregatesFilter<"BarMembership"> | string
    userId?: StringWithAggregatesFilter<"BarMembership"> | string
    role?: EnumBarMemberRoleWithAggregatesFilter<"BarMembership"> | $Enums.BarMemberRole
    createdAt?: DateTimeWithAggregatesFilter<"BarMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BarMembership"> | Date | string
  }

  export type PatronSearchEventWhereInput = {
    AND?: PatronSearchEventWhereInput | PatronSearchEventWhereInput[]
    OR?: PatronSearchEventWhereInput[]
    NOT?: PatronSearchEventWhereInput | PatronSearchEventWhereInput[]
    id?: StringFilter<"PatronSearchEvent"> | string
    barId?: StringNullableFilter<"PatronSearchEvent"> | string | null
    query?: StringNullableFilter<"PatronSearchEvent"> | string | null
    category?: StringNullableFilter<"PatronSearchEvent"> | string | null
    city?: StringNullableFilter<"PatronSearchEvent"> | string | null
    createdAt?: DateTimeFilter<"PatronSearchEvent"> | Date | string
    bar?: XOR<BarNullableScalarRelationFilter, BarWhereInput> | null
  }

  export type PatronSearchEventOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrderInput | SortOrder
    query?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type PatronSearchEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatronSearchEventWhereInput | PatronSearchEventWhereInput[]
    OR?: PatronSearchEventWhereInput[]
    NOT?: PatronSearchEventWhereInput | PatronSearchEventWhereInput[]
    barId?: StringNullableFilter<"PatronSearchEvent"> | string | null
    query?: StringNullableFilter<"PatronSearchEvent"> | string | null
    category?: StringNullableFilter<"PatronSearchEvent"> | string | null
    city?: StringNullableFilter<"PatronSearchEvent"> | string | null
    createdAt?: DateTimeFilter<"PatronSearchEvent"> | Date | string
    bar?: XOR<BarNullableScalarRelationFilter, BarWhereInput> | null
  }, "id">

  export type PatronSearchEventOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrderInput | SortOrder
    query?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PatronSearchEventCountOrderByAggregateInput
    _max?: PatronSearchEventMaxOrderByAggregateInput
    _min?: PatronSearchEventMinOrderByAggregateInput
  }

  export type PatronSearchEventScalarWhereWithAggregatesInput = {
    AND?: PatronSearchEventScalarWhereWithAggregatesInput | PatronSearchEventScalarWhereWithAggregatesInput[]
    OR?: PatronSearchEventScalarWhereWithAggregatesInput[]
    NOT?: PatronSearchEventScalarWhereWithAggregatesInput | PatronSearchEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatronSearchEvent"> | string
    barId?: StringNullableWithAggregatesFilter<"PatronSearchEvent"> | string | null
    query?: StringNullableWithAggregatesFilter<"PatronSearchEvent"> | string | null
    category?: StringNullableWithAggregatesFilter<"PatronSearchEvent"> | string | null
    city?: StringNullableWithAggregatesFilter<"PatronSearchEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PatronSearchEvent"> | Date | string
  }

  export type BarActionWhereInput = {
    AND?: BarActionWhereInput | BarActionWhereInput[]
    OR?: BarActionWhereInput[]
    NOT?: BarActionWhereInput | BarActionWhereInput[]
    id?: StringFilter<"BarAction"> | string
    barId?: StringFilter<"BarAction"> | string
    action?: StringFilter<"BarAction"> | string
    createdAt?: DateTimeFilter<"BarAction"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type BarActionOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type BarActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BarActionWhereInput | BarActionWhereInput[]
    OR?: BarActionWhereInput[]
    NOT?: BarActionWhereInput | BarActionWhereInput[]
    barId?: StringFilter<"BarAction"> | string
    action?: StringFilter<"BarAction"> | string
    createdAt?: DateTimeFilter<"BarAction"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type BarActionOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    _count?: BarActionCountOrderByAggregateInput
    _max?: BarActionMaxOrderByAggregateInput
    _min?: BarActionMinOrderByAggregateInput
  }

  export type BarActionScalarWhereWithAggregatesInput = {
    AND?: BarActionScalarWhereWithAggregatesInput | BarActionScalarWhereWithAggregatesInput[]
    OR?: BarActionScalarWhereWithAggregatesInput[]
    NOT?: BarActionScalarWhereWithAggregatesInput | BarActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarAction"> | string
    barId?: StringWithAggregatesFilter<"BarAction"> | string
    action?: StringWithAggregatesFilter<"BarAction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BarAction"> | Date | string
  }

  export type BarFollowerWhereInput = {
    AND?: BarFollowerWhereInput | BarFollowerWhereInput[]
    OR?: BarFollowerWhereInput[]
    NOT?: BarFollowerWhereInput | BarFollowerWhereInput[]
    id?: StringFilter<"BarFollower"> | string
    barId?: StringFilter<"BarFollower"> | string
    patronEmail?: StringFilter<"BarFollower"> | string
    createdAt?: DateTimeFilter<"BarFollower"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type BarFollowerOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    patronEmail?: SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type BarFollowerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barId_patronEmail?: BarFollowerBarIdPatronEmailCompoundUniqueInput
    AND?: BarFollowerWhereInput | BarFollowerWhereInput[]
    OR?: BarFollowerWhereInput[]
    NOT?: BarFollowerWhereInput | BarFollowerWhereInput[]
    barId?: StringFilter<"BarFollower"> | string
    patronEmail?: StringFilter<"BarFollower"> | string
    createdAt?: DateTimeFilter<"BarFollower"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id" | "barId_patronEmail">

  export type BarFollowerOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    patronEmail?: SortOrder
    createdAt?: SortOrder
    _count?: BarFollowerCountOrderByAggregateInput
    _max?: BarFollowerMaxOrderByAggregateInput
    _min?: BarFollowerMinOrderByAggregateInput
  }

  export type BarFollowerScalarWhereWithAggregatesInput = {
    AND?: BarFollowerScalarWhereWithAggregatesInput | BarFollowerScalarWhereWithAggregatesInput[]
    OR?: BarFollowerScalarWhereWithAggregatesInput[]
    NOT?: BarFollowerScalarWhereWithAggregatesInput | BarFollowerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarFollower"> | string
    barId?: StringWithAggregatesFilter<"BarFollower"> | string
    patronEmail?: StringWithAggregatesFilter<"BarFollower"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BarFollower"> | Date | string
  }

  export type BoostWhereInput = {
    AND?: BoostWhereInput | BoostWhereInput[]
    OR?: BoostWhereInput[]
    NOT?: BoostWhereInput | BoostWhereInput[]
    id?: StringFilter<"Boost"> | string
    barId?: StringFilter<"Boost"> | string
    eventId?: StringNullableFilter<"Boost"> | string | null
    startAt?: DateTimeFilter<"Boost"> | Date | string
    endAt?: DateTimeFilter<"Boost"> | Date | string
    budgetCents?: IntFilter<"Boost"> | number
    status?: StringFilter<"Boost"> | string
    createdAt?: DateTimeFilter<"Boost"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    metrics?: BoostMetricListRelationFilter
  }

  export type BoostOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    eventId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    budgetCents?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    metrics?: BoostMetricOrderByRelationAggregateInput
  }

  export type BoostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BoostWhereInput | BoostWhereInput[]
    OR?: BoostWhereInput[]
    NOT?: BoostWhereInput | BoostWhereInput[]
    barId?: StringFilter<"Boost"> | string
    eventId?: StringNullableFilter<"Boost"> | string | null
    startAt?: DateTimeFilter<"Boost"> | Date | string
    endAt?: DateTimeFilter<"Boost"> | Date | string
    budgetCents?: IntFilter<"Boost"> | number
    status?: StringFilter<"Boost"> | string
    createdAt?: DateTimeFilter<"Boost"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    metrics?: BoostMetricListRelationFilter
  }, "id">

  export type BoostOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    eventId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    budgetCents?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: BoostCountOrderByAggregateInput
    _avg?: BoostAvgOrderByAggregateInput
    _max?: BoostMaxOrderByAggregateInput
    _min?: BoostMinOrderByAggregateInput
    _sum?: BoostSumOrderByAggregateInput
  }

  export type BoostScalarWhereWithAggregatesInput = {
    AND?: BoostScalarWhereWithAggregatesInput | BoostScalarWhereWithAggregatesInput[]
    OR?: BoostScalarWhereWithAggregatesInput[]
    NOT?: BoostScalarWhereWithAggregatesInput | BoostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Boost"> | string
    barId?: StringWithAggregatesFilter<"Boost"> | string
    eventId?: StringNullableWithAggregatesFilter<"Boost"> | string | null
    startAt?: DateTimeWithAggregatesFilter<"Boost"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"Boost"> | Date | string
    budgetCents?: IntWithAggregatesFilter<"Boost"> | number
    status?: StringWithAggregatesFilter<"Boost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Boost"> | Date | string
  }

  export type BoostMetricWhereInput = {
    AND?: BoostMetricWhereInput | BoostMetricWhereInput[]
    OR?: BoostMetricWhereInput[]
    NOT?: BoostMetricWhereInput | BoostMetricWhereInput[]
    id?: StringFilter<"BoostMetric"> | string
    boostId?: StringFilter<"BoostMetric"> | string
    date?: DateTimeFilter<"BoostMetric"> | Date | string
    impressions?: IntFilter<"BoostMetric"> | number
    clicks?: IntFilter<"BoostMetric"> | number
    boost?: XOR<BoostScalarRelationFilter, BoostWhereInput>
  }

  export type BoostMetricOrderByWithRelationInput = {
    id?: SortOrder
    boostId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    boost?: BoostOrderByWithRelationInput
  }

  export type BoostMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    boostId_date?: BoostMetricBoostIdDateCompoundUniqueInput
    AND?: BoostMetricWhereInput | BoostMetricWhereInput[]
    OR?: BoostMetricWhereInput[]
    NOT?: BoostMetricWhereInput | BoostMetricWhereInput[]
    boostId?: StringFilter<"BoostMetric"> | string
    date?: DateTimeFilter<"BoostMetric"> | Date | string
    impressions?: IntFilter<"BoostMetric"> | number
    clicks?: IntFilter<"BoostMetric"> | number
    boost?: XOR<BoostScalarRelationFilter, BoostWhereInput>
  }, "id" | "boostId_date">

  export type BoostMetricOrderByWithAggregationInput = {
    id?: SortOrder
    boostId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    _count?: BoostMetricCountOrderByAggregateInput
    _avg?: BoostMetricAvgOrderByAggregateInput
    _max?: BoostMetricMaxOrderByAggregateInput
    _min?: BoostMetricMinOrderByAggregateInput
    _sum?: BoostMetricSumOrderByAggregateInput
  }

  export type BoostMetricScalarWhereWithAggregatesInput = {
    AND?: BoostMetricScalarWhereWithAggregatesInput | BoostMetricScalarWhereWithAggregatesInput[]
    OR?: BoostMetricScalarWhereWithAggregatesInput[]
    NOT?: BoostMetricScalarWhereWithAggregatesInput | BoostMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BoostMetric"> | string
    boostId?: StringWithAggregatesFilter<"BoostMetric"> | string
    date?: DateTimeWithAggregatesFilter<"BoostMetric"> | Date | string
    impressions?: IntWithAggregatesFilter<"BoostMetric"> | number
    clicks?: IntWithAggregatesFilter<"BoostMetric"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    unitType?: StringFilter<"Product"> | string
    sizeMl?: IntNullableFilter<"Product"> | number | null
    upc?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    barProducts?: BarProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitType?: SortOrder
    sizeMl?: SortOrderInput | SortOrder
    upc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    barProducts?: BarProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    upc?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    unitType?: StringFilter<"Product"> | string
    sizeMl?: IntNullableFilter<"Product"> | number | null
    isActive?: BoolFilter<"Product"> | boolean
    barProducts?: BarProductListRelationFilter
  }, "id" | "upc">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitType?: SortOrder
    sizeMl?: SortOrderInput | SortOrder
    upc?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    category?: StringWithAggregatesFilter<"Product"> | string
    unitType?: StringWithAggregatesFilter<"Product"> | string
    sizeMl?: IntNullableWithAggregatesFilter<"Product"> | number | null
    upc?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
  }

  export type BarProductWhereInput = {
    AND?: BarProductWhereInput | BarProductWhereInput[]
    OR?: BarProductWhereInput[]
    NOT?: BarProductWhereInput | BarProductWhereInput[]
    id?: StringFilter<"BarProduct"> | string
    barId?: StringFilter<"BarProduct"> | string
    productId?: StringNullableFilter<"BarProduct"> | string | null
    customName?: StringNullableFilter<"BarProduct"> | string | null
    parLevel?: IntNullableFilter<"BarProduct"> | number | null
    reorderThreshold?: IntNullableFilter<"BarProduct"> | number | null
    preferredVendor?: StringNullableFilter<"BarProduct"> | string | null
    isActive?: BoolFilter<"BarProduct"> | boolean
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    counts?: InventoryCountListRelationFilter
    detections?: InventoryScanDetectionListRelationFilter
  }

  export type BarProductOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrderInput | SortOrder
    customName?: SortOrderInput | SortOrder
    parLevel?: SortOrderInput | SortOrder
    reorderThreshold?: SortOrderInput | SortOrder
    preferredVendor?: SortOrderInput | SortOrder
    isActive?: SortOrder
    bar?: BarOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    counts?: InventoryCountOrderByRelationAggregateInput
    detections?: InventoryScanDetectionOrderByRelationAggregateInput
  }

  export type BarProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BarProductWhereInput | BarProductWhereInput[]
    OR?: BarProductWhereInput[]
    NOT?: BarProductWhereInput | BarProductWhereInput[]
    barId?: StringFilter<"BarProduct"> | string
    productId?: StringNullableFilter<"BarProduct"> | string | null
    customName?: StringNullableFilter<"BarProduct"> | string | null
    parLevel?: IntNullableFilter<"BarProduct"> | number | null
    reorderThreshold?: IntNullableFilter<"BarProduct"> | number | null
    preferredVendor?: StringNullableFilter<"BarProduct"> | string | null
    isActive?: BoolFilter<"BarProduct"> | boolean
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    counts?: InventoryCountListRelationFilter
    detections?: InventoryScanDetectionListRelationFilter
  }, "id">

  export type BarProductOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrderInput | SortOrder
    customName?: SortOrderInput | SortOrder
    parLevel?: SortOrderInput | SortOrder
    reorderThreshold?: SortOrderInput | SortOrder
    preferredVendor?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: BarProductCountOrderByAggregateInput
    _avg?: BarProductAvgOrderByAggregateInput
    _max?: BarProductMaxOrderByAggregateInput
    _min?: BarProductMinOrderByAggregateInput
    _sum?: BarProductSumOrderByAggregateInput
  }

  export type BarProductScalarWhereWithAggregatesInput = {
    AND?: BarProductScalarWhereWithAggregatesInput | BarProductScalarWhereWithAggregatesInput[]
    OR?: BarProductScalarWhereWithAggregatesInput[]
    NOT?: BarProductScalarWhereWithAggregatesInput | BarProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarProduct"> | string
    barId?: StringWithAggregatesFilter<"BarProduct"> | string
    productId?: StringNullableWithAggregatesFilter<"BarProduct"> | string | null
    customName?: StringNullableWithAggregatesFilter<"BarProduct"> | string | null
    parLevel?: IntNullableWithAggregatesFilter<"BarProduct"> | number | null
    reorderThreshold?: IntNullableWithAggregatesFilter<"BarProduct"> | number | null
    preferredVendor?: StringNullableWithAggregatesFilter<"BarProduct"> | string | null
    isActive?: BoolWithAggregatesFilter<"BarProduct"> | boolean
  }

  export type InventoryScanSessionWhereInput = {
    AND?: InventoryScanSessionWhereInput | InventoryScanSessionWhereInput[]
    OR?: InventoryScanSessionWhereInput[]
    NOT?: InventoryScanSessionWhereInput | InventoryScanSessionWhereInput[]
    id?: StringFilter<"InventoryScanSession"> | string
    barId?: StringFilter<"InventoryScanSession"> | string
    createdByUserId?: StringNullableFilter<"InventoryScanSession"> | string | null
    imageUrl?: StringNullableFilter<"InventoryScanSession"> | string | null
    createdAt?: DateTimeFilter<"InventoryScanSession"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    detections?: InventoryScanDetectionListRelationFilter
  }

  export type InventoryScanSessionOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    detections?: InventoryScanDetectionOrderByRelationAggregateInput
  }

  export type InventoryScanSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryScanSessionWhereInput | InventoryScanSessionWhereInput[]
    OR?: InventoryScanSessionWhereInput[]
    NOT?: InventoryScanSessionWhereInput | InventoryScanSessionWhereInput[]
    barId?: StringFilter<"InventoryScanSession"> | string
    createdByUserId?: StringNullableFilter<"InventoryScanSession"> | string | null
    imageUrl?: StringNullableFilter<"InventoryScanSession"> | string | null
    createdAt?: DateTimeFilter<"InventoryScanSession"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    detections?: InventoryScanDetectionListRelationFilter
  }, "id">

  export type InventoryScanSessionOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryScanSessionCountOrderByAggregateInput
    _max?: InventoryScanSessionMaxOrderByAggregateInput
    _min?: InventoryScanSessionMinOrderByAggregateInput
  }

  export type InventoryScanSessionScalarWhereWithAggregatesInput = {
    AND?: InventoryScanSessionScalarWhereWithAggregatesInput | InventoryScanSessionScalarWhereWithAggregatesInput[]
    OR?: InventoryScanSessionScalarWhereWithAggregatesInput[]
    NOT?: InventoryScanSessionScalarWhereWithAggregatesInput | InventoryScanSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryScanSession"> | string
    barId?: StringWithAggregatesFilter<"InventoryScanSession"> | string
    createdByUserId?: StringNullableWithAggregatesFilter<"InventoryScanSession"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"InventoryScanSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryScanSession"> | Date | string
  }

  export type InventoryScanDetectionWhereInput = {
    AND?: InventoryScanDetectionWhereInput | InventoryScanDetectionWhereInput[]
    OR?: InventoryScanDetectionWhereInput[]
    NOT?: InventoryScanDetectionWhereInput | InventoryScanDetectionWhereInput[]
    id?: StringFilter<"InventoryScanDetection"> | string
    sessionId?: StringFilter<"InventoryScanDetection"> | string
    productGuessText?: StringFilter<"InventoryScanDetection"> | string
    productId?: StringNullableFilter<"InventoryScanDetection"> | string | null
    bbox?: JsonNullableFilter<"InventoryScanDetection">
    confidence?: FloatFilter<"InventoryScanDetection"> | number
    remainingBucket?: StringNullableFilter<"InventoryScanDetection"> | string | null
    sizeMlGuess?: IntNullableFilter<"InventoryScanDetection"> | number | null
    session?: XOR<InventoryScanSessionScalarRelationFilter, InventoryScanSessionWhereInput>
    product?: XOR<BarProductNullableScalarRelationFilter, BarProductWhereInput> | null
  }

  export type InventoryScanDetectionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    productGuessText?: SortOrder
    productId?: SortOrderInput | SortOrder
    bbox?: SortOrderInput | SortOrder
    confidence?: SortOrder
    remainingBucket?: SortOrderInput | SortOrder
    sizeMlGuess?: SortOrderInput | SortOrder
    session?: InventoryScanSessionOrderByWithRelationInput
    product?: BarProductOrderByWithRelationInput
  }

  export type InventoryScanDetectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryScanDetectionWhereInput | InventoryScanDetectionWhereInput[]
    OR?: InventoryScanDetectionWhereInput[]
    NOT?: InventoryScanDetectionWhereInput | InventoryScanDetectionWhereInput[]
    sessionId?: StringFilter<"InventoryScanDetection"> | string
    productGuessText?: StringFilter<"InventoryScanDetection"> | string
    productId?: StringNullableFilter<"InventoryScanDetection"> | string | null
    bbox?: JsonNullableFilter<"InventoryScanDetection">
    confidence?: FloatFilter<"InventoryScanDetection"> | number
    remainingBucket?: StringNullableFilter<"InventoryScanDetection"> | string | null
    sizeMlGuess?: IntNullableFilter<"InventoryScanDetection"> | number | null
    session?: XOR<InventoryScanSessionScalarRelationFilter, InventoryScanSessionWhereInput>
    product?: XOR<BarProductNullableScalarRelationFilter, BarProductWhereInput> | null
  }, "id">

  export type InventoryScanDetectionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    productGuessText?: SortOrder
    productId?: SortOrderInput | SortOrder
    bbox?: SortOrderInput | SortOrder
    confidence?: SortOrder
    remainingBucket?: SortOrderInput | SortOrder
    sizeMlGuess?: SortOrderInput | SortOrder
    _count?: InventoryScanDetectionCountOrderByAggregateInput
    _avg?: InventoryScanDetectionAvgOrderByAggregateInput
    _max?: InventoryScanDetectionMaxOrderByAggregateInput
    _min?: InventoryScanDetectionMinOrderByAggregateInput
    _sum?: InventoryScanDetectionSumOrderByAggregateInput
  }

  export type InventoryScanDetectionScalarWhereWithAggregatesInput = {
    AND?: InventoryScanDetectionScalarWhereWithAggregatesInput | InventoryScanDetectionScalarWhereWithAggregatesInput[]
    OR?: InventoryScanDetectionScalarWhereWithAggregatesInput[]
    NOT?: InventoryScanDetectionScalarWhereWithAggregatesInput | InventoryScanDetectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryScanDetection"> | string
    sessionId?: StringWithAggregatesFilter<"InventoryScanDetection"> | string
    productGuessText?: StringWithAggregatesFilter<"InventoryScanDetection"> | string
    productId?: StringNullableWithAggregatesFilter<"InventoryScanDetection"> | string | null
    bbox?: JsonNullableWithAggregatesFilter<"InventoryScanDetection">
    confidence?: FloatWithAggregatesFilter<"InventoryScanDetection"> | number
    remainingBucket?: StringNullableWithAggregatesFilter<"InventoryScanDetection"> | string | null
    sizeMlGuess?: IntNullableWithAggregatesFilter<"InventoryScanDetection"> | number | null
  }

  export type InventoryCountWhereInput = {
    AND?: InventoryCountWhereInput | InventoryCountWhereInput[]
    OR?: InventoryCountWhereInput[]
    NOT?: InventoryCountWhereInput | InventoryCountWhereInput[]
    id?: StringFilter<"InventoryCount"> | string
    barId?: StringFilter<"InventoryCount"> | string
    productId?: StringFilter<"InventoryCount"> | string
    countedAt?: DateTimeFilter<"InventoryCount"> | Date | string
    quantity?: DecimalFilter<"InventoryCount"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"InventoryCount"> | string
    remainingPercent?: IntNullableFilter<"InventoryCount"> | number | null
    remainingBucket?: StringNullableFilter<"InventoryCount"> | string | null
    method?: StringFilter<"InventoryCount"> | string
    confidence?: FloatNullableFilter<"InventoryCount"> | number | null
    notes?: StringNullableFilter<"InventoryCount"> | string | null
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    product?: XOR<BarProductScalarRelationFilter, BarProductWhereInput>
  }

  export type InventoryCountOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    countedAt?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    remainingPercent?: SortOrderInput | SortOrder
    remainingBucket?: SortOrderInput | SortOrder
    method?: SortOrder
    confidence?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    bar?: BarOrderByWithRelationInput
    product?: BarProductOrderByWithRelationInput
  }

  export type InventoryCountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryCountWhereInput | InventoryCountWhereInput[]
    OR?: InventoryCountWhereInput[]
    NOT?: InventoryCountWhereInput | InventoryCountWhereInput[]
    barId?: StringFilter<"InventoryCount"> | string
    productId?: StringFilter<"InventoryCount"> | string
    countedAt?: DateTimeFilter<"InventoryCount"> | Date | string
    quantity?: DecimalFilter<"InventoryCount"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"InventoryCount"> | string
    remainingPercent?: IntNullableFilter<"InventoryCount"> | number | null
    remainingBucket?: StringNullableFilter<"InventoryCount"> | string | null
    method?: StringFilter<"InventoryCount"> | string
    confidence?: FloatNullableFilter<"InventoryCount"> | number | null
    notes?: StringNullableFilter<"InventoryCount"> | string | null
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
    product?: XOR<BarProductScalarRelationFilter, BarProductWhereInput>
  }, "id">

  export type InventoryCountOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    countedAt?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    remainingPercent?: SortOrderInput | SortOrder
    remainingBucket?: SortOrderInput | SortOrder
    method?: SortOrder
    confidence?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: InventoryCountCountOrderByAggregateInput
    _avg?: InventoryCountAvgOrderByAggregateInput
    _max?: InventoryCountMaxOrderByAggregateInput
    _min?: InventoryCountMinOrderByAggregateInput
    _sum?: InventoryCountSumOrderByAggregateInput
  }

  export type InventoryCountScalarWhereWithAggregatesInput = {
    AND?: InventoryCountScalarWhereWithAggregatesInput | InventoryCountScalarWhereWithAggregatesInput[]
    OR?: InventoryCountScalarWhereWithAggregatesInput[]
    NOT?: InventoryCountScalarWhereWithAggregatesInput | InventoryCountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryCount"> | string
    barId?: StringWithAggregatesFilter<"InventoryCount"> | string
    productId?: StringWithAggregatesFilter<"InventoryCount"> | string
    countedAt?: DateTimeWithAggregatesFilter<"InventoryCount"> | Date | string
    quantity?: DecimalWithAggregatesFilter<"InventoryCount"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"InventoryCount"> | string
    remainingPercent?: IntNullableWithAggregatesFilter<"InventoryCount"> | number | null
    remainingBucket?: StringNullableWithAggregatesFilter<"InventoryCount"> | string | null
    method?: StringWithAggregatesFilter<"InventoryCount"> | string
    confidence?: FloatNullableWithAggregatesFilter<"InventoryCount"> | number | null
    notes?: StringNullableWithAggregatesFilter<"InventoryCount"> | string | null
  }

  export type AdminAuditWhereInput = {
    AND?: AdminAuditWhereInput | AdminAuditWhereInput[]
    OR?: AdminAuditWhereInput[]
    NOT?: AdminAuditWhereInput | AdminAuditWhereInput[]
    id?: StringFilter<"AdminAudit"> | string
    adminEmail?: StringFilter<"AdminAudit"> | string
    action?: StringFilter<"AdminAudit"> | string
    entityType?: StringNullableFilter<"AdminAudit"> | string | null
    entityId?: StringNullableFilter<"AdminAudit"> | string | null
    before?: JsonNullableFilter<"AdminAudit">
    after?: JsonNullableFilter<"AdminAudit">
    createdAt?: DateTimeFilter<"AdminAudit"> | Date | string
  }

  export type AdminAuditOrderByWithRelationInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditWhereInput | AdminAuditWhereInput[]
    OR?: AdminAuditWhereInput[]
    NOT?: AdminAuditWhereInput | AdminAuditWhereInput[]
    adminEmail?: StringFilter<"AdminAudit"> | string
    action?: StringFilter<"AdminAudit"> | string
    entityType?: StringNullableFilter<"AdminAudit"> | string | null
    entityId?: StringNullableFilter<"AdminAudit"> | string | null
    before?: JsonNullableFilter<"AdminAudit">
    after?: JsonNullableFilter<"AdminAudit">
    createdAt?: DateTimeFilter<"AdminAudit"> | Date | string
  }, "id">

  export type AdminAuditOrderByWithAggregationInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditCountOrderByAggregateInput
    _max?: AdminAuditMaxOrderByAggregateInput
    _min?: AdminAuditMinOrderByAggregateInput
  }

  export type AdminAuditScalarWhereWithAggregatesInput = {
    AND?: AdminAuditScalarWhereWithAggregatesInput | AdminAuditScalarWhereWithAggregatesInput[]
    OR?: AdminAuditScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditScalarWhereWithAggregatesInput | AdminAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAudit"> | string
    adminEmail?: StringWithAggregatesFilter<"AdminAudit"> | string
    action?: StringWithAggregatesFilter<"AdminAudit"> | string
    entityType?: StringNullableWithAggregatesFilter<"AdminAudit"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"AdminAudit"> | string | null
    before?: JsonNullableWithAggregatesFilter<"AdminAudit">
    after?: JsonNullableWithAggregatesFilter<"AdminAudit">
    createdAt?: DateTimeWithAggregatesFilter<"AdminAudit"> | Date | string
  }

  export type AdminNoteWhereInput = {
    AND?: AdminNoteWhereInput | AdminNoteWhereInput[]
    OR?: AdminNoteWhereInput[]
    NOT?: AdminNoteWhereInput | AdminNoteWhereInput[]
    id?: StringFilter<"AdminNote"> | string
    adminEmail?: StringFilter<"AdminNote"> | string
    barId?: StringNullableFilter<"AdminNote"> | string | null
    userId?: StringNullableFilter<"AdminNote"> | string | null
    content?: StringFilter<"AdminNote"> | string
    createdAt?: DateTimeFilter<"AdminNote"> | Date | string
    bar?: XOR<BarNullableScalarRelationFilter, BarWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AdminNoteOrderByWithRelationInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    barId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AdminNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminNoteWhereInput | AdminNoteWhereInput[]
    OR?: AdminNoteWhereInput[]
    NOT?: AdminNoteWhereInput | AdminNoteWhereInput[]
    adminEmail?: StringFilter<"AdminNote"> | string
    barId?: StringNullableFilter<"AdminNote"> | string | null
    userId?: StringNullableFilter<"AdminNote"> | string | null
    content?: StringFilter<"AdminNote"> | string
    createdAt?: DateTimeFilter<"AdminNote"> | Date | string
    bar?: XOR<BarNullableScalarRelationFilter, BarWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AdminNoteOrderByWithAggregationInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    barId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AdminNoteCountOrderByAggregateInput
    _max?: AdminNoteMaxOrderByAggregateInput
    _min?: AdminNoteMinOrderByAggregateInput
  }

  export type AdminNoteScalarWhereWithAggregatesInput = {
    AND?: AdminNoteScalarWhereWithAggregatesInput | AdminNoteScalarWhereWithAggregatesInput[]
    OR?: AdminNoteScalarWhereWithAggregatesInput[]
    NOT?: AdminNoteScalarWhereWithAggregatesInput | AdminNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminNote"> | string
    adminEmail?: StringWithAggregatesFilter<"AdminNote"> | string
    barId?: StringNullableWithAggregatesFilter<"AdminNote"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AdminNote"> | string | null
    content?: StringWithAggregatesFilter<"AdminNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminNote"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    barId?: StringNullableFilter<"SupportTicket"> | string | null
    userEmail?: StringFilter<"SupportTicket"> | string
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    subject?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    bar?: XOR<BarNullableScalarRelationFilter, BarWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrderInput | SortOrder
    userEmail?: SortOrder
    userId?: SortOrderInput | SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    message?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    barId?: StringNullableFilter<"SupportTicket"> | string | null
    userEmail?: StringFilter<"SupportTicket"> | string
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    subject?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    bar?: XOR<BarNullableScalarRelationFilter, BarWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrderInput | SortOrder
    userEmail?: SortOrder
    userId?: SortOrderInput | SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    message?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    barId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    userEmail?: StringWithAggregatesFilter<"SupportTicket"> | string
    userId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: StringWithAggregatesFilter<"SupportTicket"> | string
    message?: StringWithAggregatesFilter<"SupportTicket"> | string
    resolution?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type StaticOfferingWhereInput = {
    AND?: StaticOfferingWhereInput | StaticOfferingWhereInput[]
    OR?: StaticOfferingWhereInput[]
    NOT?: StaticOfferingWhereInput | StaticOfferingWhereInput[]
    id?: StringFilter<"StaticOffering"> | string
    barId?: StringFilter<"StaticOffering"> | string
    name?: StringFilter<"StaticOffering"> | string
    icon?: StringFilter<"StaticOffering"> | string
    description?: StringNullableFilter<"StaticOffering"> | string | null
    position?: IntFilter<"StaticOffering"> | number
    createdAt?: DateTimeFilter<"StaticOffering"> | Date | string
    updatedAt?: DateTimeFilter<"StaticOffering"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type StaticOfferingOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type StaticOfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barId_position?: StaticOfferingBarIdPositionCompoundUniqueInput
    AND?: StaticOfferingWhereInput | StaticOfferingWhereInput[]
    OR?: StaticOfferingWhereInput[]
    NOT?: StaticOfferingWhereInput | StaticOfferingWhereInput[]
    barId?: StringFilter<"StaticOffering"> | string
    name?: StringFilter<"StaticOffering"> | string
    icon?: StringFilter<"StaticOffering"> | string
    description?: StringNullableFilter<"StaticOffering"> | string | null
    position?: IntFilter<"StaticOffering"> | number
    createdAt?: DateTimeFilter<"StaticOffering"> | Date | string
    updatedAt?: DateTimeFilter<"StaticOffering"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id" | "barId_position">

  export type StaticOfferingOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaticOfferingCountOrderByAggregateInput
    _avg?: StaticOfferingAvgOrderByAggregateInput
    _max?: StaticOfferingMaxOrderByAggregateInput
    _min?: StaticOfferingMinOrderByAggregateInput
    _sum?: StaticOfferingSumOrderByAggregateInput
  }

  export type StaticOfferingScalarWhereWithAggregatesInput = {
    AND?: StaticOfferingScalarWhereWithAggregatesInput | StaticOfferingScalarWhereWithAggregatesInput[]
    OR?: StaticOfferingScalarWhereWithAggregatesInput[]
    NOT?: StaticOfferingScalarWhereWithAggregatesInput | StaticOfferingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaticOffering"> | string
    barId?: StringWithAggregatesFilter<"StaticOffering"> | string
    name?: StringWithAggregatesFilter<"StaticOffering"> | string
    icon?: StringWithAggregatesFilter<"StaticOffering"> | string
    description?: StringNullableWithAggregatesFilter<"StaticOffering"> | string | null
    position?: IntWithAggregatesFilter<"StaticOffering"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StaticOffering"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaticOffering"> | Date | string
  }

  export type DrinkSpecialWhereInput = {
    AND?: DrinkSpecialWhereInput | DrinkSpecialWhereInput[]
    OR?: DrinkSpecialWhereInput[]
    NOT?: DrinkSpecialWhereInput | DrinkSpecialWhereInput[]
    id?: StringFilter<"DrinkSpecial"> | string
    barId?: StringFilter<"DrinkSpecial"> | string
    name?: StringFilter<"DrinkSpecial"> | string
    description?: StringNullableFilter<"DrinkSpecial"> | string | null
    startTime?: StringFilter<"DrinkSpecial"> | string
    endTime?: StringFilter<"DrinkSpecial"> | string
    daysOfWeek?: IntNullableListFilter<"DrinkSpecial">
    active?: BoolFilter<"DrinkSpecial"> | boolean
    createdAt?: DateTimeFilter<"DrinkSpecial"> | Date | string
    updatedAt?: DateTimeFilter<"DrinkSpecial"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type DrinkSpecialOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    daysOfWeek?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type DrinkSpecialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DrinkSpecialWhereInput | DrinkSpecialWhereInput[]
    OR?: DrinkSpecialWhereInput[]
    NOT?: DrinkSpecialWhereInput | DrinkSpecialWhereInput[]
    barId?: StringFilter<"DrinkSpecial"> | string
    name?: StringFilter<"DrinkSpecial"> | string
    description?: StringNullableFilter<"DrinkSpecial"> | string | null
    startTime?: StringFilter<"DrinkSpecial"> | string
    endTime?: StringFilter<"DrinkSpecial"> | string
    daysOfWeek?: IntNullableListFilter<"DrinkSpecial">
    active?: BoolFilter<"DrinkSpecial"> | boolean
    createdAt?: DateTimeFilter<"DrinkSpecial"> | Date | string
    updatedAt?: DateTimeFilter<"DrinkSpecial"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type DrinkSpecialOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    daysOfWeek?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DrinkSpecialCountOrderByAggregateInput
    _avg?: DrinkSpecialAvgOrderByAggregateInput
    _max?: DrinkSpecialMaxOrderByAggregateInput
    _min?: DrinkSpecialMinOrderByAggregateInput
    _sum?: DrinkSpecialSumOrderByAggregateInput
  }

  export type DrinkSpecialScalarWhereWithAggregatesInput = {
    AND?: DrinkSpecialScalarWhereWithAggregatesInput | DrinkSpecialScalarWhereWithAggregatesInput[]
    OR?: DrinkSpecialScalarWhereWithAggregatesInput[]
    NOT?: DrinkSpecialScalarWhereWithAggregatesInput | DrinkSpecialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DrinkSpecial"> | string
    barId?: StringWithAggregatesFilter<"DrinkSpecial"> | string
    name?: StringWithAggregatesFilter<"DrinkSpecial"> | string
    description?: StringNullableWithAggregatesFilter<"DrinkSpecial"> | string | null
    startTime?: StringWithAggregatesFilter<"DrinkSpecial"> | string
    endTime?: StringWithAggregatesFilter<"DrinkSpecial"> | string
    daysOfWeek?: IntNullableListFilter<"DrinkSpecial">
    active?: BoolWithAggregatesFilter<"DrinkSpecial"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DrinkSpecial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DrinkSpecial"> | Date | string
  }

  export type FoodOfferingWhereInput = {
    AND?: FoodOfferingWhereInput | FoodOfferingWhereInput[]
    OR?: FoodOfferingWhereInput[]
    NOT?: FoodOfferingWhereInput | FoodOfferingWhereInput[]
    id?: StringFilter<"FoodOffering"> | string
    barId?: StringFilter<"FoodOffering"> | string
    name?: StringFilter<"FoodOffering"> | string
    description?: StringNullableFilter<"FoodOffering"> | string | null
    specialDays?: IntNullableListFilter<"FoodOffering">
    isSpecial?: BoolFilter<"FoodOffering"> | boolean
    active?: BoolFilter<"FoodOffering"> | boolean
    createdAt?: DateTimeFilter<"FoodOffering"> | Date | string
    updatedAt?: DateTimeFilter<"FoodOffering"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }

  export type FoodOfferingOrderByWithRelationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    specialDays?: SortOrder
    isSpecial?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bar?: BarOrderByWithRelationInput
  }

  export type FoodOfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FoodOfferingWhereInput | FoodOfferingWhereInput[]
    OR?: FoodOfferingWhereInput[]
    NOT?: FoodOfferingWhereInput | FoodOfferingWhereInput[]
    barId?: StringFilter<"FoodOffering"> | string
    name?: StringFilter<"FoodOffering"> | string
    description?: StringNullableFilter<"FoodOffering"> | string | null
    specialDays?: IntNullableListFilter<"FoodOffering">
    isSpecial?: BoolFilter<"FoodOffering"> | boolean
    active?: BoolFilter<"FoodOffering"> | boolean
    createdAt?: DateTimeFilter<"FoodOffering"> | Date | string
    updatedAt?: DateTimeFilter<"FoodOffering"> | Date | string
    bar?: XOR<BarScalarRelationFilter, BarWhereInput>
  }, "id">

  export type FoodOfferingOrderByWithAggregationInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    specialDays?: SortOrder
    isSpecial?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodOfferingCountOrderByAggregateInput
    _avg?: FoodOfferingAvgOrderByAggregateInput
    _max?: FoodOfferingMaxOrderByAggregateInput
    _min?: FoodOfferingMinOrderByAggregateInput
    _sum?: FoodOfferingSumOrderByAggregateInput
  }

  export type FoodOfferingScalarWhereWithAggregatesInput = {
    AND?: FoodOfferingScalarWhereWithAggregatesInput | FoodOfferingScalarWhereWithAggregatesInput[]
    OR?: FoodOfferingScalarWhereWithAggregatesInput[]
    NOT?: FoodOfferingScalarWhereWithAggregatesInput | FoodOfferingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodOffering"> | string
    barId?: StringWithAggregatesFilter<"FoodOffering"> | string
    name?: StringWithAggregatesFilter<"FoodOffering"> | string
    description?: StringNullableWithAggregatesFilter<"FoodOffering"> | string | null
    specialDays?: IntNullableListFilter<"FoodOffering">
    isSpecial?: BoolWithAggregatesFilter<"FoodOffering"> | boolean
    active?: BoolWithAggregatesFilter<"FoodOffering"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FoodOffering"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodOffering"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarUncheckedCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUncheckedUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
  }

  export type OwnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
  }

  export type OwnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    paypalCustomerId?: string | null
    paypalSubscriptionId?: string | null
    priceId?: string | null
    currentPeriodEnd?: Date | string | null
    trialEndsAt?: Date | string | null
    trialReminderSentAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    ownerId: string
    plan: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    paypalCustomerId?: string | null
    paypalSubscriptionId?: string | null
    priceId?: string | null
    currentPeriodEnd?: Date | string | null
    trialEndsAt?: Date | string | null
    trialReminderSentAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    paypalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    paypalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    ownerId: string
    plan: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    paypalCustomerId?: string | null
    paypalSubscriptionId?: string | null
    priceId?: string | null
    currentPeriodEnd?: Date | string | null
    trialEndsAt?: Date | string | null
    trialReminderSentAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    paypalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    paypalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateManyInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
  }

  export type BarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
  }

  export type BarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
  }

  export type OfferingCreateInput = {
    id?: string
    dayOfWeek: number
    category: string
    customTitle?: string | null
    description?: string | null
    startTime: string
    endTime?: string | null
    recurrence?: $Enums.Recurrence
    startDate?: Date | string | null
    endDate?: Date | string | null
    tags?: OfferingCreatetagsInput | string[]
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    expiresAt?: Date | string | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutOfferingsInput
  }

  export type OfferingUncheckedCreateInput = {
    id?: string
    barId: string
    dayOfWeek: number
    category: string
    customTitle?: string | null
    description?: string | null
    startTime: string
    endTime?: string | null
    recurrence?: $Enums.Recurrence
    startDate?: Date | string | null
    endDate?: Date | string | null
    tags?: OfferingCreatetagsInput | string[]
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    expiresAt?: Date | string | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutOfferingsNestedInput
  }

  export type OfferingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferingCreateManyInput = {
    id?: string
    barId: string
    dayOfWeek: number
    category: string
    customTitle?: string | null
    description?: string | null
    startTime: string
    endTime?: string | null
    recurrence?: $Enums.Recurrence
    startDate?: Date | string | null
    endDate?: Date | string | null
    tags?: OfferingCreatetagsInput | string[]
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    expiresAt?: Date | string | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    startTime: string
    endTime?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    recurrence?: $Enums.Recurrence | null
    tags?: EventCreatetagsInput | string[]
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    autoExpire?: boolean
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    barId: string
    title: string
    description?: string | null
    category?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    startTime: string
    endTime?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    recurrence?: $Enums.Recurrence | null
    tags?: EventCreatetagsInput | string[]
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    autoExpire?: boolean
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    barId: string
    title: string
    description?: string | null
    category?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    startTime: string
    endTime?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    recurrence?: $Enums.Recurrence | null
    tags?: EventCreatetagsInput | string[]
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    autoExpire?: boolean
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    bar: BarCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    barId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    bar?: BarUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    userId: string
    barId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCategoryCreateInput = {
    id?: string
    name: string
    displayName: string
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ActivityCategoryUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ActivityCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCategoryCreateManyInput = {
    id?: string
    name: string
    displayName: string
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ActivityCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestCreateInput = {
    id?: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutCategoryRequestsInput
    owner: OwnerCreateNestedOneWithoutCategoryRequestsInput
  }

  export type CategoryRequestUncheckedCreateInput = {
    id?: string
    barId: string
    ownerId: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
  }

  export type CategoryRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutCategoryRequestsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutCategoryRequestsNestedInput
  }

  export type CategoryRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestCreateManyInput = {
    id?: string
    barId: string
    ownerId: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
  }

  export type CategoryRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerPasswordResetCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPasswordResetsInput
  }

  export type OwnerPasswordResetUncheckedCreateInput = {
    id?: string
    ownerId: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OwnerPasswordResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type OwnerPasswordResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerPasswordResetCreateManyInput = {
    id?: string
    ownerId: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OwnerPasswordResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerPasswordResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    isActive?: boolean
    maxRedemptions?: number | null
    usedCount?: number
    expiresAt?: Date | string | null
    grantPlan?: $Enums.SubscriptionPlan | null
    grantMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: PromoRedemptionCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    isActive?: boolean
    maxRedemptions?: number | null
    usedCount?: number
    expiresAt?: Date | string | null
    grantPlan?: $Enums.SubscriptionPlan | null
    grantMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grantPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    grantMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: PromoRedemptionUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grantPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    grantMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: PromoRedemptionUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    isActive?: boolean
    maxRedemptions?: number | null
    usedCount?: number
    expiresAt?: Date | string | null
    grantPlan?: $Enums.SubscriptionPlan | null
    grantMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grantPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    grantMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grantPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    grantMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionCreateInput = {
    id?: string
    redeemedAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutRedemptionsInput
    owner: OwnerCreateNestedOneWithoutPromoRedemptionsInput
  }

  export type PromoRedemptionUncheckedCreateInput = {
    id?: string
    promoCodeId: string
    ownerId: string
    redeemedAt?: Date | string
  }

  export type PromoRedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutRedemptionsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutPromoRedemptionsNestedInput
  }

  export type PromoRedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionCreateManyInput = {
    id?: string
    promoCodeId: string
    ownerId: string
    redeemedAt?: Date | string
  }

  export type PromoRedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarAnalyticsCreateInput = {
    id?: string
    date: Date | string
    dayOfWeek: number
    profileViews?: number
    profileClicks?: number
    searchAppears?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutAnalyticsInput
  }

  export type BarAnalyticsUncheckedCreateInput = {
    id?: string
    barId: string
    date: Date | string
    dayOfWeek: number
    profileViews?: number
    profileClicks?: number
    searchAppears?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type BarAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarAnalyticsCreateManyInput = {
    id?: string
    barId: string
    date: Date | string
    dayOfWeek: number
    profileViews?: number
    profileClicks?: number
    searchAppears?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateInput = {
    id?: string
    query: string
    location?: string | null
    category?: string | null
    dayOfWeek: number
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryUncheckedCreateInput = {
    id?: string
    query: string
    location?: string | null
    category?: string | null
    dayOfWeek: number
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateManyInput = {
    id?: string
    query: string
    location?: string | null
    category?: string | null
    dayOfWeek: number
    count?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarClickCreateInput = {
    id?: string
    source: string
    query?: string | null
    dayOfWeek: number
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutClicksInput
  }

  export type BarClickUncheckedCreateInput = {
    id?: string
    barId: string
    source: string
    query?: string | null
    dayOfWeek: number
    createdAt?: Date | string
  }

  export type BarClickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutClicksNestedInput
  }

  export type BarClickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarClickCreateManyInput = {
    id?: string
    barId: string
    source: string
    query?: string | null
    dayOfWeek: number
    createdAt?: Date | string
  }

  export type BarClickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarClickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    key: string
    name: string
    description: string
    icon: string
    tier?: $Enums.BadgeTier
    category: $Enums.BadgeCategory
    requirement: string
    color: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    barBadges?: BarBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description: string
    icon: string
    tier?: $Enums.BadgeTier
    category: $Enums.BadgeCategory
    requirement: string
    color: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    barBadges?: BarBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    tier?: EnumBadgeTierFieldUpdateOperationsInput | $Enums.BadgeTier
    category?: EnumBadgeCategoryFieldUpdateOperationsInput | $Enums.BadgeCategory
    requirement?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barBadges?: BarBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    tier?: EnumBadgeTierFieldUpdateOperationsInput | $Enums.BadgeTier
    category?: EnumBadgeCategoryFieldUpdateOperationsInput | $Enums.BadgeCategory
    requirement?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barBadges?: BarBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    key: string
    name: string
    description: string
    icon: string
    tier?: $Enums.BadgeTier
    category: $Enums.BadgeCategory
    requirement: string
    color: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    tier?: EnumBadgeTierFieldUpdateOperationsInput | $Enums.BadgeTier
    category?: EnumBadgeCategoryFieldUpdateOperationsInput | $Enums.BadgeCategory
    requirement?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    tier?: EnumBadgeTierFieldUpdateOperationsInput | $Enums.BadgeTier
    category?: EnumBadgeCategoryFieldUpdateOperationsInput | $Enums.BadgeCategory
    requirement?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarBadgeCreateInput = {
    id?: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bar: BarCreateNestedOneWithoutBadgesInput
    badge: BadgeCreateNestedOneWithoutBarBadgesInput
  }

  export type BarBadgeUncheckedCreateInput = {
    id?: string
    barId: string
    badgeKey: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bar?: BarUpdateOneRequiredWithoutBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutBarBadgesNestedInput
  }

  export type BarBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    badgeKey?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeCreateManyInput = {
    id?: string
    barId: string
    badgeKey: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    badgeKey?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryItemCreateInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryItemsInput
    snapshotItems?: InventorySnapshotItemCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    barId: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshotItems?: InventorySnapshotItemUncheckedCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemUncheckedCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileUncheckedCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryItemsNestedInput
    snapshotItems?: InventorySnapshotItemUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItems?: InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUncheckedUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    barId: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportCreateInput = {
    id?: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryImportsInput
    createdBy?: UserCreateNestedOneWithoutInventoryImportsInput
  }

  export type InventoryImportUncheckedCreateInput = {
    id?: string
    barId: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type InventoryImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryImportsNestedInput
    createdBy?: UserUpdateOneWithoutInventoryImportsNestedInput
  }

  export type InventoryImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportCreateManyInput = {
    id?: string
    barId: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type InventoryImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUsageCreateInput = {
    id?: string
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutShiftUsagesInput
    user?: UserCreateNestedOneWithoutShiftUsagesInput
    items?: ShiftUsageItemCreateNestedManyWithoutShiftUsageInput
  }

  export type ShiftUsageUncheckedCreateInput = {
    id?: string
    barId: string
    userId?: string | null
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    items?: ShiftUsageItemUncheckedCreateNestedManyWithoutShiftUsageInput
  }

  export type ShiftUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutShiftUsagesNestedInput
    user?: UserUpdateOneWithoutShiftUsagesNestedInput
    items?: ShiftUsageItemUpdateManyWithoutShiftUsageNestedInput
  }

  export type ShiftUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShiftUsageItemUncheckedUpdateManyWithoutShiftUsageNestedInput
  }

  export type ShiftUsageCreateManyInput = {
    id?: string
    barId: string
    userId?: string | null
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ShiftUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUsageItemCreateInput = {
    id?: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
    shiftUsage: ShiftUsageCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutShiftUsageItemsInput
  }

  export type ShiftUsageItemUncheckedCreateInput = {
    id?: string
    shiftUsageId: string
    inventoryItemId: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type ShiftUsageItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shiftUsage?: ShiftUsageUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutShiftUsageItemsNestedInput
  }

  export type ShiftUsageItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftUsageId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUsageItemCreateManyInput = {
    id?: string
    shiftUsageId: string
    inventoryItemId: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type ShiftUsageItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUsageItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftUsageId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySnapshotCreateInput = {
    id?: string
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventorySnapshotsInput
    user?: UserCreateNestedOneWithoutInventorySnapshotsInput
    items?: InventorySnapshotItemCreateNestedManyWithoutSnapshotInput
  }

  export type InventorySnapshotUncheckedCreateInput = {
    id?: string
    barId: string
    userId?: string | null
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    items?: InventorySnapshotItemUncheckedCreateNestedManyWithoutSnapshotInput
  }

  export type InventorySnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventorySnapshotsNestedInput
    user?: UserUpdateOneWithoutInventorySnapshotsNestedInput
    items?: InventorySnapshotItemUpdateManyWithoutSnapshotNestedInput
  }

  export type InventorySnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventorySnapshotItemUncheckedUpdateManyWithoutSnapshotNestedInput
  }

  export type InventorySnapshotCreateManyInput = {
    id?: string
    barId: string
    userId?: string | null
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventorySnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventorySnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventorySnapshotItemCreateInput = {
    id?: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    snapshot: InventorySnapshotCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutSnapshotItemsInput
    bottlePhoto?: BottlePhotoCreateNestedOneWithoutSnapshotItemInput
  }

  export type InventorySnapshotItemUncheckedCreateInput = {
    id?: string
    snapshotId: string
    inventoryItemId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    bottlePhoto?: BottlePhotoUncheckedCreateNestedOneWithoutSnapshotItemInput
  }

  export type InventorySnapshotItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: InventorySnapshotUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSnapshotItemsNestedInput
    bottlePhoto?: BottlePhotoUpdateOneWithoutSnapshotItemNestedInput
  }

  export type InventorySnapshotItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bottlePhoto?: BottlePhotoUncheckedUpdateOneWithoutSnapshotItemNestedInput
  }

  export type InventorySnapshotItemCreateManyInput = {
    id?: string
    snapshotId: string
    inventoryItemId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type InventorySnapshotItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySnapshotItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottlePhotoCreateInput = {
    id?: string
    imageUrl: string
    estimatedPct?: Decimal | DecimalJsLike | number | string | null
    estimatedMl?: Decimal | DecimalJsLike | number | string | null
    modelVersion?: string | null
    createdAt?: Date | string
    snapshotItem: InventorySnapshotItemCreateNestedOneWithoutBottlePhotoInput
  }

  export type BottlePhotoUncheckedCreateInput = {
    id?: string
    snapshotItemId: string
    imageUrl: string
    estimatedPct?: Decimal | DecimalJsLike | number | string | null
    estimatedMl?: Decimal | DecimalJsLike | number | string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type BottlePhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    estimatedPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItem?: InventorySnapshotItemUpdateOneRequiredWithoutBottlePhotoNestedInput
  }

  export type BottlePhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotItemId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    estimatedPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BottlePhotoCreateManyInput = {
    id?: string
    snapshotItemId: string
    imageUrl: string
    estimatedPct?: Decimal | DecimalJsLike | number | string | null
    estimatedMl?: Decimal | DecimalJsLike | number | string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type BottlePhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    estimatedPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BottlePhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotItemId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    estimatedPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostingProfileCreateInput = {
    id?: string
    pourSizeOz: Decimal | DecimalJsLike | number | string
    menuPrice: Decimal | DecimalJsLike | number | string
    costPerPour: Decimal | DecimalJsLike | number | string
    marginPct: Decimal | DecimalJsLike | number | string
    profitPerBottle: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    inventoryItem: InventoryItemCreateNestedOneWithoutCostingProfilesInput
  }

  export type CostingProfileUncheckedCreateInput = {
    id?: string
    inventoryItemId: string
    pourSizeOz: Decimal | DecimalJsLike | number | string
    menuPrice: Decimal | DecimalJsLike | number | string
    costPerPour: Decimal | DecimalJsLike | number | string
    marginPct: Decimal | DecimalJsLike | number | string
    profitPerBottle: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostingProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutCostingProfilesNestedInput
  }

  export type CostingProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostingProfileCreateManyInput = {
    id?: string
    inventoryItemId: string
    pourSizeOz: Decimal | DecimalJsLike | number | string
    menuPrice: Decimal | DecimalJsLike | number | string
    costPerPour: Decimal | DecimalJsLike | number | string
    marginPct: Decimal | DecimalJsLike | number | string
    profitPerBottle: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostingProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostingProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutVarianceAlertsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutVarianceAlertsInput
  }

  export type VarianceAlertUncheckedCreateInput = {
    id?: string
    barId: string
    inventoryItemId: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
  }

  export type VarianceAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutVarianceAlertsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutVarianceAlertsNestedInput
  }

  export type VarianceAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertCreateManyInput = {
    id?: string
    barId: string
    inventoryItemId: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
  }

  export type VarianceAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarLicenseCreateInput = {
    id?: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutBarLicensesInput
    owner: OwnerCreateNestedOneWithoutBarLicensesInput
  }

  export type BarLicenseUncheckedCreateInput = {
    id?: string
    barId: string
    ownerId: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarLicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutBarLicensesNestedInput
    owner?: OwnerUpdateOneRequiredWithoutBarLicensesNestedInput
  }

  export type BarLicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarLicenseCreateManyInput = {
    id?: string
    barId: string
    ownerId: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarLicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarLicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitCreateInput = {
    id?: string
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutVisitsInput
    user?: UserCreateNestedOneWithoutVisitsInput
  }

  export type BarVisitUncheckedCreateInput = {
    id?: string
    barId: string
    userId?: string | null
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
  }

  export type BarVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutVisitsNestedInput
    user?: UserUpdateOneWithoutVisitsNestedInput
  }

  export type BarVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitCreateManyInput = {
    id?: string
    barId: string
    userId?: string | null
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
  }

  export type BarVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarMembershipCreateInput = {
    id?: string
    userId: string
    role?: $Enums.BarMemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutMembershipsInput
  }

  export type BarMembershipUncheckedCreateInput = {
    id?: string
    barId: string
    userId: string
    role?: $Enums.BarMemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type BarMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarMembershipCreateManyInput = {
    id?: string
    barId: string
    userId: string
    role?: $Enums.BarMemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatronSearchEventCreateInput = {
    id?: string
    query?: string | null
    category?: string | null
    city?: string | null
    createdAt?: Date | string
    bar?: BarCreateNestedOneWithoutPatronSearchEventsInput
  }

  export type PatronSearchEventUncheckedCreateInput = {
    id?: string
    barId?: string | null
    query?: string | null
    category?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type PatronSearchEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneWithoutPatronSearchEventsNestedInput
  }

  export type PatronSearchEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatronSearchEventCreateManyInput = {
    id?: string
    barId?: string | null
    query?: string | null
    category?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type PatronSearchEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatronSearchEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarActionCreateInput = {
    id?: string
    action: string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutBarActionsInput
  }

  export type BarActionUncheckedCreateInput = {
    id?: string
    barId: string
    action: string
    createdAt?: Date | string
  }

  export type BarActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutBarActionsNestedInput
  }

  export type BarActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarActionCreateManyInput = {
    id?: string
    barId: string
    action: string
    createdAt?: Date | string
  }

  export type BarActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarFollowerCreateInput = {
    id?: string
    patronEmail: string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutFollowersInput
  }

  export type BarFollowerUncheckedCreateInput = {
    id?: string
    barId: string
    patronEmail: string
    createdAt?: Date | string
  }

  export type BarFollowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type BarFollowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarFollowerCreateManyInput = {
    id?: string
    barId: string
    patronEmail: string
    createdAt?: Date | string
  }

  export type BarFollowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarFollowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoostCreateInput = {
    id?: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutBoostsInput
    metrics?: BoostMetricCreateNestedManyWithoutBoostInput
  }

  export type BoostUncheckedCreateInput = {
    id?: string
    barId: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
    metrics?: BoostMetricUncheckedCreateNestedManyWithoutBoostInput
  }

  export type BoostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutBoostsNestedInput
    metrics?: BoostMetricUpdateManyWithoutBoostNestedInput
  }

  export type BoostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: BoostMetricUncheckedUpdateManyWithoutBoostNestedInput
  }

  export type BoostCreateManyInput = {
    id?: string
    barId: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
  }

  export type BoostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoostMetricCreateInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    boost: BoostCreateNestedOneWithoutMetricsInput
  }

  export type BoostMetricUncheckedCreateInput = {
    id?: string
    boostId: string
    date: Date | string
    impressions?: number
    clicks?: number
  }

  export type BoostMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    boost?: BoostUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type BoostMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boostId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type BoostMetricCreateManyInput = {
    id?: string
    boostId: string
    date: Date | string
    impressions?: number
    clicks?: number
  }

  export type BoostMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type BoostMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    boostId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    category: string
    unitType: string
    sizeMl?: number | null
    upc?: string | null
    isActive?: boolean
    barProducts?: BarProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    unitType: string
    sizeMl?: number | null
    upc?: string | null
    isActive?: boolean
    barProducts?: BarProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    sizeMl?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    barProducts?: BarProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    sizeMl?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    barProducts?: BarProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    category: string
    unitType: string
    sizeMl?: number | null
    upc?: string | null
    isActive?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    sizeMl?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    sizeMl?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BarProductCreateInput = {
    id?: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    bar: BarCreateNestedOneWithoutBarProductsInput
    product?: ProductCreateNestedOneWithoutBarProductsInput
    counts?: InventoryCountCreateNestedManyWithoutProductInput
    detections?: InventoryScanDetectionCreateNestedManyWithoutProductInput
  }

  export type BarProductUncheckedCreateInput = {
    id?: string
    barId: string
    productId?: string | null
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    counts?: InventoryCountUncheckedCreateNestedManyWithoutProductInput
    detections?: InventoryScanDetectionUncheckedCreateNestedManyWithoutProductInput
  }

  export type BarProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bar?: BarUpdateOneRequiredWithoutBarProductsNestedInput
    product?: ProductUpdateOneWithoutBarProductsNestedInput
    counts?: InventoryCountUpdateManyWithoutProductNestedInput
    detections?: InventoryScanDetectionUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    counts?: InventoryCountUncheckedUpdateManyWithoutProductNestedInput
    detections?: InventoryScanDetectionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BarProductCreateManyInput = {
    id?: string
    barId: string
    productId?: string | null
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
  }

  export type BarProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BarProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryScanSessionCreateInput = {
    id?: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryScanSessionsInput
    detections?: InventoryScanDetectionCreateNestedManyWithoutSessionInput
  }

  export type InventoryScanSessionUncheckedCreateInput = {
    id?: string
    barId: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    detections?: InventoryScanDetectionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InventoryScanSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryScanSessionsNestedInput
    detections?: InventoryScanDetectionUpdateManyWithoutSessionNestedInput
  }

  export type InventoryScanSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detections?: InventoryScanDetectionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InventoryScanSessionCreateManyInput = {
    id?: string
    barId: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type InventoryScanSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryScanSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryScanDetectionCreateInput = {
    id?: string
    productGuessText: string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
    session: InventoryScanSessionCreateNestedOneWithoutDetectionsInput
    product?: BarProductCreateNestedOneWithoutDetectionsInput
  }

  export type InventoryScanDetectionUncheckedCreateInput = {
    id?: string
    sessionId: string
    productGuessText: string
    productId?: string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
  }

  export type InventoryScanDetectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
    session?: InventoryScanSessionUpdateOneRequiredWithoutDetectionsNestedInput
    product?: BarProductUpdateOneWithoutDetectionsNestedInput
  }

  export type InventoryScanDetectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryScanDetectionCreateManyInput = {
    id?: string
    sessionId: string
    productGuessText: string
    productId?: string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
  }

  export type InventoryScanDetectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryScanDetectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryCountCreateInput = {
    id?: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
    bar: BarCreateNestedOneWithoutInventoryCountsInput
    product: BarProductCreateNestedOneWithoutCountsInput
  }

  export type InventoryCountUncheckedCreateInput = {
    id?: string
    barId: string
    productId: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
  }

  export type InventoryCountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bar?: BarUpdateOneRequiredWithoutInventoryCountsNestedInput
    product?: BarProductUpdateOneRequiredWithoutCountsNestedInput
  }

  export type InventoryCountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCountCreateManyInput = {
    id?: string
    barId: string
    productId: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
  }

  export type InventoryCountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuditCreateInput = {
    id?: string
    adminEmail: string
    action: string
    entityType?: string | null
    entityId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditUncheckedCreateInput = {
    id?: string
    adminEmail: string
    action: string
    entityType?: string | null
    entityId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditCreateManyInput = {
    id?: string
    adminEmail: string
    action: string
    entityType?: string | null
    entityId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteCreateInput = {
    id?: string
    adminEmail: string
    content: string
    createdAt?: Date | string
    bar?: BarCreateNestedOneWithoutAdminNotesInput
    user?: UserCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateInput = {
    id?: string
    adminEmail: string
    barId?: string | null
    userId?: string | null
    content: string
    createdAt?: Date | string
  }

  export type AdminNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneWithoutAdminNotesNestedInput
    user?: UserUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteCreateManyInput = {
    id?: string
    adminEmail: string
    barId?: string | null
    userId?: string | null
    content: string
    createdAt?: Date | string
  }

  export type AdminNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    userEmail: string
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bar?: BarCreateNestedOneWithoutSupportTicketsInput
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    barId?: string | null
    userEmail: string
    userId?: string | null
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneWithoutSupportTicketsNestedInput
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    barId?: string | null
    userEmail: string
    userId?: string | null
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticOfferingCreateInput = {
    id?: string
    name: string
    icon: string
    description?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutStaticOfferingsInput
  }

  export type StaticOfferingUncheckedCreateInput = {
    id?: string
    barId: string
    name: string
    icon: string
    description?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaticOfferingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutStaticOfferingsNestedInput
  }

  export type StaticOfferingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticOfferingCreateManyInput = {
    id?: string
    barId: string
    name: string
    icon: string
    description?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaticOfferingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticOfferingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrinkSpecialCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    daysOfWeek?: DrinkSpecialCreatedaysOfWeekInput | number[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutDrinkSpecialsInput
  }

  export type DrinkSpecialUncheckedCreateInput = {
    id?: string
    barId: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    daysOfWeek?: DrinkSpecialCreatedaysOfWeekInput | number[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrinkSpecialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutDrinkSpecialsNestedInput
  }

  export type DrinkSpecialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrinkSpecialCreateManyInput = {
    id?: string
    barId: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    daysOfWeek?: DrinkSpecialCreatedaysOfWeekInput | number[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrinkSpecialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrinkSpecialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodOfferingCreateInput = {
    id?: string
    name: string
    description?: string | null
    specialDays?: FoodOfferingCreatespecialDaysInput | number[]
    isSpecial?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutFoodOfferingsInput
  }

  export type FoodOfferingUncheckedCreateInput = {
    id?: string
    barId: string
    name: string
    description?: string | null
    specialDays?: FoodOfferingCreatespecialDaysInput | number[]
    isSpecial?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodOfferingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutFoodOfferingsNestedInput
  }

  export type FoodOfferingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodOfferingCreateManyInput = {
    id?: string
    barId: string
    name: string
    description?: string | null
    specialDays?: FoodOfferingCreatespecialDaysInput | number[]
    isSpecial?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodOfferingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodOfferingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type BarVisitListRelationFilter = {
    every?: BarVisitWhereInput
    some?: BarVisitWhereInput
    none?: BarVisitWhereInput
  }

  export type InventoryImportListRelationFilter = {
    every?: InventoryImportWhereInput
    some?: InventoryImportWhereInput
    none?: InventoryImportWhereInput
  }

  export type ShiftUsageListRelationFilter = {
    every?: ShiftUsageWhereInput
    some?: ShiftUsageWhereInput
    none?: ShiftUsageWhereInput
  }

  export type InventorySnapshotListRelationFilter = {
    every?: InventorySnapshotWhereInput
    some?: InventorySnapshotWhereInput
    none?: InventorySnapshotWhereInput
  }

  export type AdminNoteListRelationFilter = {
    every?: AdminNoteWhereInput
    some?: AdminNoteWhereInput
    none?: AdminNoteWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryImportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventorySnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disabled?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disabled?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disabled?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type EnumOwnerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerRole | EnumOwnerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerRoleFilter<$PrismaModel> | $Enums.OwnerRole
  }

  export type BarListRelationFilter = {
    every?: BarWhereInput
    some?: BarWhereInput
    none?: BarWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type BarLicenseListRelationFilter = {
    every?: BarLicenseWhereInput
    some?: BarLicenseWhereInput
    none?: BarLicenseWhereInput
  }

  export type PromoRedemptionListRelationFilter = {
    every?: PromoRedemptionWhereInput
    some?: PromoRedemptionWhereInput
    none?: PromoRedemptionWhereInput
  }

  export type CategoryRequestListRelationFilter = {
    every?: CategoryRequestWhereInput
    some?: CategoryRequestWhereInput
    none?: CategoryRequestWhereInput
  }

  export type OwnerPasswordResetListRelationFilter = {
    every?: OwnerPasswordResetWhereInput
    some?: OwnerPasswordResetWhereInput
    none?: OwnerPasswordResetWhereInput
  }

  export type BarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarLicenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerPasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    allowFreeListings?: SortOrder
    role?: SortOrder
  }

  export type OwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    allowFreeListings?: SortOrder
    role?: SortOrder
  }

  export type OwnerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    allowFreeListings?: SortOrder
    role?: SortOrder
  }

  export type EnumOwnerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerRole | EnumOwnerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerRoleWithAggregatesFilter<$PrismaModel> | $Enums.OwnerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnerRoleFilter<$PrismaModel>
    _max?: NestedEnumOwnerRoleFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type OwnerScalarRelationFilter = {
    is?: OwnerWhereInput
    isNot?: OwnerWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    paypalCustomerId?: SortOrder
    paypalSubscriptionId?: SortOrder
    priceId?: SortOrder
    currentPeriodEnd?: SortOrder
    trialEndsAt?: SortOrder
    trialReminderSentAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    paypalCustomerId?: SortOrder
    paypalSubscriptionId?: SortOrder
    priceId?: SortOrder
    currentPeriodEnd?: SortOrder
    trialEndsAt?: SortOrder
    trialReminderSentAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    paypalCustomerId?: SortOrder
    paypalSubscriptionId?: SortOrder
    priceId?: SortOrder
    currentPeriodEnd?: SortOrder
    trialEndsAt?: SortOrder
    trialReminderSentAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OfferingListRelationFilter = {
    every?: OfferingWhereInput
    some?: OfferingWhereInput
    none?: OfferingWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type BarAnalyticsListRelationFilter = {
    every?: BarAnalyticsWhereInput
    some?: BarAnalyticsWhereInput
    none?: BarAnalyticsWhereInput
  }

  export type BarClickListRelationFilter = {
    every?: BarClickWhereInput
    some?: BarClickWhereInput
    none?: BarClickWhereInput
  }

  export type BarBadgeListRelationFilter = {
    every?: BarBadgeWhereInput
    some?: BarBadgeWhereInput
    none?: BarBadgeWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type VarianceAlertListRelationFilter = {
    every?: VarianceAlertWhereInput
    some?: VarianceAlertWhereInput
    none?: VarianceAlertWhereInput
  }

  export type StaticOfferingListRelationFilter = {
    every?: StaticOfferingWhereInput
    some?: StaticOfferingWhereInput
    none?: StaticOfferingWhereInput
  }

  export type DrinkSpecialListRelationFilter = {
    every?: DrinkSpecialWhereInput
    some?: DrinkSpecialWhereInput
    none?: DrinkSpecialWhereInput
  }

  export type FoodOfferingListRelationFilter = {
    every?: FoodOfferingWhereInput
    some?: FoodOfferingWhereInput
    none?: FoodOfferingWhereInput
  }

  export type BarMembershipListRelationFilter = {
    every?: BarMembershipWhereInput
    some?: BarMembershipWhereInput
    none?: BarMembershipWhereInput
  }

  export type BarFollowerListRelationFilter = {
    every?: BarFollowerWhereInput
    some?: BarFollowerWhereInput
    none?: BarFollowerWhereInput
  }

  export type BoostListRelationFilter = {
    every?: BoostWhereInput
    some?: BoostWhereInput
    none?: BoostWhereInput
  }

  export type BarProductListRelationFilter = {
    every?: BarProductWhereInput
    some?: BarProductWhereInput
    none?: BarProductWhereInput
  }

  export type InventoryScanSessionListRelationFilter = {
    every?: InventoryScanSessionWhereInput
    some?: InventoryScanSessionWhereInput
    none?: InventoryScanSessionWhereInput
  }

  export type InventoryCountListRelationFilter = {
    every?: InventoryCountWhereInput
    some?: InventoryCountWhereInput
    none?: InventoryCountWhereInput
  }

  export type PatronSearchEventListRelationFilter = {
    every?: PatronSearchEventWhereInput
    some?: PatronSearchEventWhereInput
    none?: PatronSearchEventWhereInput
  }

  export type BarActionListRelationFilter = {
    every?: BarActionWhereInput
    some?: BarActionWhereInput
    none?: BarActionWhereInput
  }

  export type OfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarClickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VarianceAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaticOfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DrinkSpecialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodOfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarFollowerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryScanSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatronSearchEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    cityNormalized?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    barType?: SortOrder
    subscriptionTier?: SortOrder
    inventoryAddOnEnabled?: SortOrder
    checkInReward?: SortOrder
    neighborhood?: SortOrder
    neighborhoodNormalized?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    photos?: SortOrder
    hours?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
  }

  export type BarAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
  }

  export type BarMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    cityNormalized?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    barType?: SortOrder
    subscriptionTier?: SortOrder
    inventoryAddOnEnabled?: SortOrder
    checkInReward?: SortOrder
    neighborhood?: SortOrder
    neighborhoodNormalized?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
  }

  export type BarMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    cityNormalized?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    barType?: SortOrder
    subscriptionTier?: SortOrder
    inventoryAddOnEnabled?: SortOrder
    checkInReward?: SortOrder
    neighborhood?: SortOrder
    neighborhoodNormalized?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
  }

  export type BarSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    profileViews?: SortOrder
    searchAppearances?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRecurrenceFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel>
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFilter<$PrismaModel> | $Enums.Recurrence
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BarScalarRelationFilter = {
    is?: BarWhereInput
    isNot?: BarWhereInput
  }

  export type OfferingCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    dayOfWeek?: SortOrder
    category?: SortOrder
    customTitle?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    recurrence?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    tags?: SortOrder
    coverCharge?: SortOrder
    prize?: SortOrder
    ageRestriction?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrder
    newUntil?: SortOrder
    expiresAt?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferingAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    coverCharge?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
  }

  export type OfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    dayOfWeek?: SortOrder
    category?: SortOrder
    customTitle?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    recurrence?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverCharge?: SortOrder
    prize?: SortOrder
    ageRestriction?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrder
    newUntil?: SortOrder
    expiresAt?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferingMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    dayOfWeek?: SortOrder
    category?: SortOrder
    customTitle?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    recurrence?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverCharge?: SortOrder
    prize?: SortOrder
    ageRestriction?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrder
    newUntil?: SortOrder
    expiresAt?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferingSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    coverCharge?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
  }

  export type EnumRecurrenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel>
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceWithAggregatesFilter<$PrismaModel> | $Enums.Recurrence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumRecurrenceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceNullableFilter<$PrismaModel> | $Enums.Recurrence | null
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    recurrence?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrder
    newUntil?: SortOrder
    autoExpire?: SortOrder
    coverCharge?: SortOrder
    prize?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    coverCharge?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    recurrence?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrder
    newUntil?: SortOrder
    autoExpire?: SortOrder
    coverCharge?: SortOrder
    prize?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    recurrence?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    isNew?: SortOrder
    specialExpiresAt?: SortOrder
    newUntil?: SortOrder
    autoExpire?: SortOrder
    coverCharge?: SortOrder
    prize?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    coverCharge?: SortOrder
    ageRestriction?: SortOrder
    clickCount?: SortOrder
  }

  export type EnumRecurrenceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceNullableWithAggregatesFilter<$PrismaModel> | $Enums.Recurrence | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceNullableFilter<$PrismaModel>
  }

  export type FavoriteUserIdBarIdCompoundUniqueInput = {
    userId: string
    barId: string
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    barId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    barId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    barId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityCategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ActivityCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityCategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumCategoryRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryRequestStatus | EnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryRequestStatusFilter<$PrismaModel> | $Enums.CategoryRequestStatus
  }

  export type CategoryRequestCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    requestedByEmail?: SortOrder
    requestedByName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    reviewedByEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    requestedByEmail?: SortOrder
    requestedByName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    reviewedByEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryRequestMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    requestedByEmail?: SortOrder
    requestedByName?: SortOrder
    category?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    reviewedByEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCategoryRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryRequestStatus | EnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.CategoryRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumCategoryRequestStatusFilter<$PrismaModel>
  }

  export type OwnerPasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnerPasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnerPasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSubscriptionPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    maxRedemptions?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrder
    grantPlan?: SortOrder
    grantMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    maxRedemptions?: SortOrder
    usedCount?: SortOrder
    grantMonths?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    maxRedemptions?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrder
    grantPlan?: SortOrder
    grantMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    maxRedemptions?: SortOrder
    usedCount?: SortOrder
    expiresAt?: SortOrder
    grantPlan?: SortOrder
    grantMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    maxRedemptions?: SortOrder
    usedCount?: SortOrder
    grantMonths?: SortOrder
  }

  export type EnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
  }

  export type PromoCodeScalarRelationFilter = {
    is?: PromoCodeWhereInput
    isNot?: PromoCodeWhereInput
  }

  export type PromoRedemptionPromoCodeIdOwnerIdCompoundUniqueInput = {
    promoCodeId: string
    ownerId: string
  }

  export type PromoRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    ownerId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type PromoRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    ownerId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type PromoRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    ownerId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type BarAnalyticsBarIdDateCompoundUniqueInput = {
    barId: string
    date: Date | string
  }

  export type BarAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarAnalyticsAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
  }

  export type BarAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarAnalyticsSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    profileViews?: SortOrder
    profileClicks?: SortOrder
    searchAppears?: SortOrder
  }

  export type SearchQueryQueryLocationCategoryCompoundUniqueInput = {
    query: string
    location: string
    category: string
  }

  export type SearchQueryCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    location?: SortOrder
    category?: SortOrder
    dayOfWeek?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQueryAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    count?: SortOrder
  }

  export type SearchQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    location?: SortOrder
    category?: SortOrder
    dayOfWeek?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQueryMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    location?: SortOrder
    category?: SortOrder
    dayOfWeek?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQuerySumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    count?: SortOrder
  }

  export type BarClickCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    source?: SortOrder
    query?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
  }

  export type BarClickAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BarClickMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    source?: SortOrder
    query?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
  }

  export type BarClickMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    source?: SortOrder
    query?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
  }

  export type BarClickSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type EnumBadgeTierFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeTier | EnumBadgeTierFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTierFilter<$PrismaModel> | $Enums.BadgeTier
  }

  export type EnumBadgeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeCategory | EnumBadgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeCategoryFilter<$PrismaModel> | $Enums.BadgeCategory
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    tier?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    tier?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    tier?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumBadgeTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeTier | EnumBadgeTierFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTierWithAggregatesFilter<$PrismaModel> | $Enums.BadgeTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeTierFilter<$PrismaModel>
    _max?: NestedEnumBadgeTierFilter<$PrismaModel>
  }

  export type EnumBadgeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeCategory | EnumBadgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BadgeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeCategoryFilter<$PrismaModel>
    _max?: NestedEnumBadgeCategoryFilter<$PrismaModel>
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type BarBadgeBarIdBadgeKeyCompoundUniqueInput = {
    barId: string
    badgeKey: string
  }

  export type BarBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    badgeKey?: SortOrder
    awardedAt?: SortOrder
    progress?: SortOrder
    metadata?: SortOrder
  }

  export type BarBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    badgeKey?: SortOrder
    awardedAt?: SortOrder
  }

  export type BarBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    badgeKey?: SortOrder
    awardedAt?: SortOrder
  }

  export type InventorySnapshotItemListRelationFilter = {
    every?: InventorySnapshotItemWhereInput
    some?: InventorySnapshotItemWhereInput
    none?: InventorySnapshotItemWhereInput
  }

  export type ShiftUsageItemListRelationFilter = {
    every?: ShiftUsageItemWhereInput
    some?: ShiftUsageItemWhereInput
    none?: ShiftUsageItemWhereInput
  }

  export type CostingProfileListRelationFilter = {
    every?: CostingProfileWhereInput
    some?: CostingProfileWhereInput
    none?: CostingProfileWhereInput
  }

  export type InventorySnapshotItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftUsageItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostingProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    bottleSizeMl?: SortOrder
    startingQtyBottles?: SortOrder
    costPerBottle?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InventoryImportCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    fileName?: SortOrder
    rowsImported?: SortOrder
    mapping?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryImportAvgOrderByAggregateInput = {
    rowsImported?: SortOrder
  }

  export type InventoryImportMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    fileName?: SortOrder
    rowsImported?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryImportMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    fileName?: SortOrder
    rowsImported?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryImportSumOrderByAggregateInput = {
    rowsImported?: SortOrder
  }

  export type ShiftUsageCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    shiftTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    shiftTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftUsageMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    shiftTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ShiftUsageScalarRelationFilter = {
    is?: ShiftUsageWhereInput
    isNot?: ShiftUsageWhereInput
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type ShiftUsageItemCountOrderByAggregateInput = {
    id?: SortOrder
    shiftUsageId?: SortOrder
    inventoryItemId?: SortOrder
    quantityUsed?: SortOrder
    notes?: SortOrder
  }

  export type ShiftUsageItemAvgOrderByAggregateInput = {
    quantityUsed?: SortOrder
  }

  export type ShiftUsageItemMaxOrderByAggregateInput = {
    id?: SortOrder
    shiftUsageId?: SortOrder
    inventoryItemId?: SortOrder
    quantityUsed?: SortOrder
    notes?: SortOrder
  }

  export type ShiftUsageItemMinOrderByAggregateInput = {
    id?: SortOrder
    shiftUsageId?: SortOrder
    inventoryItemId?: SortOrder
    quantityUsed?: SortOrder
    notes?: SortOrder
  }

  export type ShiftUsageItemSumOrderByAggregateInput = {
    quantityUsed?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type InventorySnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    snapshotDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventorySnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    snapshotDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventorySnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    snapshotDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventorySnapshotScalarRelationFilter = {
    is?: InventorySnapshotWhereInput
    isNot?: InventorySnapshotWhereInput
  }

  export type BottlePhotoNullableScalarRelationFilter = {
    is?: BottlePhotoWhereInput | null
    isNot?: BottlePhotoWhereInput | null
  }

  export type InventorySnapshotItemCountOrderByAggregateInput = {
    id?: SortOrder
    snapshotId?: SortOrder
    inventoryItemId?: SortOrder
    quantityOnHand?: SortOrder
    notes?: SortOrder
  }

  export type InventorySnapshotItemAvgOrderByAggregateInput = {
    quantityOnHand?: SortOrder
  }

  export type InventorySnapshotItemMaxOrderByAggregateInput = {
    id?: SortOrder
    snapshotId?: SortOrder
    inventoryItemId?: SortOrder
    quantityOnHand?: SortOrder
    notes?: SortOrder
  }

  export type InventorySnapshotItemMinOrderByAggregateInput = {
    id?: SortOrder
    snapshotId?: SortOrder
    inventoryItemId?: SortOrder
    quantityOnHand?: SortOrder
    notes?: SortOrder
  }

  export type InventorySnapshotItemSumOrderByAggregateInput = {
    quantityOnHand?: SortOrder
  }

  export type InventorySnapshotItemScalarRelationFilter = {
    is?: InventorySnapshotItemWhereInput
    isNot?: InventorySnapshotItemWhereInput
  }

  export type BottlePhotoCountOrderByAggregateInput = {
    id?: SortOrder
    snapshotItemId?: SortOrder
    imageUrl?: SortOrder
    estimatedPct?: SortOrder
    estimatedMl?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type BottlePhotoAvgOrderByAggregateInput = {
    estimatedPct?: SortOrder
    estimatedMl?: SortOrder
  }

  export type BottlePhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    snapshotItemId?: SortOrder
    imageUrl?: SortOrder
    estimatedPct?: SortOrder
    estimatedMl?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type BottlePhotoMinOrderByAggregateInput = {
    id?: SortOrder
    snapshotItemId?: SortOrder
    imageUrl?: SortOrder
    estimatedPct?: SortOrder
    estimatedMl?: SortOrder
    modelVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type BottlePhotoSumOrderByAggregateInput = {
    estimatedPct?: SortOrder
    estimatedMl?: SortOrder
  }

  export type CostingProfileCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryItemId?: SortOrder
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
    createdAt?: SortOrder
  }

  export type CostingProfileAvgOrderByAggregateInput = {
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
  }

  export type CostingProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryItemId?: SortOrder
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
    createdAt?: SortOrder
  }

  export type CostingProfileMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryItemId?: SortOrder
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
    createdAt?: SortOrder
  }

  export type CostingProfileSumOrderByAggregateInput = {
    pourSizeOz?: SortOrder
    menuPrice?: SortOrder
    costPerPour?: SortOrder
    marginPct?: SortOrder
    profitPerBottle?: SortOrder
  }

  export type VarianceAlertCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    inventoryItemId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
    severity?: SortOrder
    reasonHint?: SortOrder
    createdAt?: SortOrder
  }

  export type VarianceAlertAvgOrderByAggregateInput = {
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
  }

  export type VarianceAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    inventoryItemId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
    severity?: SortOrder
    reasonHint?: SortOrder
    createdAt?: SortOrder
  }

  export type VarianceAlertMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    inventoryItemId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
    severity?: SortOrder
    reasonHint?: SortOrder
    createdAt?: SortOrder
  }

  export type VarianceAlertSumOrderByAggregateInput = {
    expectedMl?: SortOrder
    observedMl?: SortOrder
    varianceMl?: SortOrder
    variancePct?: SortOrder
  }

  export type BarLicenseCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarLicenseAvgOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type BarLicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarLicenseMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarLicenseSumOrderByAggregateInput = {
    priceCents?: SortOrder
  }

  export type BarVisitCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    verificationMethod?: SortOrder
    clickId?: SortOrder
    promoCodeId?: SortOrder
    metadata?: SortOrder
    visitedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BarVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    verificationMethod?: SortOrder
    clickId?: SortOrder
    promoCodeId?: SortOrder
    visitedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BarVisitMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    verificationMethod?: SortOrder
    clickId?: SortOrder
    promoCodeId?: SortOrder
    visitedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBarMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.BarMemberRole | EnumBarMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumBarMemberRoleFilter<$PrismaModel> | $Enums.BarMemberRole
  }

  export type BarMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BarMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBarMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BarMemberRole | EnumBarMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumBarMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.BarMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBarMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumBarMemberRoleFilter<$PrismaModel>
  }

  export type BarNullableScalarRelationFilter = {
    is?: BarWhereInput | null
    isNot?: BarWhereInput | null
  }

  export type PatronSearchEventCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    query?: SortOrder
    category?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
  }

  export type PatronSearchEventMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    query?: SortOrder
    category?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
  }

  export type PatronSearchEventMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    query?: SortOrder
    category?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
  }

  export type BarActionCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type BarActionMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type BarActionMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type BarFollowerBarIdPatronEmailCompoundUniqueInput = {
    barId: string
    patronEmail: string
  }

  export type BarFollowerCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    patronEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type BarFollowerMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    patronEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type BarFollowerMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    patronEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type BoostMetricListRelationFilter = {
    every?: BoostMetricWhereInput
    some?: BoostMetricWhereInput
    none?: BoostMetricWhereInput
  }

  export type BoostMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoostCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    eventId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    budgetCents?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BoostAvgOrderByAggregateInput = {
    budgetCents?: SortOrder
  }

  export type BoostMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    eventId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    budgetCents?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BoostMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    eventId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    budgetCents?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BoostSumOrderByAggregateInput = {
    budgetCents?: SortOrder
  }

  export type BoostScalarRelationFilter = {
    is?: BoostWhereInput
    isNot?: BoostWhereInput
  }

  export type BoostMetricBoostIdDateCompoundUniqueInput = {
    boostId: string
    date: Date | string
  }

  export type BoostMetricCountOrderByAggregateInput = {
    id?: SortOrder
    boostId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type BoostMetricAvgOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type BoostMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    boostId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type BoostMetricMinOrderByAggregateInput = {
    id?: SortOrder
    boostId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type BoostMetricSumOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitType?: SortOrder
    sizeMl?: SortOrder
    upc?: SortOrder
    isActive?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    sizeMl?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitType?: SortOrder
    sizeMl?: SortOrder
    upc?: SortOrder
    isActive?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unitType?: SortOrder
    sizeMl?: SortOrder
    upc?: SortOrder
    isActive?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    sizeMl?: SortOrder
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type InventoryScanDetectionListRelationFilter = {
    every?: InventoryScanDetectionWhereInput
    some?: InventoryScanDetectionWhereInput
    none?: InventoryScanDetectionWhereInput
  }

  export type InventoryScanDetectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarProductCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    customName?: SortOrder
    parLevel?: SortOrder
    reorderThreshold?: SortOrder
    preferredVendor?: SortOrder
    isActive?: SortOrder
  }

  export type BarProductAvgOrderByAggregateInput = {
    parLevel?: SortOrder
    reorderThreshold?: SortOrder
  }

  export type BarProductMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    customName?: SortOrder
    parLevel?: SortOrder
    reorderThreshold?: SortOrder
    preferredVendor?: SortOrder
    isActive?: SortOrder
  }

  export type BarProductMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    customName?: SortOrder
    parLevel?: SortOrder
    reorderThreshold?: SortOrder
    preferredVendor?: SortOrder
    isActive?: SortOrder
  }

  export type BarProductSumOrderByAggregateInput = {
    parLevel?: SortOrder
    reorderThreshold?: SortOrder
  }

  export type InventoryScanSessionCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    createdByUserId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryScanSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    createdByUserId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryScanSessionMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    createdByUserId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryScanSessionScalarRelationFilter = {
    is?: InventoryScanSessionWhereInput
    isNot?: InventoryScanSessionWhereInput
  }

  export type BarProductNullableScalarRelationFilter = {
    is?: BarProductWhereInput | null
    isNot?: BarProductWhereInput | null
  }

  export type InventoryScanDetectionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    productGuessText?: SortOrder
    productId?: SortOrder
    bbox?: SortOrder
    confidence?: SortOrder
    remainingBucket?: SortOrder
    sizeMlGuess?: SortOrder
  }

  export type InventoryScanDetectionAvgOrderByAggregateInput = {
    confidence?: SortOrder
    sizeMlGuess?: SortOrder
  }

  export type InventoryScanDetectionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    productGuessText?: SortOrder
    productId?: SortOrder
    confidence?: SortOrder
    remainingBucket?: SortOrder
    sizeMlGuess?: SortOrder
  }

  export type InventoryScanDetectionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    productGuessText?: SortOrder
    productId?: SortOrder
    confidence?: SortOrder
    remainingBucket?: SortOrder
    sizeMlGuess?: SortOrder
  }

  export type InventoryScanDetectionSumOrderByAggregateInput = {
    confidence?: SortOrder
    sizeMlGuess?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BarProductScalarRelationFilter = {
    is?: BarProductWhereInput
    isNot?: BarProductWhereInput
  }

  export type InventoryCountCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    countedAt?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    remainingPercent?: SortOrder
    remainingBucket?: SortOrder
    method?: SortOrder
    confidence?: SortOrder
    notes?: SortOrder
  }

  export type InventoryCountAvgOrderByAggregateInput = {
    quantity?: SortOrder
    remainingPercent?: SortOrder
    confidence?: SortOrder
  }

  export type InventoryCountMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    countedAt?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    remainingPercent?: SortOrder
    remainingBucket?: SortOrder
    method?: SortOrder
    confidence?: SortOrder
    notes?: SortOrder
  }

  export type InventoryCountMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    productId?: SortOrder
    countedAt?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    remainingPercent?: SortOrder
    remainingBucket?: SortOrder
    method?: SortOrder
    confidence?: SortOrder
    notes?: SortOrder
  }

  export type InventoryCountSumOrderByAggregateInput = {
    quantity?: SortOrder
    remainingPercent?: SortOrder
    confidence?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AdminAuditCountOrderByAggregateInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditMinOrderByAggregateInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminNoteCountOrderByAggregateInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminNoteMinOrderByAggregateInput = {
    id?: SortOrder
    adminEmail?: SortOrder
    barId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userEmail?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    message?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userEmail?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    message?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    userEmail?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    message?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaticOfferingBarIdPositionCompoundUniqueInput = {
    barId: string
    position: number
  }

  export type StaticOfferingCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaticOfferingAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type StaticOfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaticOfferingMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaticOfferingSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DrinkSpecialCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    daysOfWeek?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DrinkSpecialAvgOrderByAggregateInput = {
    daysOfWeek?: SortOrder
  }

  export type DrinkSpecialMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DrinkSpecialMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DrinkSpecialSumOrderByAggregateInput = {
    daysOfWeek?: SortOrder
  }

  export type FoodOfferingCountOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    specialDays?: SortOrder
    isSpecial?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodOfferingAvgOrderByAggregateInput = {
    specialDays?: SortOrder
  }

  export type FoodOfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSpecial?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodOfferingMinOrderByAggregateInput = {
    id?: SortOrder
    barId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSpecial?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodOfferingSumOrderByAggregateInput = {
    specialDays?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type BarVisitCreateNestedManyWithoutUserInput = {
    create?: XOR<BarVisitCreateWithoutUserInput, BarVisitUncheckedCreateWithoutUserInput> | BarVisitCreateWithoutUserInput[] | BarVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutUserInput | BarVisitCreateOrConnectWithoutUserInput[]
    createMany?: BarVisitCreateManyUserInputEnvelope
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
  }

  export type InventoryImportCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryImportCreateWithoutCreatedByInput, InventoryImportUncheckedCreateWithoutCreatedByInput> | InventoryImportCreateWithoutCreatedByInput[] | InventoryImportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutCreatedByInput | InventoryImportCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryImportCreateManyCreatedByInputEnvelope
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
  }

  export type ShiftUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftUsageCreateWithoutUserInput, ShiftUsageUncheckedCreateWithoutUserInput> | ShiftUsageCreateWithoutUserInput[] | ShiftUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutUserInput | ShiftUsageCreateOrConnectWithoutUserInput[]
    createMany?: ShiftUsageCreateManyUserInputEnvelope
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
  }

  export type InventorySnapshotCreateNestedManyWithoutUserInput = {
    create?: XOR<InventorySnapshotCreateWithoutUserInput, InventorySnapshotUncheckedCreateWithoutUserInput> | InventorySnapshotCreateWithoutUserInput[] | InventorySnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutUserInput | InventorySnapshotCreateOrConnectWithoutUserInput[]
    createMany?: InventorySnapshotCreateManyUserInputEnvelope
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
  }

  export type AdminNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminNoteCreateWithoutUserInput, AdminNoteUncheckedCreateWithoutUserInput> | AdminNoteCreateWithoutUserInput[] | AdminNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutUserInput | AdminNoteCreateOrConnectWithoutUserInput[]
    createMany?: AdminNoteCreateManyUserInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type BarVisitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BarVisitCreateWithoutUserInput, BarVisitUncheckedCreateWithoutUserInput> | BarVisitCreateWithoutUserInput[] | BarVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutUserInput | BarVisitCreateOrConnectWithoutUserInput[]
    createMany?: BarVisitCreateManyUserInputEnvelope
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
  }

  export type InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InventoryImportCreateWithoutCreatedByInput, InventoryImportUncheckedCreateWithoutCreatedByInput> | InventoryImportCreateWithoutCreatedByInput[] | InventoryImportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutCreatedByInput | InventoryImportCreateOrConnectWithoutCreatedByInput[]
    createMany?: InventoryImportCreateManyCreatedByInputEnvelope
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
  }

  export type ShiftUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftUsageCreateWithoutUserInput, ShiftUsageUncheckedCreateWithoutUserInput> | ShiftUsageCreateWithoutUserInput[] | ShiftUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutUserInput | ShiftUsageCreateOrConnectWithoutUserInput[]
    createMany?: ShiftUsageCreateManyUserInputEnvelope
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
  }

  export type InventorySnapshotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventorySnapshotCreateWithoutUserInput, InventorySnapshotUncheckedCreateWithoutUserInput> | InventorySnapshotCreateWithoutUserInput[] | InventorySnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutUserInput | InventorySnapshotCreateOrConnectWithoutUserInput[]
    createMany?: InventorySnapshotCreateManyUserInputEnvelope
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminNoteCreateWithoutUserInput, AdminNoteUncheckedCreateWithoutUserInput> | AdminNoteCreateWithoutUserInput[] | AdminNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutUserInput | AdminNoteCreateOrConnectWithoutUserInput[]
    createMany?: AdminNoteCreateManyUserInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type BarVisitUpdateManyWithoutUserNestedInput = {
    create?: XOR<BarVisitCreateWithoutUserInput, BarVisitUncheckedCreateWithoutUserInput> | BarVisitCreateWithoutUserInput[] | BarVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutUserInput | BarVisitCreateOrConnectWithoutUserInput[]
    upsert?: BarVisitUpsertWithWhereUniqueWithoutUserInput | BarVisitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BarVisitCreateManyUserInputEnvelope
    set?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    disconnect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    delete?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    update?: BarVisitUpdateWithWhereUniqueWithoutUserInput | BarVisitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BarVisitUpdateManyWithWhereWithoutUserInput | BarVisitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BarVisitScalarWhereInput | BarVisitScalarWhereInput[]
  }

  export type InventoryImportUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryImportCreateWithoutCreatedByInput, InventoryImportUncheckedCreateWithoutCreatedByInput> | InventoryImportCreateWithoutCreatedByInput[] | InventoryImportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutCreatedByInput | InventoryImportCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryImportUpsertWithWhereUniqueWithoutCreatedByInput | InventoryImportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryImportCreateManyCreatedByInputEnvelope
    set?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    disconnect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    delete?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    update?: InventoryImportUpdateWithWhereUniqueWithoutCreatedByInput | InventoryImportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryImportUpdateManyWithWhereWithoutCreatedByInput | InventoryImportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryImportScalarWhereInput | InventoryImportScalarWhereInput[]
  }

  export type ShiftUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftUsageCreateWithoutUserInput, ShiftUsageUncheckedCreateWithoutUserInput> | ShiftUsageCreateWithoutUserInput[] | ShiftUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutUserInput | ShiftUsageCreateOrConnectWithoutUserInput[]
    upsert?: ShiftUsageUpsertWithWhereUniqueWithoutUserInput | ShiftUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftUsageCreateManyUserInputEnvelope
    set?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    disconnect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    delete?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    update?: ShiftUsageUpdateWithWhereUniqueWithoutUserInput | ShiftUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftUsageUpdateManyWithWhereWithoutUserInput | ShiftUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftUsageScalarWhereInput | ShiftUsageScalarWhereInput[]
  }

  export type InventorySnapshotUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventorySnapshotCreateWithoutUserInput, InventorySnapshotUncheckedCreateWithoutUserInput> | InventorySnapshotCreateWithoutUserInput[] | InventorySnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutUserInput | InventorySnapshotCreateOrConnectWithoutUserInput[]
    upsert?: InventorySnapshotUpsertWithWhereUniqueWithoutUserInput | InventorySnapshotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventorySnapshotCreateManyUserInputEnvelope
    set?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    disconnect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    delete?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    update?: InventorySnapshotUpdateWithWhereUniqueWithoutUserInput | InventorySnapshotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventorySnapshotUpdateManyWithWhereWithoutUserInput | InventorySnapshotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventorySnapshotScalarWhereInput | InventorySnapshotScalarWhereInput[]
  }

  export type AdminNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminNoteCreateWithoutUserInput, AdminNoteUncheckedCreateWithoutUserInput> | AdminNoteCreateWithoutUserInput[] | AdminNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutUserInput | AdminNoteCreateOrConnectWithoutUserInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutUserInput | AdminNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminNoteCreateManyUserInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutUserInput | AdminNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutUserInput | AdminNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type BarVisitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BarVisitCreateWithoutUserInput, BarVisitUncheckedCreateWithoutUserInput> | BarVisitCreateWithoutUserInput[] | BarVisitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutUserInput | BarVisitCreateOrConnectWithoutUserInput[]
    upsert?: BarVisitUpsertWithWhereUniqueWithoutUserInput | BarVisitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BarVisitCreateManyUserInputEnvelope
    set?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    disconnect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    delete?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    update?: BarVisitUpdateWithWhereUniqueWithoutUserInput | BarVisitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BarVisitUpdateManyWithWhereWithoutUserInput | BarVisitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BarVisitScalarWhereInput | BarVisitScalarWhereInput[]
  }

  export type InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InventoryImportCreateWithoutCreatedByInput, InventoryImportUncheckedCreateWithoutCreatedByInput> | InventoryImportCreateWithoutCreatedByInput[] | InventoryImportUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutCreatedByInput | InventoryImportCreateOrConnectWithoutCreatedByInput[]
    upsert?: InventoryImportUpsertWithWhereUniqueWithoutCreatedByInput | InventoryImportUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InventoryImportCreateManyCreatedByInputEnvelope
    set?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    disconnect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    delete?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    update?: InventoryImportUpdateWithWhereUniqueWithoutCreatedByInput | InventoryImportUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InventoryImportUpdateManyWithWhereWithoutCreatedByInput | InventoryImportUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InventoryImportScalarWhereInput | InventoryImportScalarWhereInput[]
  }

  export type ShiftUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftUsageCreateWithoutUserInput, ShiftUsageUncheckedCreateWithoutUserInput> | ShiftUsageCreateWithoutUserInput[] | ShiftUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutUserInput | ShiftUsageCreateOrConnectWithoutUserInput[]
    upsert?: ShiftUsageUpsertWithWhereUniqueWithoutUserInput | ShiftUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftUsageCreateManyUserInputEnvelope
    set?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    disconnect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    delete?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    update?: ShiftUsageUpdateWithWhereUniqueWithoutUserInput | ShiftUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftUsageUpdateManyWithWhereWithoutUserInput | ShiftUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftUsageScalarWhereInput | ShiftUsageScalarWhereInput[]
  }

  export type InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventorySnapshotCreateWithoutUserInput, InventorySnapshotUncheckedCreateWithoutUserInput> | InventorySnapshotCreateWithoutUserInput[] | InventorySnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutUserInput | InventorySnapshotCreateOrConnectWithoutUserInput[]
    upsert?: InventorySnapshotUpsertWithWhereUniqueWithoutUserInput | InventorySnapshotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventorySnapshotCreateManyUserInputEnvelope
    set?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    disconnect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    delete?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    update?: InventorySnapshotUpdateWithWhereUniqueWithoutUserInput | InventorySnapshotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventorySnapshotUpdateManyWithWhereWithoutUserInput | InventorySnapshotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventorySnapshotScalarWhereInput | InventorySnapshotScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminNoteCreateWithoutUserInput, AdminNoteUncheckedCreateWithoutUserInput> | AdminNoteCreateWithoutUserInput[] | AdminNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutUserInput | AdminNoteCreateOrConnectWithoutUserInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutUserInput | AdminNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminNoteCreateManyUserInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutUserInput | AdminNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutUserInput | AdminNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type BarCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BarCreateWithoutOwnerInput, BarUncheckedCreateWithoutOwnerInput> | BarCreateWithoutOwnerInput[] | BarUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarCreateOrConnectWithoutOwnerInput | BarCreateOrConnectWithoutOwnerInput[]
    createMany?: BarCreateManyOwnerInputEnvelope
    connect?: BarWhereUniqueInput | BarWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutOwnerInput = {
    create?: XOR<SubscriptionCreateWithoutOwnerInput, SubscriptionUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOwnerInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type BarLicenseCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BarLicenseCreateWithoutOwnerInput, BarLicenseUncheckedCreateWithoutOwnerInput> | BarLicenseCreateWithoutOwnerInput[] | BarLicenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutOwnerInput | BarLicenseCreateOrConnectWithoutOwnerInput[]
    createMany?: BarLicenseCreateManyOwnerInputEnvelope
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
  }

  export type PromoRedemptionCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PromoRedemptionCreateWithoutOwnerInput, PromoRedemptionUncheckedCreateWithoutOwnerInput> | PromoRedemptionCreateWithoutOwnerInput[] | PromoRedemptionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutOwnerInput | PromoRedemptionCreateOrConnectWithoutOwnerInput[]
    createMany?: PromoRedemptionCreateManyOwnerInputEnvelope
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
  }

  export type CategoryRequestCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CategoryRequestCreateWithoutOwnerInput, CategoryRequestUncheckedCreateWithoutOwnerInput> | CategoryRequestCreateWithoutOwnerInput[] | CategoryRequestUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutOwnerInput | CategoryRequestCreateOrConnectWithoutOwnerInput[]
    createMany?: CategoryRequestCreateManyOwnerInputEnvelope
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
  }

  export type OwnerPasswordResetCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerPasswordResetCreateWithoutOwnerInput, OwnerPasswordResetUncheckedCreateWithoutOwnerInput> | OwnerPasswordResetCreateWithoutOwnerInput[] | OwnerPasswordResetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerPasswordResetCreateOrConnectWithoutOwnerInput | OwnerPasswordResetCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerPasswordResetCreateManyOwnerInputEnvelope
    connect?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
  }

  export type BarUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BarCreateWithoutOwnerInput, BarUncheckedCreateWithoutOwnerInput> | BarCreateWithoutOwnerInput[] | BarUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarCreateOrConnectWithoutOwnerInput | BarCreateOrConnectWithoutOwnerInput[]
    createMany?: BarCreateManyOwnerInputEnvelope
    connect?: BarWhereUniqueInput | BarWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<SubscriptionCreateWithoutOwnerInput, SubscriptionUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOwnerInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type BarLicenseUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BarLicenseCreateWithoutOwnerInput, BarLicenseUncheckedCreateWithoutOwnerInput> | BarLicenseCreateWithoutOwnerInput[] | BarLicenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutOwnerInput | BarLicenseCreateOrConnectWithoutOwnerInput[]
    createMany?: BarLicenseCreateManyOwnerInputEnvelope
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
  }

  export type PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PromoRedemptionCreateWithoutOwnerInput, PromoRedemptionUncheckedCreateWithoutOwnerInput> | PromoRedemptionCreateWithoutOwnerInput[] | PromoRedemptionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutOwnerInput | PromoRedemptionCreateOrConnectWithoutOwnerInput[]
    createMany?: PromoRedemptionCreateManyOwnerInputEnvelope
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
  }

  export type CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CategoryRequestCreateWithoutOwnerInput, CategoryRequestUncheckedCreateWithoutOwnerInput> | CategoryRequestCreateWithoutOwnerInput[] | CategoryRequestUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutOwnerInput | CategoryRequestCreateOrConnectWithoutOwnerInput[]
    createMany?: CategoryRequestCreateManyOwnerInputEnvelope
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
  }

  export type OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerPasswordResetCreateWithoutOwnerInput, OwnerPasswordResetUncheckedCreateWithoutOwnerInput> | OwnerPasswordResetCreateWithoutOwnerInput[] | OwnerPasswordResetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerPasswordResetCreateOrConnectWithoutOwnerInput | OwnerPasswordResetCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerPasswordResetCreateManyOwnerInputEnvelope
    connect?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
  }

  export type EnumOwnerRoleFieldUpdateOperationsInput = {
    set?: $Enums.OwnerRole
  }

  export type BarUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BarCreateWithoutOwnerInput, BarUncheckedCreateWithoutOwnerInput> | BarCreateWithoutOwnerInput[] | BarUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarCreateOrConnectWithoutOwnerInput | BarCreateOrConnectWithoutOwnerInput[]
    upsert?: BarUpsertWithWhereUniqueWithoutOwnerInput | BarUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BarCreateManyOwnerInputEnvelope
    set?: BarWhereUniqueInput | BarWhereUniqueInput[]
    disconnect?: BarWhereUniqueInput | BarWhereUniqueInput[]
    delete?: BarWhereUniqueInput | BarWhereUniqueInput[]
    connect?: BarWhereUniqueInput | BarWhereUniqueInput[]
    update?: BarUpdateWithWhereUniqueWithoutOwnerInput | BarUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BarUpdateManyWithWhereWithoutOwnerInput | BarUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BarScalarWhereInput | BarScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOwnerInput, SubscriptionUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOwnerInput
    upsert?: SubscriptionUpsertWithoutOwnerInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutOwnerInput, SubscriptionUpdateWithoutOwnerInput>, SubscriptionUncheckedUpdateWithoutOwnerInput>
  }

  export type BarLicenseUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BarLicenseCreateWithoutOwnerInput, BarLicenseUncheckedCreateWithoutOwnerInput> | BarLicenseCreateWithoutOwnerInput[] | BarLicenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutOwnerInput | BarLicenseCreateOrConnectWithoutOwnerInput[]
    upsert?: BarLicenseUpsertWithWhereUniqueWithoutOwnerInput | BarLicenseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BarLicenseCreateManyOwnerInputEnvelope
    set?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    disconnect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    delete?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    update?: BarLicenseUpdateWithWhereUniqueWithoutOwnerInput | BarLicenseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BarLicenseUpdateManyWithWhereWithoutOwnerInput | BarLicenseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BarLicenseScalarWhereInput | BarLicenseScalarWhereInput[]
  }

  export type PromoRedemptionUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PromoRedemptionCreateWithoutOwnerInput, PromoRedemptionUncheckedCreateWithoutOwnerInput> | PromoRedemptionCreateWithoutOwnerInput[] | PromoRedemptionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutOwnerInput | PromoRedemptionCreateOrConnectWithoutOwnerInput[]
    upsert?: PromoRedemptionUpsertWithWhereUniqueWithoutOwnerInput | PromoRedemptionUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PromoRedemptionCreateManyOwnerInputEnvelope
    set?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    disconnect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    delete?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    update?: PromoRedemptionUpdateWithWhereUniqueWithoutOwnerInput | PromoRedemptionUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PromoRedemptionUpdateManyWithWhereWithoutOwnerInput | PromoRedemptionUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PromoRedemptionScalarWhereInput | PromoRedemptionScalarWhereInput[]
  }

  export type CategoryRequestUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CategoryRequestCreateWithoutOwnerInput, CategoryRequestUncheckedCreateWithoutOwnerInput> | CategoryRequestCreateWithoutOwnerInput[] | CategoryRequestUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutOwnerInput | CategoryRequestCreateOrConnectWithoutOwnerInput[]
    upsert?: CategoryRequestUpsertWithWhereUniqueWithoutOwnerInput | CategoryRequestUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CategoryRequestCreateManyOwnerInputEnvelope
    set?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    disconnect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    delete?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    update?: CategoryRequestUpdateWithWhereUniqueWithoutOwnerInput | CategoryRequestUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CategoryRequestUpdateManyWithWhereWithoutOwnerInput | CategoryRequestUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CategoryRequestScalarWhereInput | CategoryRequestScalarWhereInput[]
  }

  export type OwnerPasswordResetUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerPasswordResetCreateWithoutOwnerInput, OwnerPasswordResetUncheckedCreateWithoutOwnerInput> | OwnerPasswordResetCreateWithoutOwnerInput[] | OwnerPasswordResetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerPasswordResetCreateOrConnectWithoutOwnerInput | OwnerPasswordResetCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerPasswordResetUpsertWithWhereUniqueWithoutOwnerInput | OwnerPasswordResetUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerPasswordResetCreateManyOwnerInputEnvelope
    set?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    disconnect?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    delete?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    connect?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    update?: OwnerPasswordResetUpdateWithWhereUniqueWithoutOwnerInput | OwnerPasswordResetUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerPasswordResetUpdateManyWithWhereWithoutOwnerInput | OwnerPasswordResetUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerPasswordResetScalarWhereInput | OwnerPasswordResetScalarWhereInput[]
  }

  export type BarUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BarCreateWithoutOwnerInput, BarUncheckedCreateWithoutOwnerInput> | BarCreateWithoutOwnerInput[] | BarUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarCreateOrConnectWithoutOwnerInput | BarCreateOrConnectWithoutOwnerInput[]
    upsert?: BarUpsertWithWhereUniqueWithoutOwnerInput | BarUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BarCreateManyOwnerInputEnvelope
    set?: BarWhereUniqueInput | BarWhereUniqueInput[]
    disconnect?: BarWhereUniqueInput | BarWhereUniqueInput[]
    delete?: BarWhereUniqueInput | BarWhereUniqueInput[]
    connect?: BarWhereUniqueInput | BarWhereUniqueInput[]
    update?: BarUpdateWithWhereUniqueWithoutOwnerInput | BarUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BarUpdateManyWithWhereWithoutOwnerInput | BarUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BarScalarWhereInput | BarScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutOwnerInput, SubscriptionUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutOwnerInput
    upsert?: SubscriptionUpsertWithoutOwnerInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutOwnerInput, SubscriptionUpdateWithoutOwnerInput>, SubscriptionUncheckedUpdateWithoutOwnerInput>
  }

  export type BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BarLicenseCreateWithoutOwnerInput, BarLicenseUncheckedCreateWithoutOwnerInput> | BarLicenseCreateWithoutOwnerInput[] | BarLicenseUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutOwnerInput | BarLicenseCreateOrConnectWithoutOwnerInput[]
    upsert?: BarLicenseUpsertWithWhereUniqueWithoutOwnerInput | BarLicenseUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BarLicenseCreateManyOwnerInputEnvelope
    set?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    disconnect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    delete?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    update?: BarLicenseUpdateWithWhereUniqueWithoutOwnerInput | BarLicenseUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BarLicenseUpdateManyWithWhereWithoutOwnerInput | BarLicenseUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BarLicenseScalarWhereInput | BarLicenseScalarWhereInput[]
  }

  export type PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PromoRedemptionCreateWithoutOwnerInput, PromoRedemptionUncheckedCreateWithoutOwnerInput> | PromoRedemptionCreateWithoutOwnerInput[] | PromoRedemptionUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutOwnerInput | PromoRedemptionCreateOrConnectWithoutOwnerInput[]
    upsert?: PromoRedemptionUpsertWithWhereUniqueWithoutOwnerInput | PromoRedemptionUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PromoRedemptionCreateManyOwnerInputEnvelope
    set?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    disconnect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    delete?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    update?: PromoRedemptionUpdateWithWhereUniqueWithoutOwnerInput | PromoRedemptionUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PromoRedemptionUpdateManyWithWhereWithoutOwnerInput | PromoRedemptionUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PromoRedemptionScalarWhereInput | PromoRedemptionScalarWhereInput[]
  }

  export type CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CategoryRequestCreateWithoutOwnerInput, CategoryRequestUncheckedCreateWithoutOwnerInput> | CategoryRequestCreateWithoutOwnerInput[] | CategoryRequestUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutOwnerInput | CategoryRequestCreateOrConnectWithoutOwnerInput[]
    upsert?: CategoryRequestUpsertWithWhereUniqueWithoutOwnerInput | CategoryRequestUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CategoryRequestCreateManyOwnerInputEnvelope
    set?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    disconnect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    delete?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    update?: CategoryRequestUpdateWithWhereUniqueWithoutOwnerInput | CategoryRequestUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CategoryRequestUpdateManyWithWhereWithoutOwnerInput | CategoryRequestUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CategoryRequestScalarWhereInput | CategoryRequestScalarWhereInput[]
  }

  export type OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerPasswordResetCreateWithoutOwnerInput, OwnerPasswordResetUncheckedCreateWithoutOwnerInput> | OwnerPasswordResetCreateWithoutOwnerInput[] | OwnerPasswordResetUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerPasswordResetCreateOrConnectWithoutOwnerInput | OwnerPasswordResetCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerPasswordResetUpsertWithWhereUniqueWithoutOwnerInput | OwnerPasswordResetUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerPasswordResetCreateManyOwnerInputEnvelope
    set?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    disconnect?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    delete?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    connect?: OwnerPasswordResetWhereUniqueInput | OwnerPasswordResetWhereUniqueInput[]
    update?: OwnerPasswordResetUpdateWithWhereUniqueWithoutOwnerInput | OwnerPasswordResetUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerPasswordResetUpdateManyWithWhereWithoutOwnerInput | OwnerPasswordResetUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerPasswordResetScalarWhereInput | OwnerPasswordResetScalarWhereInput[]
  }

  export type OwnerCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<OwnerCreateWithoutSubscriptionInput, OwnerUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutSubscriptionInput
    connect?: OwnerWhereUniqueInput
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type OwnerUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<OwnerCreateWithoutSubscriptionInput, OwnerUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutSubscriptionInput
    upsert?: OwnerUpsertWithoutSubscriptionInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutSubscriptionInput, OwnerUpdateWithoutSubscriptionInput>, OwnerUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BarCreatephotosInput = {
    set: string[]
  }

  export type OwnerCreateNestedOneWithoutBarsInput = {
    create?: XOR<OwnerCreateWithoutBarsInput, OwnerUncheckedCreateWithoutBarsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBarsInput
    connect?: OwnerWhereUniqueInput
  }

  export type OfferingCreateNestedManyWithoutBarInput = {
    create?: XOR<OfferingCreateWithoutBarInput, OfferingUncheckedCreateWithoutBarInput> | OfferingCreateWithoutBarInput[] | OfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: OfferingCreateOrConnectWithoutBarInput | OfferingCreateOrConnectWithoutBarInput[]
    createMany?: OfferingCreateManyBarInputEnvelope
    connect?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutBarInput = {
    create?: XOR<EventCreateWithoutBarInput, EventUncheckedCreateWithoutBarInput> | EventCreateWithoutBarInput[] | EventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBarInput | EventCreateOrConnectWithoutBarInput[]
    createMany?: EventCreateManyBarInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutBarInput = {
    create?: XOR<FavoriteCreateWithoutBarInput, FavoriteUncheckedCreateWithoutBarInput> | FavoriteCreateWithoutBarInput[] | FavoriteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutBarInput | FavoriteCreateOrConnectWithoutBarInput[]
    createMany?: FavoriteCreateManyBarInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type BarAnalyticsCreateNestedManyWithoutBarInput = {
    create?: XOR<BarAnalyticsCreateWithoutBarInput, BarAnalyticsUncheckedCreateWithoutBarInput> | BarAnalyticsCreateWithoutBarInput[] | BarAnalyticsUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarAnalyticsCreateOrConnectWithoutBarInput | BarAnalyticsCreateOrConnectWithoutBarInput[]
    createMany?: BarAnalyticsCreateManyBarInputEnvelope
    connect?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
  }

  export type BarClickCreateNestedManyWithoutBarInput = {
    create?: XOR<BarClickCreateWithoutBarInput, BarClickUncheckedCreateWithoutBarInput> | BarClickCreateWithoutBarInput[] | BarClickUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarClickCreateOrConnectWithoutBarInput | BarClickCreateOrConnectWithoutBarInput[]
    createMany?: BarClickCreateManyBarInputEnvelope
    connect?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
  }

  export type BarBadgeCreateNestedManyWithoutBarInput = {
    create?: XOR<BarBadgeCreateWithoutBarInput, BarBadgeUncheckedCreateWithoutBarInput> | BarBadgeCreateWithoutBarInput[] | BarBadgeUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBarInput | BarBadgeCreateOrConnectWithoutBarInput[]
    createMany?: BarBadgeCreateManyBarInputEnvelope
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
  }

  export type BarLicenseCreateNestedManyWithoutBarInput = {
    create?: XOR<BarLicenseCreateWithoutBarInput, BarLicenseUncheckedCreateWithoutBarInput> | BarLicenseCreateWithoutBarInput[] | BarLicenseUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutBarInput | BarLicenseCreateOrConnectWithoutBarInput[]
    createMany?: BarLicenseCreateManyBarInputEnvelope
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
  }

  export type ShiftUsageCreateNestedManyWithoutBarInput = {
    create?: XOR<ShiftUsageCreateWithoutBarInput, ShiftUsageUncheckedCreateWithoutBarInput> | ShiftUsageCreateWithoutBarInput[] | ShiftUsageUncheckedCreateWithoutBarInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutBarInput | ShiftUsageCreateOrConnectWithoutBarInput[]
    createMany?: ShiftUsageCreateManyBarInputEnvelope
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryItemCreateWithoutBarInput, InventoryItemUncheckedCreateWithoutBarInput> | InventoryItemCreateWithoutBarInput[] | InventoryItemUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBarInput | InventoryItemCreateOrConnectWithoutBarInput[]
    createMany?: InventoryItemCreateManyBarInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryImportCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryImportCreateWithoutBarInput, InventoryImportUncheckedCreateWithoutBarInput> | InventoryImportCreateWithoutBarInput[] | InventoryImportUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutBarInput | InventoryImportCreateOrConnectWithoutBarInput[]
    createMany?: InventoryImportCreateManyBarInputEnvelope
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
  }

  export type InventorySnapshotCreateNestedManyWithoutBarInput = {
    create?: XOR<InventorySnapshotCreateWithoutBarInput, InventorySnapshotUncheckedCreateWithoutBarInput> | InventorySnapshotCreateWithoutBarInput[] | InventorySnapshotUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutBarInput | InventorySnapshotCreateOrConnectWithoutBarInput[]
    createMany?: InventorySnapshotCreateManyBarInputEnvelope
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
  }

  export type BarVisitCreateNestedManyWithoutBarInput = {
    create?: XOR<BarVisitCreateWithoutBarInput, BarVisitUncheckedCreateWithoutBarInput> | BarVisitCreateWithoutBarInput[] | BarVisitUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutBarInput | BarVisitCreateOrConnectWithoutBarInput[]
    createMany?: BarVisitCreateManyBarInputEnvelope
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
  }

  export type VarianceAlertCreateNestedManyWithoutBarInput = {
    create?: XOR<VarianceAlertCreateWithoutBarInput, VarianceAlertUncheckedCreateWithoutBarInput> | VarianceAlertCreateWithoutBarInput[] | VarianceAlertUncheckedCreateWithoutBarInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutBarInput | VarianceAlertCreateOrConnectWithoutBarInput[]
    createMany?: VarianceAlertCreateManyBarInputEnvelope
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
  }

  export type StaticOfferingCreateNestedManyWithoutBarInput = {
    create?: XOR<StaticOfferingCreateWithoutBarInput, StaticOfferingUncheckedCreateWithoutBarInput> | StaticOfferingCreateWithoutBarInput[] | StaticOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: StaticOfferingCreateOrConnectWithoutBarInput | StaticOfferingCreateOrConnectWithoutBarInput[]
    createMany?: StaticOfferingCreateManyBarInputEnvelope
    connect?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
  }

  export type DrinkSpecialCreateNestedManyWithoutBarInput = {
    create?: XOR<DrinkSpecialCreateWithoutBarInput, DrinkSpecialUncheckedCreateWithoutBarInput> | DrinkSpecialCreateWithoutBarInput[] | DrinkSpecialUncheckedCreateWithoutBarInput[]
    connectOrCreate?: DrinkSpecialCreateOrConnectWithoutBarInput | DrinkSpecialCreateOrConnectWithoutBarInput[]
    createMany?: DrinkSpecialCreateManyBarInputEnvelope
    connect?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
  }

  export type FoodOfferingCreateNestedManyWithoutBarInput = {
    create?: XOR<FoodOfferingCreateWithoutBarInput, FoodOfferingUncheckedCreateWithoutBarInput> | FoodOfferingCreateWithoutBarInput[] | FoodOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FoodOfferingCreateOrConnectWithoutBarInput | FoodOfferingCreateOrConnectWithoutBarInput[]
    createMany?: FoodOfferingCreateManyBarInputEnvelope
    connect?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
  }

  export type CategoryRequestCreateNestedManyWithoutBarInput = {
    create?: XOR<CategoryRequestCreateWithoutBarInput, CategoryRequestUncheckedCreateWithoutBarInput> | CategoryRequestCreateWithoutBarInput[] | CategoryRequestUncheckedCreateWithoutBarInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutBarInput | CategoryRequestCreateOrConnectWithoutBarInput[]
    createMany?: CategoryRequestCreateManyBarInputEnvelope
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
  }

  export type BarMembershipCreateNestedManyWithoutBarInput = {
    create?: XOR<BarMembershipCreateWithoutBarInput, BarMembershipUncheckedCreateWithoutBarInput> | BarMembershipCreateWithoutBarInput[] | BarMembershipUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarMembershipCreateOrConnectWithoutBarInput | BarMembershipCreateOrConnectWithoutBarInput[]
    createMany?: BarMembershipCreateManyBarInputEnvelope
    connect?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
  }

  export type BarFollowerCreateNestedManyWithoutBarInput = {
    create?: XOR<BarFollowerCreateWithoutBarInput, BarFollowerUncheckedCreateWithoutBarInput> | BarFollowerCreateWithoutBarInput[] | BarFollowerUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarFollowerCreateOrConnectWithoutBarInput | BarFollowerCreateOrConnectWithoutBarInput[]
    createMany?: BarFollowerCreateManyBarInputEnvelope
    connect?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
  }

  export type BoostCreateNestedManyWithoutBarInput = {
    create?: XOR<BoostCreateWithoutBarInput, BoostUncheckedCreateWithoutBarInput> | BoostCreateWithoutBarInput[] | BoostUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BoostCreateOrConnectWithoutBarInput | BoostCreateOrConnectWithoutBarInput[]
    createMany?: BoostCreateManyBarInputEnvelope
    connect?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
  }

  export type BarProductCreateNestedManyWithoutBarInput = {
    create?: XOR<BarProductCreateWithoutBarInput, BarProductUncheckedCreateWithoutBarInput> | BarProductCreateWithoutBarInput[] | BarProductUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutBarInput | BarProductCreateOrConnectWithoutBarInput[]
    createMany?: BarProductCreateManyBarInputEnvelope
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
  }

  export type InventoryScanSessionCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryScanSessionCreateWithoutBarInput, InventoryScanSessionUncheckedCreateWithoutBarInput> | InventoryScanSessionCreateWithoutBarInput[] | InventoryScanSessionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryScanSessionCreateOrConnectWithoutBarInput | InventoryScanSessionCreateOrConnectWithoutBarInput[]
    createMany?: InventoryScanSessionCreateManyBarInputEnvelope
    connect?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
  }

  export type InventoryCountCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryCountCreateWithoutBarInput, InventoryCountUncheckedCreateWithoutBarInput> | InventoryCountCreateWithoutBarInput[] | InventoryCountUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutBarInput | InventoryCountCreateOrConnectWithoutBarInput[]
    createMany?: InventoryCountCreateManyBarInputEnvelope
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
  }

  export type PatronSearchEventCreateNestedManyWithoutBarInput = {
    create?: XOR<PatronSearchEventCreateWithoutBarInput, PatronSearchEventUncheckedCreateWithoutBarInput> | PatronSearchEventCreateWithoutBarInput[] | PatronSearchEventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: PatronSearchEventCreateOrConnectWithoutBarInput | PatronSearchEventCreateOrConnectWithoutBarInput[]
    createMany?: PatronSearchEventCreateManyBarInputEnvelope
    connect?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
  }

  export type BarActionCreateNestedManyWithoutBarInput = {
    create?: XOR<BarActionCreateWithoutBarInput, BarActionUncheckedCreateWithoutBarInput> | BarActionCreateWithoutBarInput[] | BarActionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarActionCreateOrConnectWithoutBarInput | BarActionCreateOrConnectWithoutBarInput[]
    createMany?: BarActionCreateManyBarInputEnvelope
    connect?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
  }

  export type AdminNoteCreateNestedManyWithoutBarInput = {
    create?: XOR<AdminNoteCreateWithoutBarInput, AdminNoteUncheckedCreateWithoutBarInput> | AdminNoteCreateWithoutBarInput[] | AdminNoteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBarInput | AdminNoteCreateOrConnectWithoutBarInput[]
    createMany?: AdminNoteCreateManyBarInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutBarInput = {
    create?: XOR<SupportTicketCreateWithoutBarInput, SupportTicketUncheckedCreateWithoutBarInput> | SupportTicketCreateWithoutBarInput[] | SupportTicketUncheckedCreateWithoutBarInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutBarInput | SupportTicketCreateOrConnectWithoutBarInput[]
    createMany?: SupportTicketCreateManyBarInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type OfferingUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<OfferingCreateWithoutBarInput, OfferingUncheckedCreateWithoutBarInput> | OfferingCreateWithoutBarInput[] | OfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: OfferingCreateOrConnectWithoutBarInput | OfferingCreateOrConnectWithoutBarInput[]
    createMany?: OfferingCreateManyBarInputEnvelope
    connect?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<EventCreateWithoutBarInput, EventUncheckedCreateWithoutBarInput> | EventCreateWithoutBarInput[] | EventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBarInput | EventCreateOrConnectWithoutBarInput[]
    createMany?: EventCreateManyBarInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<FavoriteCreateWithoutBarInput, FavoriteUncheckedCreateWithoutBarInput> | FavoriteCreateWithoutBarInput[] | FavoriteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutBarInput | FavoriteCreateOrConnectWithoutBarInput[]
    createMany?: FavoriteCreateManyBarInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type BarAnalyticsUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarAnalyticsCreateWithoutBarInput, BarAnalyticsUncheckedCreateWithoutBarInput> | BarAnalyticsCreateWithoutBarInput[] | BarAnalyticsUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarAnalyticsCreateOrConnectWithoutBarInput | BarAnalyticsCreateOrConnectWithoutBarInput[]
    createMany?: BarAnalyticsCreateManyBarInputEnvelope
    connect?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
  }

  export type BarClickUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarClickCreateWithoutBarInput, BarClickUncheckedCreateWithoutBarInput> | BarClickCreateWithoutBarInput[] | BarClickUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarClickCreateOrConnectWithoutBarInput | BarClickCreateOrConnectWithoutBarInput[]
    createMany?: BarClickCreateManyBarInputEnvelope
    connect?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
  }

  export type BarBadgeUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarBadgeCreateWithoutBarInput, BarBadgeUncheckedCreateWithoutBarInput> | BarBadgeCreateWithoutBarInput[] | BarBadgeUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBarInput | BarBadgeCreateOrConnectWithoutBarInput[]
    createMany?: BarBadgeCreateManyBarInputEnvelope
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
  }

  export type BarLicenseUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarLicenseCreateWithoutBarInput, BarLicenseUncheckedCreateWithoutBarInput> | BarLicenseCreateWithoutBarInput[] | BarLicenseUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutBarInput | BarLicenseCreateOrConnectWithoutBarInput[]
    createMany?: BarLicenseCreateManyBarInputEnvelope
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
  }

  export type ShiftUsageUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<ShiftUsageCreateWithoutBarInput, ShiftUsageUncheckedCreateWithoutBarInput> | ShiftUsageCreateWithoutBarInput[] | ShiftUsageUncheckedCreateWithoutBarInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutBarInput | ShiftUsageCreateOrConnectWithoutBarInput[]
    createMany?: ShiftUsageCreateManyBarInputEnvelope
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryItemCreateWithoutBarInput, InventoryItemUncheckedCreateWithoutBarInput> | InventoryItemCreateWithoutBarInput[] | InventoryItemUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBarInput | InventoryItemCreateOrConnectWithoutBarInput[]
    createMany?: InventoryItemCreateManyBarInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryImportUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryImportCreateWithoutBarInput, InventoryImportUncheckedCreateWithoutBarInput> | InventoryImportCreateWithoutBarInput[] | InventoryImportUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutBarInput | InventoryImportCreateOrConnectWithoutBarInput[]
    createMany?: InventoryImportCreateManyBarInputEnvelope
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
  }

  export type InventorySnapshotUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<InventorySnapshotCreateWithoutBarInput, InventorySnapshotUncheckedCreateWithoutBarInput> | InventorySnapshotCreateWithoutBarInput[] | InventorySnapshotUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutBarInput | InventorySnapshotCreateOrConnectWithoutBarInput[]
    createMany?: InventorySnapshotCreateManyBarInputEnvelope
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
  }

  export type BarVisitUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarVisitCreateWithoutBarInput, BarVisitUncheckedCreateWithoutBarInput> | BarVisitCreateWithoutBarInput[] | BarVisitUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutBarInput | BarVisitCreateOrConnectWithoutBarInput[]
    createMany?: BarVisitCreateManyBarInputEnvelope
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
  }

  export type VarianceAlertUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<VarianceAlertCreateWithoutBarInput, VarianceAlertUncheckedCreateWithoutBarInput> | VarianceAlertCreateWithoutBarInput[] | VarianceAlertUncheckedCreateWithoutBarInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutBarInput | VarianceAlertCreateOrConnectWithoutBarInput[]
    createMany?: VarianceAlertCreateManyBarInputEnvelope
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
  }

  export type StaticOfferingUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<StaticOfferingCreateWithoutBarInput, StaticOfferingUncheckedCreateWithoutBarInput> | StaticOfferingCreateWithoutBarInput[] | StaticOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: StaticOfferingCreateOrConnectWithoutBarInput | StaticOfferingCreateOrConnectWithoutBarInput[]
    createMany?: StaticOfferingCreateManyBarInputEnvelope
    connect?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
  }

  export type DrinkSpecialUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<DrinkSpecialCreateWithoutBarInput, DrinkSpecialUncheckedCreateWithoutBarInput> | DrinkSpecialCreateWithoutBarInput[] | DrinkSpecialUncheckedCreateWithoutBarInput[]
    connectOrCreate?: DrinkSpecialCreateOrConnectWithoutBarInput | DrinkSpecialCreateOrConnectWithoutBarInput[]
    createMany?: DrinkSpecialCreateManyBarInputEnvelope
    connect?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
  }

  export type FoodOfferingUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<FoodOfferingCreateWithoutBarInput, FoodOfferingUncheckedCreateWithoutBarInput> | FoodOfferingCreateWithoutBarInput[] | FoodOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FoodOfferingCreateOrConnectWithoutBarInput | FoodOfferingCreateOrConnectWithoutBarInput[]
    createMany?: FoodOfferingCreateManyBarInputEnvelope
    connect?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
  }

  export type CategoryRequestUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<CategoryRequestCreateWithoutBarInput, CategoryRequestUncheckedCreateWithoutBarInput> | CategoryRequestCreateWithoutBarInput[] | CategoryRequestUncheckedCreateWithoutBarInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutBarInput | CategoryRequestCreateOrConnectWithoutBarInput[]
    createMany?: CategoryRequestCreateManyBarInputEnvelope
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
  }

  export type BarMembershipUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarMembershipCreateWithoutBarInput, BarMembershipUncheckedCreateWithoutBarInput> | BarMembershipCreateWithoutBarInput[] | BarMembershipUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarMembershipCreateOrConnectWithoutBarInput | BarMembershipCreateOrConnectWithoutBarInput[]
    createMany?: BarMembershipCreateManyBarInputEnvelope
    connect?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
  }

  export type BarFollowerUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarFollowerCreateWithoutBarInput, BarFollowerUncheckedCreateWithoutBarInput> | BarFollowerCreateWithoutBarInput[] | BarFollowerUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarFollowerCreateOrConnectWithoutBarInput | BarFollowerCreateOrConnectWithoutBarInput[]
    createMany?: BarFollowerCreateManyBarInputEnvelope
    connect?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
  }

  export type BoostUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BoostCreateWithoutBarInput, BoostUncheckedCreateWithoutBarInput> | BoostCreateWithoutBarInput[] | BoostUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BoostCreateOrConnectWithoutBarInput | BoostCreateOrConnectWithoutBarInput[]
    createMany?: BoostCreateManyBarInputEnvelope
    connect?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
  }

  export type BarProductUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarProductCreateWithoutBarInput, BarProductUncheckedCreateWithoutBarInput> | BarProductCreateWithoutBarInput[] | BarProductUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutBarInput | BarProductCreateOrConnectWithoutBarInput[]
    createMany?: BarProductCreateManyBarInputEnvelope
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
  }

  export type InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryScanSessionCreateWithoutBarInput, InventoryScanSessionUncheckedCreateWithoutBarInput> | InventoryScanSessionCreateWithoutBarInput[] | InventoryScanSessionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryScanSessionCreateOrConnectWithoutBarInput | InventoryScanSessionCreateOrConnectWithoutBarInput[]
    createMany?: InventoryScanSessionCreateManyBarInputEnvelope
    connect?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
  }

  export type InventoryCountUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<InventoryCountCreateWithoutBarInput, InventoryCountUncheckedCreateWithoutBarInput> | InventoryCountCreateWithoutBarInput[] | InventoryCountUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutBarInput | InventoryCountCreateOrConnectWithoutBarInput[]
    createMany?: InventoryCountCreateManyBarInputEnvelope
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
  }

  export type PatronSearchEventUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<PatronSearchEventCreateWithoutBarInput, PatronSearchEventUncheckedCreateWithoutBarInput> | PatronSearchEventCreateWithoutBarInput[] | PatronSearchEventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: PatronSearchEventCreateOrConnectWithoutBarInput | PatronSearchEventCreateOrConnectWithoutBarInput[]
    createMany?: PatronSearchEventCreateManyBarInputEnvelope
    connect?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
  }

  export type BarActionUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<BarActionCreateWithoutBarInput, BarActionUncheckedCreateWithoutBarInput> | BarActionCreateWithoutBarInput[] | BarActionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarActionCreateOrConnectWithoutBarInput | BarActionCreateOrConnectWithoutBarInput[]
    createMany?: BarActionCreateManyBarInputEnvelope
    connect?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<AdminNoteCreateWithoutBarInput, AdminNoteUncheckedCreateWithoutBarInput> | AdminNoteCreateWithoutBarInput[] | AdminNoteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBarInput | AdminNoteCreateOrConnectWithoutBarInput[]
    createMany?: AdminNoteCreateManyBarInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutBarInput = {
    create?: XOR<SupportTicketCreateWithoutBarInput, SupportTicketUncheckedCreateWithoutBarInput> | SupportTicketCreateWithoutBarInput[] | SupportTicketUncheckedCreateWithoutBarInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutBarInput | SupportTicketCreateOrConnectWithoutBarInput[]
    createMany?: SupportTicketCreateManyBarInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BarUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OwnerUpdateOneRequiredWithoutBarsNestedInput = {
    create?: XOR<OwnerCreateWithoutBarsInput, OwnerUncheckedCreateWithoutBarsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBarsInput
    upsert?: OwnerUpsertWithoutBarsInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutBarsInput, OwnerUpdateWithoutBarsInput>, OwnerUncheckedUpdateWithoutBarsInput>
  }

  export type OfferingUpdateManyWithoutBarNestedInput = {
    create?: XOR<OfferingCreateWithoutBarInput, OfferingUncheckedCreateWithoutBarInput> | OfferingCreateWithoutBarInput[] | OfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: OfferingCreateOrConnectWithoutBarInput | OfferingCreateOrConnectWithoutBarInput[]
    upsert?: OfferingUpsertWithWhereUniqueWithoutBarInput | OfferingUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: OfferingCreateManyBarInputEnvelope
    set?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    disconnect?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    delete?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    connect?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    update?: OfferingUpdateWithWhereUniqueWithoutBarInput | OfferingUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: OfferingUpdateManyWithWhereWithoutBarInput | OfferingUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: OfferingScalarWhereInput | OfferingScalarWhereInput[]
  }

  export type EventUpdateManyWithoutBarNestedInput = {
    create?: XOR<EventCreateWithoutBarInput, EventUncheckedCreateWithoutBarInput> | EventCreateWithoutBarInput[] | EventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBarInput | EventCreateOrConnectWithoutBarInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutBarInput | EventUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: EventCreateManyBarInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutBarInput | EventUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: EventUpdateManyWithWhereWithoutBarInput | EventUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutBarNestedInput = {
    create?: XOR<FavoriteCreateWithoutBarInput, FavoriteUncheckedCreateWithoutBarInput> | FavoriteCreateWithoutBarInput[] | FavoriteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutBarInput | FavoriteCreateOrConnectWithoutBarInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutBarInput | FavoriteUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: FavoriteCreateManyBarInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutBarInput | FavoriteUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutBarInput | FavoriteUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type BarAnalyticsUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarAnalyticsCreateWithoutBarInput, BarAnalyticsUncheckedCreateWithoutBarInput> | BarAnalyticsCreateWithoutBarInput[] | BarAnalyticsUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarAnalyticsCreateOrConnectWithoutBarInput | BarAnalyticsCreateOrConnectWithoutBarInput[]
    upsert?: BarAnalyticsUpsertWithWhereUniqueWithoutBarInput | BarAnalyticsUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarAnalyticsCreateManyBarInputEnvelope
    set?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    disconnect?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    delete?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    connect?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    update?: BarAnalyticsUpdateWithWhereUniqueWithoutBarInput | BarAnalyticsUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarAnalyticsUpdateManyWithWhereWithoutBarInput | BarAnalyticsUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarAnalyticsScalarWhereInput | BarAnalyticsScalarWhereInput[]
  }

  export type BarClickUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarClickCreateWithoutBarInput, BarClickUncheckedCreateWithoutBarInput> | BarClickCreateWithoutBarInput[] | BarClickUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarClickCreateOrConnectWithoutBarInput | BarClickCreateOrConnectWithoutBarInput[]
    upsert?: BarClickUpsertWithWhereUniqueWithoutBarInput | BarClickUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarClickCreateManyBarInputEnvelope
    set?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    disconnect?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    delete?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    connect?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    update?: BarClickUpdateWithWhereUniqueWithoutBarInput | BarClickUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarClickUpdateManyWithWhereWithoutBarInput | BarClickUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarClickScalarWhereInput | BarClickScalarWhereInput[]
  }

  export type BarBadgeUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarBadgeCreateWithoutBarInput, BarBadgeUncheckedCreateWithoutBarInput> | BarBadgeCreateWithoutBarInput[] | BarBadgeUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBarInput | BarBadgeCreateOrConnectWithoutBarInput[]
    upsert?: BarBadgeUpsertWithWhereUniqueWithoutBarInput | BarBadgeUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarBadgeCreateManyBarInputEnvelope
    set?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    disconnect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    delete?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    update?: BarBadgeUpdateWithWhereUniqueWithoutBarInput | BarBadgeUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarBadgeUpdateManyWithWhereWithoutBarInput | BarBadgeUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarBadgeScalarWhereInput | BarBadgeScalarWhereInput[]
  }

  export type BarLicenseUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarLicenseCreateWithoutBarInput, BarLicenseUncheckedCreateWithoutBarInput> | BarLicenseCreateWithoutBarInput[] | BarLicenseUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutBarInput | BarLicenseCreateOrConnectWithoutBarInput[]
    upsert?: BarLicenseUpsertWithWhereUniqueWithoutBarInput | BarLicenseUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarLicenseCreateManyBarInputEnvelope
    set?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    disconnect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    delete?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    update?: BarLicenseUpdateWithWhereUniqueWithoutBarInput | BarLicenseUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarLicenseUpdateManyWithWhereWithoutBarInput | BarLicenseUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarLicenseScalarWhereInput | BarLicenseScalarWhereInput[]
  }

  export type ShiftUsageUpdateManyWithoutBarNestedInput = {
    create?: XOR<ShiftUsageCreateWithoutBarInput, ShiftUsageUncheckedCreateWithoutBarInput> | ShiftUsageCreateWithoutBarInput[] | ShiftUsageUncheckedCreateWithoutBarInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutBarInput | ShiftUsageCreateOrConnectWithoutBarInput[]
    upsert?: ShiftUsageUpsertWithWhereUniqueWithoutBarInput | ShiftUsageUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: ShiftUsageCreateManyBarInputEnvelope
    set?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    disconnect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    delete?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    update?: ShiftUsageUpdateWithWhereUniqueWithoutBarInput | ShiftUsageUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: ShiftUsageUpdateManyWithWhereWithoutBarInput | ShiftUsageUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: ShiftUsageScalarWhereInput | ShiftUsageScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBarInput, InventoryItemUncheckedCreateWithoutBarInput> | InventoryItemCreateWithoutBarInput[] | InventoryItemUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBarInput | InventoryItemCreateOrConnectWithoutBarInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBarInput | InventoryItemUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryItemCreateManyBarInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBarInput | InventoryItemUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBarInput | InventoryItemUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryImportUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryImportCreateWithoutBarInput, InventoryImportUncheckedCreateWithoutBarInput> | InventoryImportCreateWithoutBarInput[] | InventoryImportUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutBarInput | InventoryImportCreateOrConnectWithoutBarInput[]
    upsert?: InventoryImportUpsertWithWhereUniqueWithoutBarInput | InventoryImportUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryImportCreateManyBarInputEnvelope
    set?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    disconnect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    delete?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    update?: InventoryImportUpdateWithWhereUniqueWithoutBarInput | InventoryImportUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryImportUpdateManyWithWhereWithoutBarInput | InventoryImportUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryImportScalarWhereInput | InventoryImportScalarWhereInput[]
  }

  export type InventorySnapshotUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventorySnapshotCreateWithoutBarInput, InventorySnapshotUncheckedCreateWithoutBarInput> | InventorySnapshotCreateWithoutBarInput[] | InventorySnapshotUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutBarInput | InventorySnapshotCreateOrConnectWithoutBarInput[]
    upsert?: InventorySnapshotUpsertWithWhereUniqueWithoutBarInput | InventorySnapshotUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventorySnapshotCreateManyBarInputEnvelope
    set?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    disconnect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    delete?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    update?: InventorySnapshotUpdateWithWhereUniqueWithoutBarInput | InventorySnapshotUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventorySnapshotUpdateManyWithWhereWithoutBarInput | InventorySnapshotUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventorySnapshotScalarWhereInput | InventorySnapshotScalarWhereInput[]
  }

  export type BarVisitUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarVisitCreateWithoutBarInput, BarVisitUncheckedCreateWithoutBarInput> | BarVisitCreateWithoutBarInput[] | BarVisitUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutBarInput | BarVisitCreateOrConnectWithoutBarInput[]
    upsert?: BarVisitUpsertWithWhereUniqueWithoutBarInput | BarVisitUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarVisitCreateManyBarInputEnvelope
    set?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    disconnect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    delete?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    update?: BarVisitUpdateWithWhereUniqueWithoutBarInput | BarVisitUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarVisitUpdateManyWithWhereWithoutBarInput | BarVisitUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarVisitScalarWhereInput | BarVisitScalarWhereInput[]
  }

  export type VarianceAlertUpdateManyWithoutBarNestedInput = {
    create?: XOR<VarianceAlertCreateWithoutBarInput, VarianceAlertUncheckedCreateWithoutBarInput> | VarianceAlertCreateWithoutBarInput[] | VarianceAlertUncheckedCreateWithoutBarInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutBarInput | VarianceAlertCreateOrConnectWithoutBarInput[]
    upsert?: VarianceAlertUpsertWithWhereUniqueWithoutBarInput | VarianceAlertUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: VarianceAlertCreateManyBarInputEnvelope
    set?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    disconnect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    delete?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    update?: VarianceAlertUpdateWithWhereUniqueWithoutBarInput | VarianceAlertUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: VarianceAlertUpdateManyWithWhereWithoutBarInput | VarianceAlertUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: VarianceAlertScalarWhereInput | VarianceAlertScalarWhereInput[]
  }

  export type StaticOfferingUpdateManyWithoutBarNestedInput = {
    create?: XOR<StaticOfferingCreateWithoutBarInput, StaticOfferingUncheckedCreateWithoutBarInput> | StaticOfferingCreateWithoutBarInput[] | StaticOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: StaticOfferingCreateOrConnectWithoutBarInput | StaticOfferingCreateOrConnectWithoutBarInput[]
    upsert?: StaticOfferingUpsertWithWhereUniqueWithoutBarInput | StaticOfferingUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: StaticOfferingCreateManyBarInputEnvelope
    set?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    disconnect?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    delete?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    connect?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    update?: StaticOfferingUpdateWithWhereUniqueWithoutBarInput | StaticOfferingUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: StaticOfferingUpdateManyWithWhereWithoutBarInput | StaticOfferingUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: StaticOfferingScalarWhereInput | StaticOfferingScalarWhereInput[]
  }

  export type DrinkSpecialUpdateManyWithoutBarNestedInput = {
    create?: XOR<DrinkSpecialCreateWithoutBarInput, DrinkSpecialUncheckedCreateWithoutBarInput> | DrinkSpecialCreateWithoutBarInput[] | DrinkSpecialUncheckedCreateWithoutBarInput[]
    connectOrCreate?: DrinkSpecialCreateOrConnectWithoutBarInput | DrinkSpecialCreateOrConnectWithoutBarInput[]
    upsert?: DrinkSpecialUpsertWithWhereUniqueWithoutBarInput | DrinkSpecialUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: DrinkSpecialCreateManyBarInputEnvelope
    set?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    disconnect?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    delete?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    connect?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    update?: DrinkSpecialUpdateWithWhereUniqueWithoutBarInput | DrinkSpecialUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: DrinkSpecialUpdateManyWithWhereWithoutBarInput | DrinkSpecialUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: DrinkSpecialScalarWhereInput | DrinkSpecialScalarWhereInput[]
  }

  export type FoodOfferingUpdateManyWithoutBarNestedInput = {
    create?: XOR<FoodOfferingCreateWithoutBarInput, FoodOfferingUncheckedCreateWithoutBarInput> | FoodOfferingCreateWithoutBarInput[] | FoodOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FoodOfferingCreateOrConnectWithoutBarInput | FoodOfferingCreateOrConnectWithoutBarInput[]
    upsert?: FoodOfferingUpsertWithWhereUniqueWithoutBarInput | FoodOfferingUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: FoodOfferingCreateManyBarInputEnvelope
    set?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    disconnect?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    delete?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    connect?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    update?: FoodOfferingUpdateWithWhereUniqueWithoutBarInput | FoodOfferingUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: FoodOfferingUpdateManyWithWhereWithoutBarInput | FoodOfferingUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: FoodOfferingScalarWhereInput | FoodOfferingScalarWhereInput[]
  }

  export type CategoryRequestUpdateManyWithoutBarNestedInput = {
    create?: XOR<CategoryRequestCreateWithoutBarInput, CategoryRequestUncheckedCreateWithoutBarInput> | CategoryRequestCreateWithoutBarInput[] | CategoryRequestUncheckedCreateWithoutBarInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutBarInput | CategoryRequestCreateOrConnectWithoutBarInput[]
    upsert?: CategoryRequestUpsertWithWhereUniqueWithoutBarInput | CategoryRequestUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: CategoryRequestCreateManyBarInputEnvelope
    set?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    disconnect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    delete?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    update?: CategoryRequestUpdateWithWhereUniqueWithoutBarInput | CategoryRequestUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: CategoryRequestUpdateManyWithWhereWithoutBarInput | CategoryRequestUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: CategoryRequestScalarWhereInput | CategoryRequestScalarWhereInput[]
  }

  export type BarMembershipUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarMembershipCreateWithoutBarInput, BarMembershipUncheckedCreateWithoutBarInput> | BarMembershipCreateWithoutBarInput[] | BarMembershipUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarMembershipCreateOrConnectWithoutBarInput | BarMembershipCreateOrConnectWithoutBarInput[]
    upsert?: BarMembershipUpsertWithWhereUniqueWithoutBarInput | BarMembershipUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarMembershipCreateManyBarInputEnvelope
    set?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    disconnect?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    delete?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    connect?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    update?: BarMembershipUpdateWithWhereUniqueWithoutBarInput | BarMembershipUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarMembershipUpdateManyWithWhereWithoutBarInput | BarMembershipUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarMembershipScalarWhereInput | BarMembershipScalarWhereInput[]
  }

  export type BarFollowerUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarFollowerCreateWithoutBarInput, BarFollowerUncheckedCreateWithoutBarInput> | BarFollowerCreateWithoutBarInput[] | BarFollowerUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarFollowerCreateOrConnectWithoutBarInput | BarFollowerCreateOrConnectWithoutBarInput[]
    upsert?: BarFollowerUpsertWithWhereUniqueWithoutBarInput | BarFollowerUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarFollowerCreateManyBarInputEnvelope
    set?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    disconnect?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    delete?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    connect?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    update?: BarFollowerUpdateWithWhereUniqueWithoutBarInput | BarFollowerUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarFollowerUpdateManyWithWhereWithoutBarInput | BarFollowerUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarFollowerScalarWhereInput | BarFollowerScalarWhereInput[]
  }

  export type BoostUpdateManyWithoutBarNestedInput = {
    create?: XOR<BoostCreateWithoutBarInput, BoostUncheckedCreateWithoutBarInput> | BoostCreateWithoutBarInput[] | BoostUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BoostCreateOrConnectWithoutBarInput | BoostCreateOrConnectWithoutBarInput[]
    upsert?: BoostUpsertWithWhereUniqueWithoutBarInput | BoostUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BoostCreateManyBarInputEnvelope
    set?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    disconnect?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    delete?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    connect?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    update?: BoostUpdateWithWhereUniqueWithoutBarInput | BoostUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BoostUpdateManyWithWhereWithoutBarInput | BoostUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BoostScalarWhereInput | BoostScalarWhereInput[]
  }

  export type BarProductUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarProductCreateWithoutBarInput, BarProductUncheckedCreateWithoutBarInput> | BarProductCreateWithoutBarInput[] | BarProductUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutBarInput | BarProductCreateOrConnectWithoutBarInput[]
    upsert?: BarProductUpsertWithWhereUniqueWithoutBarInput | BarProductUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarProductCreateManyBarInputEnvelope
    set?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    disconnect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    delete?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    update?: BarProductUpdateWithWhereUniqueWithoutBarInput | BarProductUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarProductUpdateManyWithWhereWithoutBarInput | BarProductUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarProductScalarWhereInput | BarProductScalarWhereInput[]
  }

  export type InventoryScanSessionUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryScanSessionCreateWithoutBarInput, InventoryScanSessionUncheckedCreateWithoutBarInput> | InventoryScanSessionCreateWithoutBarInput[] | InventoryScanSessionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryScanSessionCreateOrConnectWithoutBarInput | InventoryScanSessionCreateOrConnectWithoutBarInput[]
    upsert?: InventoryScanSessionUpsertWithWhereUniqueWithoutBarInput | InventoryScanSessionUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryScanSessionCreateManyBarInputEnvelope
    set?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    disconnect?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    delete?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    connect?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    update?: InventoryScanSessionUpdateWithWhereUniqueWithoutBarInput | InventoryScanSessionUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryScanSessionUpdateManyWithWhereWithoutBarInput | InventoryScanSessionUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryScanSessionScalarWhereInput | InventoryScanSessionScalarWhereInput[]
  }

  export type InventoryCountUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryCountCreateWithoutBarInput, InventoryCountUncheckedCreateWithoutBarInput> | InventoryCountCreateWithoutBarInput[] | InventoryCountUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutBarInput | InventoryCountCreateOrConnectWithoutBarInput[]
    upsert?: InventoryCountUpsertWithWhereUniqueWithoutBarInput | InventoryCountUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryCountCreateManyBarInputEnvelope
    set?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    disconnect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    delete?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    update?: InventoryCountUpdateWithWhereUniqueWithoutBarInput | InventoryCountUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryCountUpdateManyWithWhereWithoutBarInput | InventoryCountUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryCountScalarWhereInput | InventoryCountScalarWhereInput[]
  }

  export type PatronSearchEventUpdateManyWithoutBarNestedInput = {
    create?: XOR<PatronSearchEventCreateWithoutBarInput, PatronSearchEventUncheckedCreateWithoutBarInput> | PatronSearchEventCreateWithoutBarInput[] | PatronSearchEventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: PatronSearchEventCreateOrConnectWithoutBarInput | PatronSearchEventCreateOrConnectWithoutBarInput[]
    upsert?: PatronSearchEventUpsertWithWhereUniqueWithoutBarInput | PatronSearchEventUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: PatronSearchEventCreateManyBarInputEnvelope
    set?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    disconnect?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    delete?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    connect?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    update?: PatronSearchEventUpdateWithWhereUniqueWithoutBarInput | PatronSearchEventUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: PatronSearchEventUpdateManyWithWhereWithoutBarInput | PatronSearchEventUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: PatronSearchEventScalarWhereInput | PatronSearchEventScalarWhereInput[]
  }

  export type BarActionUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarActionCreateWithoutBarInput, BarActionUncheckedCreateWithoutBarInput> | BarActionCreateWithoutBarInput[] | BarActionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarActionCreateOrConnectWithoutBarInput | BarActionCreateOrConnectWithoutBarInput[]
    upsert?: BarActionUpsertWithWhereUniqueWithoutBarInput | BarActionUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarActionCreateManyBarInputEnvelope
    set?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    disconnect?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    delete?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    connect?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    update?: BarActionUpdateWithWhereUniqueWithoutBarInput | BarActionUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarActionUpdateManyWithWhereWithoutBarInput | BarActionUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarActionScalarWhereInput | BarActionScalarWhereInput[]
  }

  export type AdminNoteUpdateManyWithoutBarNestedInput = {
    create?: XOR<AdminNoteCreateWithoutBarInput, AdminNoteUncheckedCreateWithoutBarInput> | AdminNoteCreateWithoutBarInput[] | AdminNoteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBarInput | AdminNoteCreateOrConnectWithoutBarInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutBarInput | AdminNoteUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: AdminNoteCreateManyBarInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutBarInput | AdminNoteUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutBarInput | AdminNoteUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutBarNestedInput = {
    create?: XOR<SupportTicketCreateWithoutBarInput, SupportTicketUncheckedCreateWithoutBarInput> | SupportTicketCreateWithoutBarInput[] | SupportTicketUncheckedCreateWithoutBarInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutBarInput | SupportTicketCreateOrConnectWithoutBarInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutBarInput | SupportTicketUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: SupportTicketCreateManyBarInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutBarInput | SupportTicketUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutBarInput | SupportTicketUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type OfferingUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<OfferingCreateWithoutBarInput, OfferingUncheckedCreateWithoutBarInput> | OfferingCreateWithoutBarInput[] | OfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: OfferingCreateOrConnectWithoutBarInput | OfferingCreateOrConnectWithoutBarInput[]
    upsert?: OfferingUpsertWithWhereUniqueWithoutBarInput | OfferingUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: OfferingCreateManyBarInputEnvelope
    set?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    disconnect?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    delete?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    connect?: OfferingWhereUniqueInput | OfferingWhereUniqueInput[]
    update?: OfferingUpdateWithWhereUniqueWithoutBarInput | OfferingUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: OfferingUpdateManyWithWhereWithoutBarInput | OfferingUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: OfferingScalarWhereInput | OfferingScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<EventCreateWithoutBarInput, EventUncheckedCreateWithoutBarInput> | EventCreateWithoutBarInput[] | EventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBarInput | EventCreateOrConnectWithoutBarInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutBarInput | EventUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: EventCreateManyBarInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutBarInput | EventUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: EventUpdateManyWithWhereWithoutBarInput | EventUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<FavoriteCreateWithoutBarInput, FavoriteUncheckedCreateWithoutBarInput> | FavoriteCreateWithoutBarInput[] | FavoriteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutBarInput | FavoriteCreateOrConnectWithoutBarInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutBarInput | FavoriteUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: FavoriteCreateManyBarInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutBarInput | FavoriteUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutBarInput | FavoriteUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarAnalyticsCreateWithoutBarInput, BarAnalyticsUncheckedCreateWithoutBarInput> | BarAnalyticsCreateWithoutBarInput[] | BarAnalyticsUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarAnalyticsCreateOrConnectWithoutBarInput | BarAnalyticsCreateOrConnectWithoutBarInput[]
    upsert?: BarAnalyticsUpsertWithWhereUniqueWithoutBarInput | BarAnalyticsUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarAnalyticsCreateManyBarInputEnvelope
    set?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    disconnect?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    delete?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    connect?: BarAnalyticsWhereUniqueInput | BarAnalyticsWhereUniqueInput[]
    update?: BarAnalyticsUpdateWithWhereUniqueWithoutBarInput | BarAnalyticsUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarAnalyticsUpdateManyWithWhereWithoutBarInput | BarAnalyticsUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarAnalyticsScalarWhereInput | BarAnalyticsScalarWhereInput[]
  }

  export type BarClickUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarClickCreateWithoutBarInput, BarClickUncheckedCreateWithoutBarInput> | BarClickCreateWithoutBarInput[] | BarClickUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarClickCreateOrConnectWithoutBarInput | BarClickCreateOrConnectWithoutBarInput[]
    upsert?: BarClickUpsertWithWhereUniqueWithoutBarInput | BarClickUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarClickCreateManyBarInputEnvelope
    set?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    disconnect?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    delete?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    connect?: BarClickWhereUniqueInput | BarClickWhereUniqueInput[]
    update?: BarClickUpdateWithWhereUniqueWithoutBarInput | BarClickUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarClickUpdateManyWithWhereWithoutBarInput | BarClickUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarClickScalarWhereInput | BarClickScalarWhereInput[]
  }

  export type BarBadgeUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarBadgeCreateWithoutBarInput, BarBadgeUncheckedCreateWithoutBarInput> | BarBadgeCreateWithoutBarInput[] | BarBadgeUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBarInput | BarBadgeCreateOrConnectWithoutBarInput[]
    upsert?: BarBadgeUpsertWithWhereUniqueWithoutBarInput | BarBadgeUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarBadgeCreateManyBarInputEnvelope
    set?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    disconnect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    delete?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    update?: BarBadgeUpdateWithWhereUniqueWithoutBarInput | BarBadgeUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarBadgeUpdateManyWithWhereWithoutBarInput | BarBadgeUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarBadgeScalarWhereInput | BarBadgeScalarWhereInput[]
  }

  export type BarLicenseUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarLicenseCreateWithoutBarInput, BarLicenseUncheckedCreateWithoutBarInput> | BarLicenseCreateWithoutBarInput[] | BarLicenseUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarLicenseCreateOrConnectWithoutBarInput | BarLicenseCreateOrConnectWithoutBarInput[]
    upsert?: BarLicenseUpsertWithWhereUniqueWithoutBarInput | BarLicenseUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarLicenseCreateManyBarInputEnvelope
    set?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    disconnect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    delete?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    connect?: BarLicenseWhereUniqueInput | BarLicenseWhereUniqueInput[]
    update?: BarLicenseUpdateWithWhereUniqueWithoutBarInput | BarLicenseUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarLicenseUpdateManyWithWhereWithoutBarInput | BarLicenseUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarLicenseScalarWhereInput | BarLicenseScalarWhereInput[]
  }

  export type ShiftUsageUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<ShiftUsageCreateWithoutBarInput, ShiftUsageUncheckedCreateWithoutBarInput> | ShiftUsageCreateWithoutBarInput[] | ShiftUsageUncheckedCreateWithoutBarInput[]
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutBarInput | ShiftUsageCreateOrConnectWithoutBarInput[]
    upsert?: ShiftUsageUpsertWithWhereUniqueWithoutBarInput | ShiftUsageUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: ShiftUsageCreateManyBarInputEnvelope
    set?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    disconnect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    delete?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    connect?: ShiftUsageWhereUniqueInput | ShiftUsageWhereUniqueInput[]
    update?: ShiftUsageUpdateWithWhereUniqueWithoutBarInput | ShiftUsageUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: ShiftUsageUpdateManyWithWhereWithoutBarInput | ShiftUsageUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: ShiftUsageScalarWhereInput | ShiftUsageScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBarInput, InventoryItemUncheckedCreateWithoutBarInput> | InventoryItemCreateWithoutBarInput[] | InventoryItemUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBarInput | InventoryItemCreateOrConnectWithoutBarInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBarInput | InventoryItemUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryItemCreateManyBarInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBarInput | InventoryItemUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBarInput | InventoryItemUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryImportUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryImportCreateWithoutBarInput, InventoryImportUncheckedCreateWithoutBarInput> | InventoryImportCreateWithoutBarInput[] | InventoryImportUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryImportCreateOrConnectWithoutBarInput | InventoryImportCreateOrConnectWithoutBarInput[]
    upsert?: InventoryImportUpsertWithWhereUniqueWithoutBarInput | InventoryImportUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryImportCreateManyBarInputEnvelope
    set?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    disconnect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    delete?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    connect?: InventoryImportWhereUniqueInput | InventoryImportWhereUniqueInput[]
    update?: InventoryImportUpdateWithWhereUniqueWithoutBarInput | InventoryImportUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryImportUpdateManyWithWhereWithoutBarInput | InventoryImportUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryImportScalarWhereInput | InventoryImportScalarWhereInput[]
  }

  export type InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventorySnapshotCreateWithoutBarInput, InventorySnapshotUncheckedCreateWithoutBarInput> | InventorySnapshotCreateWithoutBarInput[] | InventorySnapshotUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutBarInput | InventorySnapshotCreateOrConnectWithoutBarInput[]
    upsert?: InventorySnapshotUpsertWithWhereUniqueWithoutBarInput | InventorySnapshotUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventorySnapshotCreateManyBarInputEnvelope
    set?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    disconnect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    delete?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    connect?: InventorySnapshotWhereUniqueInput | InventorySnapshotWhereUniqueInput[]
    update?: InventorySnapshotUpdateWithWhereUniqueWithoutBarInput | InventorySnapshotUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventorySnapshotUpdateManyWithWhereWithoutBarInput | InventorySnapshotUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventorySnapshotScalarWhereInput | InventorySnapshotScalarWhereInput[]
  }

  export type BarVisitUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarVisitCreateWithoutBarInput, BarVisitUncheckedCreateWithoutBarInput> | BarVisitCreateWithoutBarInput[] | BarVisitUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarVisitCreateOrConnectWithoutBarInput | BarVisitCreateOrConnectWithoutBarInput[]
    upsert?: BarVisitUpsertWithWhereUniqueWithoutBarInput | BarVisitUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarVisitCreateManyBarInputEnvelope
    set?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    disconnect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    delete?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    connect?: BarVisitWhereUniqueInput | BarVisitWhereUniqueInput[]
    update?: BarVisitUpdateWithWhereUniqueWithoutBarInput | BarVisitUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarVisitUpdateManyWithWhereWithoutBarInput | BarVisitUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarVisitScalarWhereInput | BarVisitScalarWhereInput[]
  }

  export type VarianceAlertUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<VarianceAlertCreateWithoutBarInput, VarianceAlertUncheckedCreateWithoutBarInput> | VarianceAlertCreateWithoutBarInput[] | VarianceAlertUncheckedCreateWithoutBarInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutBarInput | VarianceAlertCreateOrConnectWithoutBarInput[]
    upsert?: VarianceAlertUpsertWithWhereUniqueWithoutBarInput | VarianceAlertUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: VarianceAlertCreateManyBarInputEnvelope
    set?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    disconnect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    delete?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    update?: VarianceAlertUpdateWithWhereUniqueWithoutBarInput | VarianceAlertUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: VarianceAlertUpdateManyWithWhereWithoutBarInput | VarianceAlertUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: VarianceAlertScalarWhereInput | VarianceAlertScalarWhereInput[]
  }

  export type StaticOfferingUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<StaticOfferingCreateWithoutBarInput, StaticOfferingUncheckedCreateWithoutBarInput> | StaticOfferingCreateWithoutBarInput[] | StaticOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: StaticOfferingCreateOrConnectWithoutBarInput | StaticOfferingCreateOrConnectWithoutBarInput[]
    upsert?: StaticOfferingUpsertWithWhereUniqueWithoutBarInput | StaticOfferingUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: StaticOfferingCreateManyBarInputEnvelope
    set?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    disconnect?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    delete?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    connect?: StaticOfferingWhereUniqueInput | StaticOfferingWhereUniqueInput[]
    update?: StaticOfferingUpdateWithWhereUniqueWithoutBarInput | StaticOfferingUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: StaticOfferingUpdateManyWithWhereWithoutBarInput | StaticOfferingUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: StaticOfferingScalarWhereInput | StaticOfferingScalarWhereInput[]
  }

  export type DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<DrinkSpecialCreateWithoutBarInput, DrinkSpecialUncheckedCreateWithoutBarInput> | DrinkSpecialCreateWithoutBarInput[] | DrinkSpecialUncheckedCreateWithoutBarInput[]
    connectOrCreate?: DrinkSpecialCreateOrConnectWithoutBarInput | DrinkSpecialCreateOrConnectWithoutBarInput[]
    upsert?: DrinkSpecialUpsertWithWhereUniqueWithoutBarInput | DrinkSpecialUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: DrinkSpecialCreateManyBarInputEnvelope
    set?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    disconnect?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    delete?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    connect?: DrinkSpecialWhereUniqueInput | DrinkSpecialWhereUniqueInput[]
    update?: DrinkSpecialUpdateWithWhereUniqueWithoutBarInput | DrinkSpecialUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: DrinkSpecialUpdateManyWithWhereWithoutBarInput | DrinkSpecialUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: DrinkSpecialScalarWhereInput | DrinkSpecialScalarWhereInput[]
  }

  export type FoodOfferingUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<FoodOfferingCreateWithoutBarInput, FoodOfferingUncheckedCreateWithoutBarInput> | FoodOfferingCreateWithoutBarInput[] | FoodOfferingUncheckedCreateWithoutBarInput[]
    connectOrCreate?: FoodOfferingCreateOrConnectWithoutBarInput | FoodOfferingCreateOrConnectWithoutBarInput[]
    upsert?: FoodOfferingUpsertWithWhereUniqueWithoutBarInput | FoodOfferingUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: FoodOfferingCreateManyBarInputEnvelope
    set?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    disconnect?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    delete?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    connect?: FoodOfferingWhereUniqueInput | FoodOfferingWhereUniqueInput[]
    update?: FoodOfferingUpdateWithWhereUniqueWithoutBarInput | FoodOfferingUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: FoodOfferingUpdateManyWithWhereWithoutBarInput | FoodOfferingUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: FoodOfferingScalarWhereInput | FoodOfferingScalarWhereInput[]
  }

  export type CategoryRequestUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<CategoryRequestCreateWithoutBarInput, CategoryRequestUncheckedCreateWithoutBarInput> | CategoryRequestCreateWithoutBarInput[] | CategoryRequestUncheckedCreateWithoutBarInput[]
    connectOrCreate?: CategoryRequestCreateOrConnectWithoutBarInput | CategoryRequestCreateOrConnectWithoutBarInput[]
    upsert?: CategoryRequestUpsertWithWhereUniqueWithoutBarInput | CategoryRequestUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: CategoryRequestCreateManyBarInputEnvelope
    set?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    disconnect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    delete?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    connect?: CategoryRequestWhereUniqueInput | CategoryRequestWhereUniqueInput[]
    update?: CategoryRequestUpdateWithWhereUniqueWithoutBarInput | CategoryRequestUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: CategoryRequestUpdateManyWithWhereWithoutBarInput | CategoryRequestUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: CategoryRequestScalarWhereInput | CategoryRequestScalarWhereInput[]
  }

  export type BarMembershipUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarMembershipCreateWithoutBarInput, BarMembershipUncheckedCreateWithoutBarInput> | BarMembershipCreateWithoutBarInput[] | BarMembershipUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarMembershipCreateOrConnectWithoutBarInput | BarMembershipCreateOrConnectWithoutBarInput[]
    upsert?: BarMembershipUpsertWithWhereUniqueWithoutBarInput | BarMembershipUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarMembershipCreateManyBarInputEnvelope
    set?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    disconnect?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    delete?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    connect?: BarMembershipWhereUniqueInput | BarMembershipWhereUniqueInput[]
    update?: BarMembershipUpdateWithWhereUniqueWithoutBarInput | BarMembershipUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarMembershipUpdateManyWithWhereWithoutBarInput | BarMembershipUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarMembershipScalarWhereInput | BarMembershipScalarWhereInput[]
  }

  export type BarFollowerUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarFollowerCreateWithoutBarInput, BarFollowerUncheckedCreateWithoutBarInput> | BarFollowerCreateWithoutBarInput[] | BarFollowerUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarFollowerCreateOrConnectWithoutBarInput | BarFollowerCreateOrConnectWithoutBarInput[]
    upsert?: BarFollowerUpsertWithWhereUniqueWithoutBarInput | BarFollowerUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarFollowerCreateManyBarInputEnvelope
    set?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    disconnect?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    delete?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    connect?: BarFollowerWhereUniqueInput | BarFollowerWhereUniqueInput[]
    update?: BarFollowerUpdateWithWhereUniqueWithoutBarInput | BarFollowerUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarFollowerUpdateManyWithWhereWithoutBarInput | BarFollowerUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarFollowerScalarWhereInput | BarFollowerScalarWhereInput[]
  }

  export type BoostUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BoostCreateWithoutBarInput, BoostUncheckedCreateWithoutBarInput> | BoostCreateWithoutBarInput[] | BoostUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BoostCreateOrConnectWithoutBarInput | BoostCreateOrConnectWithoutBarInput[]
    upsert?: BoostUpsertWithWhereUniqueWithoutBarInput | BoostUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BoostCreateManyBarInputEnvelope
    set?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    disconnect?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    delete?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    connect?: BoostWhereUniqueInput | BoostWhereUniqueInput[]
    update?: BoostUpdateWithWhereUniqueWithoutBarInput | BoostUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BoostUpdateManyWithWhereWithoutBarInput | BoostUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BoostScalarWhereInput | BoostScalarWhereInput[]
  }

  export type BarProductUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarProductCreateWithoutBarInput, BarProductUncheckedCreateWithoutBarInput> | BarProductCreateWithoutBarInput[] | BarProductUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutBarInput | BarProductCreateOrConnectWithoutBarInput[]
    upsert?: BarProductUpsertWithWhereUniqueWithoutBarInput | BarProductUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarProductCreateManyBarInputEnvelope
    set?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    disconnect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    delete?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    update?: BarProductUpdateWithWhereUniqueWithoutBarInput | BarProductUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarProductUpdateManyWithWhereWithoutBarInput | BarProductUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarProductScalarWhereInput | BarProductScalarWhereInput[]
  }

  export type InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryScanSessionCreateWithoutBarInput, InventoryScanSessionUncheckedCreateWithoutBarInput> | InventoryScanSessionCreateWithoutBarInput[] | InventoryScanSessionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryScanSessionCreateOrConnectWithoutBarInput | InventoryScanSessionCreateOrConnectWithoutBarInput[]
    upsert?: InventoryScanSessionUpsertWithWhereUniqueWithoutBarInput | InventoryScanSessionUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryScanSessionCreateManyBarInputEnvelope
    set?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    disconnect?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    delete?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    connect?: InventoryScanSessionWhereUniqueInput | InventoryScanSessionWhereUniqueInput[]
    update?: InventoryScanSessionUpdateWithWhereUniqueWithoutBarInput | InventoryScanSessionUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryScanSessionUpdateManyWithWhereWithoutBarInput | InventoryScanSessionUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryScanSessionScalarWhereInput | InventoryScanSessionScalarWhereInput[]
  }

  export type InventoryCountUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<InventoryCountCreateWithoutBarInput, InventoryCountUncheckedCreateWithoutBarInput> | InventoryCountCreateWithoutBarInput[] | InventoryCountUncheckedCreateWithoutBarInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutBarInput | InventoryCountCreateOrConnectWithoutBarInput[]
    upsert?: InventoryCountUpsertWithWhereUniqueWithoutBarInput | InventoryCountUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: InventoryCountCreateManyBarInputEnvelope
    set?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    disconnect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    delete?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    update?: InventoryCountUpdateWithWhereUniqueWithoutBarInput | InventoryCountUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: InventoryCountUpdateManyWithWhereWithoutBarInput | InventoryCountUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: InventoryCountScalarWhereInput | InventoryCountScalarWhereInput[]
  }

  export type PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<PatronSearchEventCreateWithoutBarInput, PatronSearchEventUncheckedCreateWithoutBarInput> | PatronSearchEventCreateWithoutBarInput[] | PatronSearchEventUncheckedCreateWithoutBarInput[]
    connectOrCreate?: PatronSearchEventCreateOrConnectWithoutBarInput | PatronSearchEventCreateOrConnectWithoutBarInput[]
    upsert?: PatronSearchEventUpsertWithWhereUniqueWithoutBarInput | PatronSearchEventUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: PatronSearchEventCreateManyBarInputEnvelope
    set?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    disconnect?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    delete?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    connect?: PatronSearchEventWhereUniqueInput | PatronSearchEventWhereUniqueInput[]
    update?: PatronSearchEventUpdateWithWhereUniqueWithoutBarInput | PatronSearchEventUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: PatronSearchEventUpdateManyWithWhereWithoutBarInput | PatronSearchEventUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: PatronSearchEventScalarWhereInput | PatronSearchEventScalarWhereInput[]
  }

  export type BarActionUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<BarActionCreateWithoutBarInput, BarActionUncheckedCreateWithoutBarInput> | BarActionCreateWithoutBarInput[] | BarActionUncheckedCreateWithoutBarInput[]
    connectOrCreate?: BarActionCreateOrConnectWithoutBarInput | BarActionCreateOrConnectWithoutBarInput[]
    upsert?: BarActionUpsertWithWhereUniqueWithoutBarInput | BarActionUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: BarActionCreateManyBarInputEnvelope
    set?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    disconnect?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    delete?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    connect?: BarActionWhereUniqueInput | BarActionWhereUniqueInput[]
    update?: BarActionUpdateWithWhereUniqueWithoutBarInput | BarActionUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: BarActionUpdateManyWithWhereWithoutBarInput | BarActionUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: BarActionScalarWhereInput | BarActionScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<AdminNoteCreateWithoutBarInput, AdminNoteUncheckedCreateWithoutBarInput> | AdminNoteCreateWithoutBarInput[] | AdminNoteUncheckedCreateWithoutBarInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBarInput | AdminNoteCreateOrConnectWithoutBarInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutBarInput | AdminNoteUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: AdminNoteCreateManyBarInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutBarInput | AdminNoteUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutBarInput | AdminNoteUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutBarNestedInput = {
    create?: XOR<SupportTicketCreateWithoutBarInput, SupportTicketUncheckedCreateWithoutBarInput> | SupportTicketCreateWithoutBarInput[] | SupportTicketUncheckedCreateWithoutBarInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutBarInput | SupportTicketCreateOrConnectWithoutBarInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutBarInput | SupportTicketUpsertWithWhereUniqueWithoutBarInput[]
    createMany?: SupportTicketCreateManyBarInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutBarInput | SupportTicketUpdateWithWhereUniqueWithoutBarInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutBarInput | SupportTicketUpdateManyWithWhereWithoutBarInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type OfferingCreatetagsInput = {
    set: string[]
  }

  export type BarCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<BarCreateWithoutOfferingsInput, BarUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: BarCreateOrConnectWithoutOfferingsInput
    connect?: BarWhereUniqueInput
  }

  export type EnumRecurrenceFieldUpdateOperationsInput = {
    set?: $Enums.Recurrence
  }

  export type OfferingUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BarUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<BarCreateWithoutOfferingsInput, BarUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: BarCreateOrConnectWithoutOfferingsInput
    upsert?: BarUpsertWithoutOfferingsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutOfferingsInput, BarUpdateWithoutOfferingsInput>, BarUncheckedUpdateWithoutOfferingsInput>
  }

  export type EventCreatetagsInput = {
    set: string[]
  }

  export type BarCreateNestedOneWithoutEventsInput = {
    create?: XOR<BarCreateWithoutEventsInput, BarUncheckedCreateWithoutEventsInput>
    connectOrCreate?: BarCreateOrConnectWithoutEventsInput
    connect?: BarWhereUniqueInput
  }

  export type NullableEnumRecurrenceFieldUpdateOperationsInput = {
    set?: $Enums.Recurrence | null
  }

  export type EventUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BarUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<BarCreateWithoutEventsInput, BarUncheckedCreateWithoutEventsInput>
    connectOrCreate?: BarCreateOrConnectWithoutEventsInput
    upsert?: BarUpsertWithoutEventsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutEventsInput, BarUpdateWithoutEventsInput>, BarUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type BarCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<BarCreateWithoutFavoritesInput, BarUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: BarCreateOrConnectWithoutFavoritesInput
    connect?: BarWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type BarUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<BarCreateWithoutFavoritesInput, BarUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: BarCreateOrConnectWithoutFavoritesInput
    upsert?: BarUpsertWithoutFavoritesInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutFavoritesInput, BarUpdateWithoutFavoritesInput>, BarUncheckedUpdateWithoutFavoritesInput>
  }

  export type BarCreateNestedOneWithoutCategoryRequestsInput = {
    create?: XOR<BarCreateWithoutCategoryRequestsInput, BarUncheckedCreateWithoutCategoryRequestsInput>
    connectOrCreate?: BarCreateOrConnectWithoutCategoryRequestsInput
    connect?: BarWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutCategoryRequestsInput = {
    create?: XOR<OwnerCreateWithoutCategoryRequestsInput, OwnerUncheckedCreateWithoutCategoryRequestsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutCategoryRequestsInput
    connect?: OwnerWhereUniqueInput
  }

  export type EnumCategoryRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.CategoryRequestStatus
  }

  export type BarUpdateOneRequiredWithoutCategoryRequestsNestedInput = {
    create?: XOR<BarCreateWithoutCategoryRequestsInput, BarUncheckedCreateWithoutCategoryRequestsInput>
    connectOrCreate?: BarCreateOrConnectWithoutCategoryRequestsInput
    upsert?: BarUpsertWithoutCategoryRequestsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutCategoryRequestsInput, BarUpdateWithoutCategoryRequestsInput>, BarUncheckedUpdateWithoutCategoryRequestsInput>
  }

  export type OwnerUpdateOneRequiredWithoutCategoryRequestsNestedInput = {
    create?: XOR<OwnerCreateWithoutCategoryRequestsInput, OwnerUncheckedCreateWithoutCategoryRequestsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutCategoryRequestsInput
    upsert?: OwnerUpsertWithoutCategoryRequestsInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutCategoryRequestsInput, OwnerUpdateWithoutCategoryRequestsInput>, OwnerUncheckedUpdateWithoutCategoryRequestsInput>
  }

  export type OwnerCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<OwnerCreateWithoutPasswordResetsInput, OwnerUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutPasswordResetsInput
    connect?: OwnerWhereUniqueInput
  }

  export type OwnerUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<OwnerCreateWithoutPasswordResetsInput, OwnerUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutPasswordResetsInput
    upsert?: OwnerUpsertWithoutPasswordResetsInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutPasswordResetsInput, OwnerUpdateWithoutPasswordResetsInput>, OwnerUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type PromoRedemptionCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<PromoRedemptionCreateWithoutPromoCodeInput, PromoRedemptionUncheckedCreateWithoutPromoCodeInput> | PromoRedemptionCreateWithoutPromoCodeInput[] | PromoRedemptionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutPromoCodeInput | PromoRedemptionCreateOrConnectWithoutPromoCodeInput[]
    createMany?: PromoRedemptionCreateManyPromoCodeInputEnvelope
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
  }

  export type PromoRedemptionUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<PromoRedemptionCreateWithoutPromoCodeInput, PromoRedemptionUncheckedCreateWithoutPromoCodeInput> | PromoRedemptionCreateWithoutPromoCodeInput[] | PromoRedemptionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutPromoCodeInput | PromoRedemptionCreateOrConnectWithoutPromoCodeInput[]
    createMany?: PromoRedemptionCreateManyPromoCodeInputEnvelope
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
  }

  export type NullableEnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan | null
  }

  export type PromoRedemptionUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<PromoRedemptionCreateWithoutPromoCodeInput, PromoRedemptionUncheckedCreateWithoutPromoCodeInput> | PromoRedemptionCreateWithoutPromoCodeInput[] | PromoRedemptionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutPromoCodeInput | PromoRedemptionCreateOrConnectWithoutPromoCodeInput[]
    upsert?: PromoRedemptionUpsertWithWhereUniqueWithoutPromoCodeInput | PromoRedemptionUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: PromoRedemptionCreateManyPromoCodeInputEnvelope
    set?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    disconnect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    delete?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    update?: PromoRedemptionUpdateWithWhereUniqueWithoutPromoCodeInput | PromoRedemptionUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: PromoRedemptionUpdateManyWithWhereWithoutPromoCodeInput | PromoRedemptionUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: PromoRedemptionScalarWhereInput | PromoRedemptionScalarWhereInput[]
  }

  export type PromoRedemptionUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<PromoRedemptionCreateWithoutPromoCodeInput, PromoRedemptionUncheckedCreateWithoutPromoCodeInput> | PromoRedemptionCreateWithoutPromoCodeInput[] | PromoRedemptionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoRedemptionCreateOrConnectWithoutPromoCodeInput | PromoRedemptionCreateOrConnectWithoutPromoCodeInput[]
    upsert?: PromoRedemptionUpsertWithWhereUniqueWithoutPromoCodeInput | PromoRedemptionUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: PromoRedemptionCreateManyPromoCodeInputEnvelope
    set?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    disconnect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    delete?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    connect?: PromoRedemptionWhereUniqueInput | PromoRedemptionWhereUniqueInput[]
    update?: PromoRedemptionUpdateWithWhereUniqueWithoutPromoCodeInput | PromoRedemptionUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: PromoRedemptionUpdateManyWithWhereWithoutPromoCodeInput | PromoRedemptionUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: PromoRedemptionScalarWhereInput | PromoRedemptionScalarWhereInput[]
  }

  export type PromoCodeCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<PromoCodeCreateWithoutRedemptionsInput, PromoCodeUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutRedemptionsInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutPromoRedemptionsInput = {
    create?: XOR<OwnerCreateWithoutPromoRedemptionsInput, OwnerUncheckedCreateWithoutPromoRedemptionsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutPromoRedemptionsInput
    connect?: OwnerWhereUniqueInput
  }

  export type PromoCodeUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutRedemptionsInput, PromoCodeUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutRedemptionsInput
    upsert?: PromoCodeUpsertWithoutRedemptionsInput
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutRedemptionsInput, PromoCodeUpdateWithoutRedemptionsInput>, PromoCodeUncheckedUpdateWithoutRedemptionsInput>
  }

  export type OwnerUpdateOneRequiredWithoutPromoRedemptionsNestedInput = {
    create?: XOR<OwnerCreateWithoutPromoRedemptionsInput, OwnerUncheckedCreateWithoutPromoRedemptionsInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutPromoRedemptionsInput
    upsert?: OwnerUpsertWithoutPromoRedemptionsInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutPromoRedemptionsInput, OwnerUpdateWithoutPromoRedemptionsInput>, OwnerUncheckedUpdateWithoutPromoRedemptionsInput>
  }

  export type BarCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<BarCreateWithoutAnalyticsInput, BarUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: BarCreateOrConnectWithoutAnalyticsInput
    connect?: BarWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<BarCreateWithoutAnalyticsInput, BarUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: BarCreateOrConnectWithoutAnalyticsInput
    upsert?: BarUpsertWithoutAnalyticsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutAnalyticsInput, BarUpdateWithoutAnalyticsInput>, BarUncheckedUpdateWithoutAnalyticsInput>
  }

  export type BarCreateNestedOneWithoutClicksInput = {
    create?: XOR<BarCreateWithoutClicksInput, BarUncheckedCreateWithoutClicksInput>
    connectOrCreate?: BarCreateOrConnectWithoutClicksInput
    connect?: BarWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutClicksNestedInput = {
    create?: XOR<BarCreateWithoutClicksInput, BarUncheckedCreateWithoutClicksInput>
    connectOrCreate?: BarCreateOrConnectWithoutClicksInput
    upsert?: BarUpsertWithoutClicksInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutClicksInput, BarUpdateWithoutClicksInput>, BarUncheckedUpdateWithoutClicksInput>
  }

  export type BarBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<BarBadgeCreateWithoutBadgeInput, BarBadgeUncheckedCreateWithoutBadgeInput> | BarBadgeCreateWithoutBadgeInput[] | BarBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBadgeInput | BarBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: BarBadgeCreateManyBadgeInputEnvelope
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
  }

  export type BarBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<BarBadgeCreateWithoutBadgeInput, BarBadgeUncheckedCreateWithoutBadgeInput> | BarBadgeCreateWithoutBadgeInput[] | BarBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBadgeInput | BarBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: BarBadgeCreateManyBadgeInputEnvelope
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
  }

  export type EnumBadgeTierFieldUpdateOperationsInput = {
    set?: $Enums.BadgeTier
  }

  export type EnumBadgeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.BadgeCategory
  }

  export type BarBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<BarBadgeCreateWithoutBadgeInput, BarBadgeUncheckedCreateWithoutBadgeInput> | BarBadgeCreateWithoutBadgeInput[] | BarBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBadgeInput | BarBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: BarBadgeUpsertWithWhereUniqueWithoutBadgeInput | BarBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: BarBadgeCreateManyBadgeInputEnvelope
    set?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    disconnect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    delete?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    update?: BarBadgeUpdateWithWhereUniqueWithoutBadgeInput | BarBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: BarBadgeUpdateManyWithWhereWithoutBadgeInput | BarBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: BarBadgeScalarWhereInput | BarBadgeScalarWhereInput[]
  }

  export type BarBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<BarBadgeCreateWithoutBadgeInput, BarBadgeUncheckedCreateWithoutBadgeInput> | BarBadgeCreateWithoutBadgeInput[] | BarBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: BarBadgeCreateOrConnectWithoutBadgeInput | BarBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: BarBadgeUpsertWithWhereUniqueWithoutBadgeInput | BarBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: BarBadgeCreateManyBadgeInputEnvelope
    set?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    disconnect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    delete?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    connect?: BarBadgeWhereUniqueInput | BarBadgeWhereUniqueInput[]
    update?: BarBadgeUpdateWithWhereUniqueWithoutBadgeInput | BarBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: BarBadgeUpdateManyWithWhereWithoutBadgeInput | BarBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: BarBadgeScalarWhereInput | BarBadgeScalarWhereInput[]
  }

  export type BarCreateNestedOneWithoutBadgesInput = {
    create?: XOR<BarCreateWithoutBadgesInput, BarUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BarCreateOrConnectWithoutBadgesInput
    connect?: BarWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutBarBadgesInput = {
    create?: XOR<BadgeCreateWithoutBarBadgesInput, BadgeUncheckedCreateWithoutBarBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutBarBadgesInput
    connect?: BadgeWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<BarCreateWithoutBadgesInput, BarUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BarCreateOrConnectWithoutBadgesInput
    upsert?: BarUpsertWithoutBadgesInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutBadgesInput, BarUpdateWithoutBadgesInput>, BarUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutBarBadgesNestedInput = {
    create?: XOR<BadgeCreateWithoutBarBadgesInput, BadgeUncheckedCreateWithoutBarBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutBarBadgesInput
    upsert?: BadgeUpsertWithoutBarBadgesInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutBarBadgesInput, BadgeUpdateWithoutBarBadgesInput>, BadgeUncheckedUpdateWithoutBarBadgesInput>
  }

  export type BarCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<BarCreateWithoutInventoryItemsInput, BarUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryItemsInput
    connect?: BarWhereUniqueInput
  }

  export type InventorySnapshotItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutInventoryItemInput, InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput> | InventorySnapshotItemCreateWithoutInventoryItemInput[] | InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput | InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: InventorySnapshotItemCreateManyInventoryItemInputEnvelope
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
  }

  export type ShiftUsageItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<ShiftUsageItemCreateWithoutInventoryItemInput, ShiftUsageItemUncheckedCreateWithoutInventoryItemInput> | ShiftUsageItemCreateWithoutInventoryItemInput[] | ShiftUsageItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutInventoryItemInput | ShiftUsageItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: ShiftUsageItemCreateManyInventoryItemInputEnvelope
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
  }

  export type CostingProfileCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<CostingProfileCreateWithoutInventoryItemInput, CostingProfileUncheckedCreateWithoutInventoryItemInput> | CostingProfileCreateWithoutInventoryItemInput[] | CostingProfileUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: CostingProfileCreateOrConnectWithoutInventoryItemInput | CostingProfileCreateOrConnectWithoutInventoryItemInput[]
    createMany?: CostingProfileCreateManyInventoryItemInputEnvelope
    connect?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
  }

  export type VarianceAlertCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<VarianceAlertCreateWithoutInventoryItemInput, VarianceAlertUncheckedCreateWithoutInventoryItemInput> | VarianceAlertCreateWithoutInventoryItemInput[] | VarianceAlertUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutInventoryItemInput | VarianceAlertCreateOrConnectWithoutInventoryItemInput[]
    createMany?: VarianceAlertCreateManyInventoryItemInputEnvelope
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
  }

  export type InventorySnapshotItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutInventoryItemInput, InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput> | InventorySnapshotItemCreateWithoutInventoryItemInput[] | InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput | InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: InventorySnapshotItemCreateManyInventoryItemInputEnvelope
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
  }

  export type ShiftUsageItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<ShiftUsageItemCreateWithoutInventoryItemInput, ShiftUsageItemUncheckedCreateWithoutInventoryItemInput> | ShiftUsageItemCreateWithoutInventoryItemInput[] | ShiftUsageItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutInventoryItemInput | ShiftUsageItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: ShiftUsageItemCreateManyInventoryItemInputEnvelope
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
  }

  export type CostingProfileUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<CostingProfileCreateWithoutInventoryItemInput, CostingProfileUncheckedCreateWithoutInventoryItemInput> | CostingProfileCreateWithoutInventoryItemInput[] | CostingProfileUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: CostingProfileCreateOrConnectWithoutInventoryItemInput | CostingProfileCreateOrConnectWithoutInventoryItemInput[]
    createMany?: CostingProfileCreateManyInventoryItemInputEnvelope
    connect?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
  }

  export type VarianceAlertUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<VarianceAlertCreateWithoutInventoryItemInput, VarianceAlertUncheckedCreateWithoutInventoryItemInput> | VarianceAlertCreateWithoutInventoryItemInput[] | VarianceAlertUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutInventoryItemInput | VarianceAlertCreateOrConnectWithoutInventoryItemInput[]
    createMany?: VarianceAlertCreateManyInventoryItemInputEnvelope
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
  }

  export type BarUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<BarCreateWithoutInventoryItemsInput, BarUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryItemsInput
    upsert?: BarUpsertWithoutInventoryItemsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutInventoryItemsInput, BarUpdateWithoutInventoryItemsInput>, BarUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type InventorySnapshotItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutInventoryItemInput, InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput> | InventorySnapshotItemCreateWithoutInventoryItemInput[] | InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput | InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: InventorySnapshotItemUpsertWithWhereUniqueWithoutInventoryItemInput | InventorySnapshotItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: InventorySnapshotItemCreateManyInventoryItemInputEnvelope
    set?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    disconnect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    delete?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    update?: InventorySnapshotItemUpdateWithWhereUniqueWithoutInventoryItemInput | InventorySnapshotItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: InventorySnapshotItemUpdateManyWithWhereWithoutInventoryItemInput | InventorySnapshotItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: InventorySnapshotItemScalarWhereInput | InventorySnapshotItemScalarWhereInput[]
  }

  export type ShiftUsageItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<ShiftUsageItemCreateWithoutInventoryItemInput, ShiftUsageItemUncheckedCreateWithoutInventoryItemInput> | ShiftUsageItemCreateWithoutInventoryItemInput[] | ShiftUsageItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutInventoryItemInput | ShiftUsageItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: ShiftUsageItemUpsertWithWhereUniqueWithoutInventoryItemInput | ShiftUsageItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: ShiftUsageItemCreateManyInventoryItemInputEnvelope
    set?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    disconnect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    delete?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    update?: ShiftUsageItemUpdateWithWhereUniqueWithoutInventoryItemInput | ShiftUsageItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: ShiftUsageItemUpdateManyWithWhereWithoutInventoryItemInput | ShiftUsageItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: ShiftUsageItemScalarWhereInput | ShiftUsageItemScalarWhereInput[]
  }

  export type CostingProfileUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<CostingProfileCreateWithoutInventoryItemInput, CostingProfileUncheckedCreateWithoutInventoryItemInput> | CostingProfileCreateWithoutInventoryItemInput[] | CostingProfileUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: CostingProfileCreateOrConnectWithoutInventoryItemInput | CostingProfileCreateOrConnectWithoutInventoryItemInput[]
    upsert?: CostingProfileUpsertWithWhereUniqueWithoutInventoryItemInput | CostingProfileUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: CostingProfileCreateManyInventoryItemInputEnvelope
    set?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    disconnect?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    delete?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    connect?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    update?: CostingProfileUpdateWithWhereUniqueWithoutInventoryItemInput | CostingProfileUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: CostingProfileUpdateManyWithWhereWithoutInventoryItemInput | CostingProfileUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: CostingProfileScalarWhereInput | CostingProfileScalarWhereInput[]
  }

  export type VarianceAlertUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<VarianceAlertCreateWithoutInventoryItemInput, VarianceAlertUncheckedCreateWithoutInventoryItemInput> | VarianceAlertCreateWithoutInventoryItemInput[] | VarianceAlertUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutInventoryItemInput | VarianceAlertCreateOrConnectWithoutInventoryItemInput[]
    upsert?: VarianceAlertUpsertWithWhereUniqueWithoutInventoryItemInput | VarianceAlertUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: VarianceAlertCreateManyInventoryItemInputEnvelope
    set?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    disconnect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    delete?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    update?: VarianceAlertUpdateWithWhereUniqueWithoutInventoryItemInput | VarianceAlertUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: VarianceAlertUpdateManyWithWhereWithoutInventoryItemInput | VarianceAlertUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: VarianceAlertScalarWhereInput | VarianceAlertScalarWhereInput[]
  }

  export type InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutInventoryItemInput, InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput> | InventorySnapshotItemCreateWithoutInventoryItemInput[] | InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput | InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: InventorySnapshotItemUpsertWithWhereUniqueWithoutInventoryItemInput | InventorySnapshotItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: InventorySnapshotItemCreateManyInventoryItemInputEnvelope
    set?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    disconnect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    delete?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    update?: InventorySnapshotItemUpdateWithWhereUniqueWithoutInventoryItemInput | InventorySnapshotItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: InventorySnapshotItemUpdateManyWithWhereWithoutInventoryItemInput | InventorySnapshotItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: InventorySnapshotItemScalarWhereInput | InventorySnapshotItemScalarWhereInput[]
  }

  export type ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<ShiftUsageItemCreateWithoutInventoryItemInput, ShiftUsageItemUncheckedCreateWithoutInventoryItemInput> | ShiftUsageItemCreateWithoutInventoryItemInput[] | ShiftUsageItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutInventoryItemInput | ShiftUsageItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: ShiftUsageItemUpsertWithWhereUniqueWithoutInventoryItemInput | ShiftUsageItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: ShiftUsageItemCreateManyInventoryItemInputEnvelope
    set?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    disconnect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    delete?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    update?: ShiftUsageItemUpdateWithWhereUniqueWithoutInventoryItemInput | ShiftUsageItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: ShiftUsageItemUpdateManyWithWhereWithoutInventoryItemInput | ShiftUsageItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: ShiftUsageItemScalarWhereInput | ShiftUsageItemScalarWhereInput[]
  }

  export type CostingProfileUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<CostingProfileCreateWithoutInventoryItemInput, CostingProfileUncheckedCreateWithoutInventoryItemInput> | CostingProfileCreateWithoutInventoryItemInput[] | CostingProfileUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: CostingProfileCreateOrConnectWithoutInventoryItemInput | CostingProfileCreateOrConnectWithoutInventoryItemInput[]
    upsert?: CostingProfileUpsertWithWhereUniqueWithoutInventoryItemInput | CostingProfileUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: CostingProfileCreateManyInventoryItemInputEnvelope
    set?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    disconnect?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    delete?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    connect?: CostingProfileWhereUniqueInput | CostingProfileWhereUniqueInput[]
    update?: CostingProfileUpdateWithWhereUniqueWithoutInventoryItemInput | CostingProfileUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: CostingProfileUpdateManyWithWhereWithoutInventoryItemInput | CostingProfileUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: CostingProfileScalarWhereInput | CostingProfileScalarWhereInput[]
  }

  export type VarianceAlertUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<VarianceAlertCreateWithoutInventoryItemInput, VarianceAlertUncheckedCreateWithoutInventoryItemInput> | VarianceAlertCreateWithoutInventoryItemInput[] | VarianceAlertUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: VarianceAlertCreateOrConnectWithoutInventoryItemInput | VarianceAlertCreateOrConnectWithoutInventoryItemInput[]
    upsert?: VarianceAlertUpsertWithWhereUniqueWithoutInventoryItemInput | VarianceAlertUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: VarianceAlertCreateManyInventoryItemInputEnvelope
    set?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    disconnect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    delete?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    connect?: VarianceAlertWhereUniqueInput | VarianceAlertWhereUniqueInput[]
    update?: VarianceAlertUpdateWithWhereUniqueWithoutInventoryItemInput | VarianceAlertUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: VarianceAlertUpdateManyWithWhereWithoutInventoryItemInput | VarianceAlertUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: VarianceAlertScalarWhereInput | VarianceAlertScalarWhereInput[]
  }

  export type BarCreateNestedOneWithoutInventoryImportsInput = {
    create?: XOR<BarCreateWithoutInventoryImportsInput, BarUncheckedCreateWithoutInventoryImportsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryImportsInput
    connect?: BarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryImportsInput = {
    create?: XOR<UserCreateWithoutInventoryImportsInput, UserUncheckedCreateWithoutInventoryImportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryImportsInput
    connect?: UserWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutInventoryImportsNestedInput = {
    create?: XOR<BarCreateWithoutInventoryImportsInput, BarUncheckedCreateWithoutInventoryImportsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryImportsInput
    upsert?: BarUpsertWithoutInventoryImportsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutInventoryImportsInput, BarUpdateWithoutInventoryImportsInput>, BarUncheckedUpdateWithoutInventoryImportsInput>
  }

  export type UserUpdateOneWithoutInventoryImportsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryImportsInput, UserUncheckedCreateWithoutInventoryImportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryImportsInput
    upsert?: UserUpsertWithoutInventoryImportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryImportsInput, UserUpdateWithoutInventoryImportsInput>, UserUncheckedUpdateWithoutInventoryImportsInput>
  }

  export type BarCreateNestedOneWithoutShiftUsagesInput = {
    create?: XOR<BarCreateWithoutShiftUsagesInput, BarUncheckedCreateWithoutShiftUsagesInput>
    connectOrCreate?: BarCreateOrConnectWithoutShiftUsagesInput
    connect?: BarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShiftUsagesInput = {
    create?: XOR<UserCreateWithoutShiftUsagesInput, UserUncheckedCreateWithoutShiftUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftUsagesInput
    connect?: UserWhereUniqueInput
  }

  export type ShiftUsageItemCreateNestedManyWithoutShiftUsageInput = {
    create?: XOR<ShiftUsageItemCreateWithoutShiftUsageInput, ShiftUsageItemUncheckedCreateWithoutShiftUsageInput> | ShiftUsageItemCreateWithoutShiftUsageInput[] | ShiftUsageItemUncheckedCreateWithoutShiftUsageInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutShiftUsageInput | ShiftUsageItemCreateOrConnectWithoutShiftUsageInput[]
    createMany?: ShiftUsageItemCreateManyShiftUsageInputEnvelope
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
  }

  export type ShiftUsageItemUncheckedCreateNestedManyWithoutShiftUsageInput = {
    create?: XOR<ShiftUsageItemCreateWithoutShiftUsageInput, ShiftUsageItemUncheckedCreateWithoutShiftUsageInput> | ShiftUsageItemCreateWithoutShiftUsageInput[] | ShiftUsageItemUncheckedCreateWithoutShiftUsageInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutShiftUsageInput | ShiftUsageItemCreateOrConnectWithoutShiftUsageInput[]
    createMany?: ShiftUsageItemCreateManyShiftUsageInputEnvelope
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
  }

  export type BarUpdateOneRequiredWithoutShiftUsagesNestedInput = {
    create?: XOR<BarCreateWithoutShiftUsagesInput, BarUncheckedCreateWithoutShiftUsagesInput>
    connectOrCreate?: BarCreateOrConnectWithoutShiftUsagesInput
    upsert?: BarUpsertWithoutShiftUsagesInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutShiftUsagesInput, BarUpdateWithoutShiftUsagesInput>, BarUncheckedUpdateWithoutShiftUsagesInput>
  }

  export type UserUpdateOneWithoutShiftUsagesNestedInput = {
    create?: XOR<UserCreateWithoutShiftUsagesInput, UserUncheckedCreateWithoutShiftUsagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftUsagesInput
    upsert?: UserUpsertWithoutShiftUsagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftUsagesInput, UserUpdateWithoutShiftUsagesInput>, UserUncheckedUpdateWithoutShiftUsagesInput>
  }

  export type ShiftUsageItemUpdateManyWithoutShiftUsageNestedInput = {
    create?: XOR<ShiftUsageItemCreateWithoutShiftUsageInput, ShiftUsageItemUncheckedCreateWithoutShiftUsageInput> | ShiftUsageItemCreateWithoutShiftUsageInput[] | ShiftUsageItemUncheckedCreateWithoutShiftUsageInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutShiftUsageInput | ShiftUsageItemCreateOrConnectWithoutShiftUsageInput[]
    upsert?: ShiftUsageItemUpsertWithWhereUniqueWithoutShiftUsageInput | ShiftUsageItemUpsertWithWhereUniqueWithoutShiftUsageInput[]
    createMany?: ShiftUsageItemCreateManyShiftUsageInputEnvelope
    set?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    disconnect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    delete?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    update?: ShiftUsageItemUpdateWithWhereUniqueWithoutShiftUsageInput | ShiftUsageItemUpdateWithWhereUniqueWithoutShiftUsageInput[]
    updateMany?: ShiftUsageItemUpdateManyWithWhereWithoutShiftUsageInput | ShiftUsageItemUpdateManyWithWhereWithoutShiftUsageInput[]
    deleteMany?: ShiftUsageItemScalarWhereInput | ShiftUsageItemScalarWhereInput[]
  }

  export type ShiftUsageItemUncheckedUpdateManyWithoutShiftUsageNestedInput = {
    create?: XOR<ShiftUsageItemCreateWithoutShiftUsageInput, ShiftUsageItemUncheckedCreateWithoutShiftUsageInput> | ShiftUsageItemCreateWithoutShiftUsageInput[] | ShiftUsageItemUncheckedCreateWithoutShiftUsageInput[]
    connectOrCreate?: ShiftUsageItemCreateOrConnectWithoutShiftUsageInput | ShiftUsageItemCreateOrConnectWithoutShiftUsageInput[]
    upsert?: ShiftUsageItemUpsertWithWhereUniqueWithoutShiftUsageInput | ShiftUsageItemUpsertWithWhereUniqueWithoutShiftUsageInput[]
    createMany?: ShiftUsageItemCreateManyShiftUsageInputEnvelope
    set?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    disconnect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    delete?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    connect?: ShiftUsageItemWhereUniqueInput | ShiftUsageItemWhereUniqueInput[]
    update?: ShiftUsageItemUpdateWithWhereUniqueWithoutShiftUsageInput | ShiftUsageItemUpdateWithWhereUniqueWithoutShiftUsageInput[]
    updateMany?: ShiftUsageItemUpdateManyWithWhereWithoutShiftUsageInput | ShiftUsageItemUpdateManyWithWhereWithoutShiftUsageInput[]
    deleteMany?: ShiftUsageItemScalarWhereInput | ShiftUsageItemScalarWhereInput[]
  }

  export type ShiftUsageCreateNestedOneWithoutItemsInput = {
    create?: XOR<ShiftUsageCreateWithoutItemsInput, ShiftUsageUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutItemsInput
    connect?: ShiftUsageWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutShiftUsageItemsInput = {
    create?: XOR<InventoryItemCreateWithoutShiftUsageItemsInput, InventoryItemUncheckedCreateWithoutShiftUsageItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutShiftUsageItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ShiftUsageUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ShiftUsageCreateWithoutItemsInput, ShiftUsageUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShiftUsageCreateOrConnectWithoutItemsInput
    upsert?: ShiftUsageUpsertWithoutItemsInput
    connect?: ShiftUsageWhereUniqueInput
    update?: XOR<XOR<ShiftUsageUpdateToOneWithWhereWithoutItemsInput, ShiftUsageUpdateWithoutItemsInput>, ShiftUsageUncheckedUpdateWithoutItemsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutShiftUsageItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutShiftUsageItemsInput, InventoryItemUncheckedCreateWithoutShiftUsageItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutShiftUsageItemsInput
    upsert?: InventoryItemUpsertWithoutShiftUsageItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutShiftUsageItemsInput, InventoryItemUpdateWithoutShiftUsageItemsInput>, InventoryItemUncheckedUpdateWithoutShiftUsageItemsInput>
  }

  export type BarCreateNestedOneWithoutInventorySnapshotsInput = {
    create?: XOR<BarCreateWithoutInventorySnapshotsInput, BarUncheckedCreateWithoutInventorySnapshotsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventorySnapshotsInput
    connect?: BarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventorySnapshotsInput = {
    create?: XOR<UserCreateWithoutInventorySnapshotsInput, UserUncheckedCreateWithoutInventorySnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventorySnapshotsInput
    connect?: UserWhereUniqueInput
  }

  export type InventorySnapshotItemCreateNestedManyWithoutSnapshotInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutSnapshotInput, InventorySnapshotItemUncheckedCreateWithoutSnapshotInput> | InventorySnapshotItemCreateWithoutSnapshotInput[] | InventorySnapshotItemUncheckedCreateWithoutSnapshotInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutSnapshotInput | InventorySnapshotItemCreateOrConnectWithoutSnapshotInput[]
    createMany?: InventorySnapshotItemCreateManySnapshotInputEnvelope
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
  }

  export type InventorySnapshotItemUncheckedCreateNestedManyWithoutSnapshotInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutSnapshotInput, InventorySnapshotItemUncheckedCreateWithoutSnapshotInput> | InventorySnapshotItemCreateWithoutSnapshotInput[] | InventorySnapshotItemUncheckedCreateWithoutSnapshotInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutSnapshotInput | InventorySnapshotItemCreateOrConnectWithoutSnapshotInput[]
    createMany?: InventorySnapshotItemCreateManySnapshotInputEnvelope
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
  }

  export type BarUpdateOneRequiredWithoutInventorySnapshotsNestedInput = {
    create?: XOR<BarCreateWithoutInventorySnapshotsInput, BarUncheckedCreateWithoutInventorySnapshotsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventorySnapshotsInput
    upsert?: BarUpsertWithoutInventorySnapshotsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutInventorySnapshotsInput, BarUpdateWithoutInventorySnapshotsInput>, BarUncheckedUpdateWithoutInventorySnapshotsInput>
  }

  export type UserUpdateOneWithoutInventorySnapshotsNestedInput = {
    create?: XOR<UserCreateWithoutInventorySnapshotsInput, UserUncheckedCreateWithoutInventorySnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventorySnapshotsInput
    upsert?: UserUpsertWithoutInventorySnapshotsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventorySnapshotsInput, UserUpdateWithoutInventorySnapshotsInput>, UserUncheckedUpdateWithoutInventorySnapshotsInput>
  }

  export type InventorySnapshotItemUpdateManyWithoutSnapshotNestedInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutSnapshotInput, InventorySnapshotItemUncheckedCreateWithoutSnapshotInput> | InventorySnapshotItemCreateWithoutSnapshotInput[] | InventorySnapshotItemUncheckedCreateWithoutSnapshotInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutSnapshotInput | InventorySnapshotItemCreateOrConnectWithoutSnapshotInput[]
    upsert?: InventorySnapshotItemUpsertWithWhereUniqueWithoutSnapshotInput | InventorySnapshotItemUpsertWithWhereUniqueWithoutSnapshotInput[]
    createMany?: InventorySnapshotItemCreateManySnapshotInputEnvelope
    set?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    disconnect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    delete?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    update?: InventorySnapshotItemUpdateWithWhereUniqueWithoutSnapshotInput | InventorySnapshotItemUpdateWithWhereUniqueWithoutSnapshotInput[]
    updateMany?: InventorySnapshotItemUpdateManyWithWhereWithoutSnapshotInput | InventorySnapshotItemUpdateManyWithWhereWithoutSnapshotInput[]
    deleteMany?: InventorySnapshotItemScalarWhereInput | InventorySnapshotItemScalarWhereInput[]
  }

  export type InventorySnapshotItemUncheckedUpdateManyWithoutSnapshotNestedInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutSnapshotInput, InventorySnapshotItemUncheckedCreateWithoutSnapshotInput> | InventorySnapshotItemCreateWithoutSnapshotInput[] | InventorySnapshotItemUncheckedCreateWithoutSnapshotInput[]
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutSnapshotInput | InventorySnapshotItemCreateOrConnectWithoutSnapshotInput[]
    upsert?: InventorySnapshotItemUpsertWithWhereUniqueWithoutSnapshotInput | InventorySnapshotItemUpsertWithWhereUniqueWithoutSnapshotInput[]
    createMany?: InventorySnapshotItemCreateManySnapshotInputEnvelope
    set?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    disconnect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    delete?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    connect?: InventorySnapshotItemWhereUniqueInput | InventorySnapshotItemWhereUniqueInput[]
    update?: InventorySnapshotItemUpdateWithWhereUniqueWithoutSnapshotInput | InventorySnapshotItemUpdateWithWhereUniqueWithoutSnapshotInput[]
    updateMany?: InventorySnapshotItemUpdateManyWithWhereWithoutSnapshotInput | InventorySnapshotItemUpdateManyWithWhereWithoutSnapshotInput[]
    deleteMany?: InventorySnapshotItemScalarWhereInput | InventorySnapshotItemScalarWhereInput[]
  }

  export type InventorySnapshotCreateNestedOneWithoutItemsInput = {
    create?: XOR<InventorySnapshotCreateWithoutItemsInput, InventorySnapshotUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutItemsInput
    connect?: InventorySnapshotWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutSnapshotItemsInput = {
    create?: XOR<InventoryItemCreateWithoutSnapshotItemsInput, InventoryItemUncheckedCreateWithoutSnapshotItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSnapshotItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type BottlePhotoCreateNestedOneWithoutSnapshotItemInput = {
    create?: XOR<BottlePhotoCreateWithoutSnapshotItemInput, BottlePhotoUncheckedCreateWithoutSnapshotItemInput>
    connectOrCreate?: BottlePhotoCreateOrConnectWithoutSnapshotItemInput
    connect?: BottlePhotoWhereUniqueInput
  }

  export type BottlePhotoUncheckedCreateNestedOneWithoutSnapshotItemInput = {
    create?: XOR<BottlePhotoCreateWithoutSnapshotItemInput, BottlePhotoUncheckedCreateWithoutSnapshotItemInput>
    connectOrCreate?: BottlePhotoCreateOrConnectWithoutSnapshotItemInput
    connect?: BottlePhotoWhereUniqueInput
  }

  export type InventorySnapshotUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InventorySnapshotCreateWithoutItemsInput, InventorySnapshotUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InventorySnapshotCreateOrConnectWithoutItemsInput
    upsert?: InventorySnapshotUpsertWithoutItemsInput
    connect?: InventorySnapshotWhereUniqueInput
    update?: XOR<XOR<InventorySnapshotUpdateToOneWithWhereWithoutItemsInput, InventorySnapshotUpdateWithoutItemsInput>, InventorySnapshotUncheckedUpdateWithoutItemsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutSnapshotItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutSnapshotItemsInput, InventoryItemUncheckedCreateWithoutSnapshotItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSnapshotItemsInput
    upsert?: InventoryItemUpsertWithoutSnapshotItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutSnapshotItemsInput, InventoryItemUpdateWithoutSnapshotItemsInput>, InventoryItemUncheckedUpdateWithoutSnapshotItemsInput>
  }

  export type BottlePhotoUpdateOneWithoutSnapshotItemNestedInput = {
    create?: XOR<BottlePhotoCreateWithoutSnapshotItemInput, BottlePhotoUncheckedCreateWithoutSnapshotItemInput>
    connectOrCreate?: BottlePhotoCreateOrConnectWithoutSnapshotItemInput
    upsert?: BottlePhotoUpsertWithoutSnapshotItemInput
    disconnect?: BottlePhotoWhereInput | boolean
    delete?: BottlePhotoWhereInput | boolean
    connect?: BottlePhotoWhereUniqueInput
    update?: XOR<XOR<BottlePhotoUpdateToOneWithWhereWithoutSnapshotItemInput, BottlePhotoUpdateWithoutSnapshotItemInput>, BottlePhotoUncheckedUpdateWithoutSnapshotItemInput>
  }

  export type BottlePhotoUncheckedUpdateOneWithoutSnapshotItemNestedInput = {
    create?: XOR<BottlePhotoCreateWithoutSnapshotItemInput, BottlePhotoUncheckedCreateWithoutSnapshotItemInput>
    connectOrCreate?: BottlePhotoCreateOrConnectWithoutSnapshotItemInput
    upsert?: BottlePhotoUpsertWithoutSnapshotItemInput
    disconnect?: BottlePhotoWhereInput | boolean
    delete?: BottlePhotoWhereInput | boolean
    connect?: BottlePhotoWhereUniqueInput
    update?: XOR<XOR<BottlePhotoUpdateToOneWithWhereWithoutSnapshotItemInput, BottlePhotoUpdateWithoutSnapshotItemInput>, BottlePhotoUncheckedUpdateWithoutSnapshotItemInput>
  }

  export type InventorySnapshotItemCreateNestedOneWithoutBottlePhotoInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutBottlePhotoInput, InventorySnapshotItemUncheckedCreateWithoutBottlePhotoInput>
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutBottlePhotoInput
    connect?: InventorySnapshotItemWhereUniqueInput
  }

  export type InventorySnapshotItemUpdateOneRequiredWithoutBottlePhotoNestedInput = {
    create?: XOR<InventorySnapshotItemCreateWithoutBottlePhotoInput, InventorySnapshotItemUncheckedCreateWithoutBottlePhotoInput>
    connectOrCreate?: InventorySnapshotItemCreateOrConnectWithoutBottlePhotoInput
    upsert?: InventorySnapshotItemUpsertWithoutBottlePhotoInput
    connect?: InventorySnapshotItemWhereUniqueInput
    update?: XOR<XOR<InventorySnapshotItemUpdateToOneWithWhereWithoutBottlePhotoInput, InventorySnapshotItemUpdateWithoutBottlePhotoInput>, InventorySnapshotItemUncheckedUpdateWithoutBottlePhotoInput>
  }

  export type InventoryItemCreateNestedOneWithoutCostingProfilesInput = {
    create?: XOR<InventoryItemCreateWithoutCostingProfilesInput, InventoryItemUncheckedCreateWithoutCostingProfilesInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutCostingProfilesInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type InventoryItemUpdateOneRequiredWithoutCostingProfilesNestedInput = {
    create?: XOR<InventoryItemCreateWithoutCostingProfilesInput, InventoryItemUncheckedCreateWithoutCostingProfilesInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutCostingProfilesInput
    upsert?: InventoryItemUpsertWithoutCostingProfilesInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutCostingProfilesInput, InventoryItemUpdateWithoutCostingProfilesInput>, InventoryItemUncheckedUpdateWithoutCostingProfilesInput>
  }

  export type BarCreateNestedOneWithoutVarianceAlertsInput = {
    create?: XOR<BarCreateWithoutVarianceAlertsInput, BarUncheckedCreateWithoutVarianceAlertsInput>
    connectOrCreate?: BarCreateOrConnectWithoutVarianceAlertsInput
    connect?: BarWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutVarianceAlertsInput = {
    create?: XOR<InventoryItemCreateWithoutVarianceAlertsInput, InventoryItemUncheckedCreateWithoutVarianceAlertsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutVarianceAlertsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutVarianceAlertsNestedInput = {
    create?: XOR<BarCreateWithoutVarianceAlertsInput, BarUncheckedCreateWithoutVarianceAlertsInput>
    connectOrCreate?: BarCreateOrConnectWithoutVarianceAlertsInput
    upsert?: BarUpsertWithoutVarianceAlertsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutVarianceAlertsInput, BarUpdateWithoutVarianceAlertsInput>, BarUncheckedUpdateWithoutVarianceAlertsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutVarianceAlertsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutVarianceAlertsInput, InventoryItemUncheckedCreateWithoutVarianceAlertsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutVarianceAlertsInput
    upsert?: InventoryItemUpsertWithoutVarianceAlertsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutVarianceAlertsInput, InventoryItemUpdateWithoutVarianceAlertsInput>, InventoryItemUncheckedUpdateWithoutVarianceAlertsInput>
  }

  export type BarCreateNestedOneWithoutBarLicensesInput = {
    create?: XOR<BarCreateWithoutBarLicensesInput, BarUncheckedCreateWithoutBarLicensesInput>
    connectOrCreate?: BarCreateOrConnectWithoutBarLicensesInput
    connect?: BarWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutBarLicensesInput = {
    create?: XOR<OwnerCreateWithoutBarLicensesInput, OwnerUncheckedCreateWithoutBarLicensesInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBarLicensesInput
    connect?: OwnerWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutBarLicensesNestedInput = {
    create?: XOR<BarCreateWithoutBarLicensesInput, BarUncheckedCreateWithoutBarLicensesInput>
    connectOrCreate?: BarCreateOrConnectWithoutBarLicensesInput
    upsert?: BarUpsertWithoutBarLicensesInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutBarLicensesInput, BarUpdateWithoutBarLicensesInput>, BarUncheckedUpdateWithoutBarLicensesInput>
  }

  export type OwnerUpdateOneRequiredWithoutBarLicensesNestedInput = {
    create?: XOR<OwnerCreateWithoutBarLicensesInput, OwnerUncheckedCreateWithoutBarLicensesInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutBarLicensesInput
    upsert?: OwnerUpsertWithoutBarLicensesInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutBarLicensesInput, OwnerUpdateWithoutBarLicensesInput>, OwnerUncheckedUpdateWithoutBarLicensesInput>
  }

  export type BarCreateNestedOneWithoutVisitsInput = {
    create?: XOR<BarCreateWithoutVisitsInput, BarUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: BarCreateOrConnectWithoutVisitsInput
    connect?: BarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVisitsInput = {
    create?: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutVisitsNestedInput = {
    create?: XOR<BarCreateWithoutVisitsInput, BarUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: BarCreateOrConnectWithoutVisitsInput
    upsert?: BarUpsertWithoutVisitsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutVisitsInput, BarUpdateWithoutVisitsInput>, BarUncheckedUpdateWithoutVisitsInput>
  }

  export type UserUpdateOneWithoutVisitsNestedInput = {
    create?: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitsInput
    upsert?: UserUpsertWithoutVisitsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVisitsInput, UserUpdateWithoutVisitsInput>, UserUncheckedUpdateWithoutVisitsInput>
  }

  export type BarCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<BarCreateWithoutMembershipsInput, BarUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: BarCreateOrConnectWithoutMembershipsInput
    connect?: BarWhereUniqueInput
  }

  export type EnumBarMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.BarMemberRole
  }

  export type BarUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<BarCreateWithoutMembershipsInput, BarUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: BarCreateOrConnectWithoutMembershipsInput
    upsert?: BarUpsertWithoutMembershipsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutMembershipsInput, BarUpdateWithoutMembershipsInput>, BarUncheckedUpdateWithoutMembershipsInput>
  }

  export type BarCreateNestedOneWithoutPatronSearchEventsInput = {
    create?: XOR<BarCreateWithoutPatronSearchEventsInput, BarUncheckedCreateWithoutPatronSearchEventsInput>
    connectOrCreate?: BarCreateOrConnectWithoutPatronSearchEventsInput
    connect?: BarWhereUniqueInput
  }

  export type BarUpdateOneWithoutPatronSearchEventsNestedInput = {
    create?: XOR<BarCreateWithoutPatronSearchEventsInput, BarUncheckedCreateWithoutPatronSearchEventsInput>
    connectOrCreate?: BarCreateOrConnectWithoutPatronSearchEventsInput
    upsert?: BarUpsertWithoutPatronSearchEventsInput
    disconnect?: BarWhereInput | boolean
    delete?: BarWhereInput | boolean
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutPatronSearchEventsInput, BarUpdateWithoutPatronSearchEventsInput>, BarUncheckedUpdateWithoutPatronSearchEventsInput>
  }

  export type BarCreateNestedOneWithoutBarActionsInput = {
    create?: XOR<BarCreateWithoutBarActionsInput, BarUncheckedCreateWithoutBarActionsInput>
    connectOrCreate?: BarCreateOrConnectWithoutBarActionsInput
    connect?: BarWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutBarActionsNestedInput = {
    create?: XOR<BarCreateWithoutBarActionsInput, BarUncheckedCreateWithoutBarActionsInput>
    connectOrCreate?: BarCreateOrConnectWithoutBarActionsInput
    upsert?: BarUpsertWithoutBarActionsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutBarActionsInput, BarUpdateWithoutBarActionsInput>, BarUncheckedUpdateWithoutBarActionsInput>
  }

  export type BarCreateNestedOneWithoutFollowersInput = {
    create?: XOR<BarCreateWithoutFollowersInput, BarUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: BarCreateOrConnectWithoutFollowersInput
    connect?: BarWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<BarCreateWithoutFollowersInput, BarUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: BarCreateOrConnectWithoutFollowersInput
    upsert?: BarUpsertWithoutFollowersInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutFollowersInput, BarUpdateWithoutFollowersInput>, BarUncheckedUpdateWithoutFollowersInput>
  }

  export type BarCreateNestedOneWithoutBoostsInput = {
    create?: XOR<BarCreateWithoutBoostsInput, BarUncheckedCreateWithoutBoostsInput>
    connectOrCreate?: BarCreateOrConnectWithoutBoostsInput
    connect?: BarWhereUniqueInput
  }

  export type BoostMetricCreateNestedManyWithoutBoostInput = {
    create?: XOR<BoostMetricCreateWithoutBoostInput, BoostMetricUncheckedCreateWithoutBoostInput> | BoostMetricCreateWithoutBoostInput[] | BoostMetricUncheckedCreateWithoutBoostInput[]
    connectOrCreate?: BoostMetricCreateOrConnectWithoutBoostInput | BoostMetricCreateOrConnectWithoutBoostInput[]
    createMany?: BoostMetricCreateManyBoostInputEnvelope
    connect?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
  }

  export type BoostMetricUncheckedCreateNestedManyWithoutBoostInput = {
    create?: XOR<BoostMetricCreateWithoutBoostInput, BoostMetricUncheckedCreateWithoutBoostInput> | BoostMetricCreateWithoutBoostInput[] | BoostMetricUncheckedCreateWithoutBoostInput[]
    connectOrCreate?: BoostMetricCreateOrConnectWithoutBoostInput | BoostMetricCreateOrConnectWithoutBoostInput[]
    createMany?: BoostMetricCreateManyBoostInputEnvelope
    connect?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
  }

  export type BarUpdateOneRequiredWithoutBoostsNestedInput = {
    create?: XOR<BarCreateWithoutBoostsInput, BarUncheckedCreateWithoutBoostsInput>
    connectOrCreate?: BarCreateOrConnectWithoutBoostsInput
    upsert?: BarUpsertWithoutBoostsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutBoostsInput, BarUpdateWithoutBoostsInput>, BarUncheckedUpdateWithoutBoostsInput>
  }

  export type BoostMetricUpdateManyWithoutBoostNestedInput = {
    create?: XOR<BoostMetricCreateWithoutBoostInput, BoostMetricUncheckedCreateWithoutBoostInput> | BoostMetricCreateWithoutBoostInput[] | BoostMetricUncheckedCreateWithoutBoostInput[]
    connectOrCreate?: BoostMetricCreateOrConnectWithoutBoostInput | BoostMetricCreateOrConnectWithoutBoostInput[]
    upsert?: BoostMetricUpsertWithWhereUniqueWithoutBoostInput | BoostMetricUpsertWithWhereUniqueWithoutBoostInput[]
    createMany?: BoostMetricCreateManyBoostInputEnvelope
    set?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    disconnect?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    delete?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    connect?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    update?: BoostMetricUpdateWithWhereUniqueWithoutBoostInput | BoostMetricUpdateWithWhereUniqueWithoutBoostInput[]
    updateMany?: BoostMetricUpdateManyWithWhereWithoutBoostInput | BoostMetricUpdateManyWithWhereWithoutBoostInput[]
    deleteMany?: BoostMetricScalarWhereInput | BoostMetricScalarWhereInput[]
  }

  export type BoostMetricUncheckedUpdateManyWithoutBoostNestedInput = {
    create?: XOR<BoostMetricCreateWithoutBoostInput, BoostMetricUncheckedCreateWithoutBoostInput> | BoostMetricCreateWithoutBoostInput[] | BoostMetricUncheckedCreateWithoutBoostInput[]
    connectOrCreate?: BoostMetricCreateOrConnectWithoutBoostInput | BoostMetricCreateOrConnectWithoutBoostInput[]
    upsert?: BoostMetricUpsertWithWhereUniqueWithoutBoostInput | BoostMetricUpsertWithWhereUniqueWithoutBoostInput[]
    createMany?: BoostMetricCreateManyBoostInputEnvelope
    set?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    disconnect?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    delete?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    connect?: BoostMetricWhereUniqueInput | BoostMetricWhereUniqueInput[]
    update?: BoostMetricUpdateWithWhereUniqueWithoutBoostInput | BoostMetricUpdateWithWhereUniqueWithoutBoostInput[]
    updateMany?: BoostMetricUpdateManyWithWhereWithoutBoostInput | BoostMetricUpdateManyWithWhereWithoutBoostInput[]
    deleteMany?: BoostMetricScalarWhereInput | BoostMetricScalarWhereInput[]
  }

  export type BoostCreateNestedOneWithoutMetricsInput = {
    create?: XOR<BoostCreateWithoutMetricsInput, BoostUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: BoostCreateOrConnectWithoutMetricsInput
    connect?: BoostWhereUniqueInput
  }

  export type BoostUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<BoostCreateWithoutMetricsInput, BoostUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: BoostCreateOrConnectWithoutMetricsInput
    upsert?: BoostUpsertWithoutMetricsInput
    connect?: BoostWhereUniqueInput
    update?: XOR<XOR<BoostUpdateToOneWithWhereWithoutMetricsInput, BoostUpdateWithoutMetricsInput>, BoostUncheckedUpdateWithoutMetricsInput>
  }

  export type BarProductCreateNestedManyWithoutProductInput = {
    create?: XOR<BarProductCreateWithoutProductInput, BarProductUncheckedCreateWithoutProductInput> | BarProductCreateWithoutProductInput[] | BarProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutProductInput | BarProductCreateOrConnectWithoutProductInput[]
    createMany?: BarProductCreateManyProductInputEnvelope
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
  }

  export type BarProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<BarProductCreateWithoutProductInput, BarProductUncheckedCreateWithoutProductInput> | BarProductCreateWithoutProductInput[] | BarProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutProductInput | BarProductCreateOrConnectWithoutProductInput[]
    createMany?: BarProductCreateManyProductInputEnvelope
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
  }

  export type BarProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<BarProductCreateWithoutProductInput, BarProductUncheckedCreateWithoutProductInput> | BarProductCreateWithoutProductInput[] | BarProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutProductInput | BarProductCreateOrConnectWithoutProductInput[]
    upsert?: BarProductUpsertWithWhereUniqueWithoutProductInput | BarProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BarProductCreateManyProductInputEnvelope
    set?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    disconnect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    delete?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    update?: BarProductUpdateWithWhereUniqueWithoutProductInput | BarProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BarProductUpdateManyWithWhereWithoutProductInput | BarProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BarProductScalarWhereInput | BarProductScalarWhereInput[]
  }

  export type BarProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<BarProductCreateWithoutProductInput, BarProductUncheckedCreateWithoutProductInput> | BarProductCreateWithoutProductInput[] | BarProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BarProductCreateOrConnectWithoutProductInput | BarProductCreateOrConnectWithoutProductInput[]
    upsert?: BarProductUpsertWithWhereUniqueWithoutProductInput | BarProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BarProductCreateManyProductInputEnvelope
    set?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    disconnect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    delete?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    connect?: BarProductWhereUniqueInput | BarProductWhereUniqueInput[]
    update?: BarProductUpdateWithWhereUniqueWithoutProductInput | BarProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BarProductUpdateManyWithWhereWithoutProductInput | BarProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BarProductScalarWhereInput | BarProductScalarWhereInput[]
  }

  export type BarCreateNestedOneWithoutBarProductsInput = {
    create?: XOR<BarCreateWithoutBarProductsInput, BarUncheckedCreateWithoutBarProductsInput>
    connectOrCreate?: BarCreateOrConnectWithoutBarProductsInput
    connect?: BarWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBarProductsInput = {
    create?: XOR<ProductCreateWithoutBarProductsInput, ProductUncheckedCreateWithoutBarProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBarProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type InventoryCountCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCountCreateWithoutProductInput, InventoryCountUncheckedCreateWithoutProductInput> | InventoryCountCreateWithoutProductInput[] | InventoryCountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutProductInput | InventoryCountCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCountCreateManyProductInputEnvelope
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
  }

  export type InventoryScanDetectionCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutProductInput, InventoryScanDetectionUncheckedCreateWithoutProductInput> | InventoryScanDetectionCreateWithoutProductInput[] | InventoryScanDetectionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutProductInput | InventoryScanDetectionCreateOrConnectWithoutProductInput[]
    createMany?: InventoryScanDetectionCreateManyProductInputEnvelope
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
  }

  export type InventoryCountUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCountCreateWithoutProductInput, InventoryCountUncheckedCreateWithoutProductInput> | InventoryCountCreateWithoutProductInput[] | InventoryCountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutProductInput | InventoryCountCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCountCreateManyProductInputEnvelope
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
  }

  export type InventoryScanDetectionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutProductInput, InventoryScanDetectionUncheckedCreateWithoutProductInput> | InventoryScanDetectionCreateWithoutProductInput[] | InventoryScanDetectionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutProductInput | InventoryScanDetectionCreateOrConnectWithoutProductInput[]
    createMany?: InventoryScanDetectionCreateManyProductInputEnvelope
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
  }

  export type BarUpdateOneRequiredWithoutBarProductsNestedInput = {
    create?: XOR<BarCreateWithoutBarProductsInput, BarUncheckedCreateWithoutBarProductsInput>
    connectOrCreate?: BarCreateOrConnectWithoutBarProductsInput
    upsert?: BarUpsertWithoutBarProductsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutBarProductsInput, BarUpdateWithoutBarProductsInput>, BarUncheckedUpdateWithoutBarProductsInput>
  }

  export type ProductUpdateOneWithoutBarProductsNestedInput = {
    create?: XOR<ProductCreateWithoutBarProductsInput, ProductUncheckedCreateWithoutBarProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBarProductsInput
    upsert?: ProductUpsertWithoutBarProductsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBarProductsInput, ProductUpdateWithoutBarProductsInput>, ProductUncheckedUpdateWithoutBarProductsInput>
  }

  export type InventoryCountUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCountCreateWithoutProductInput, InventoryCountUncheckedCreateWithoutProductInput> | InventoryCountCreateWithoutProductInput[] | InventoryCountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutProductInput | InventoryCountCreateOrConnectWithoutProductInput[]
    upsert?: InventoryCountUpsertWithWhereUniqueWithoutProductInput | InventoryCountUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCountCreateManyProductInputEnvelope
    set?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    disconnect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    delete?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    update?: InventoryCountUpdateWithWhereUniqueWithoutProductInput | InventoryCountUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryCountUpdateManyWithWhereWithoutProductInput | InventoryCountUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryCountScalarWhereInput | InventoryCountScalarWhereInput[]
  }

  export type InventoryScanDetectionUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutProductInput, InventoryScanDetectionUncheckedCreateWithoutProductInput> | InventoryScanDetectionCreateWithoutProductInput[] | InventoryScanDetectionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutProductInput | InventoryScanDetectionCreateOrConnectWithoutProductInput[]
    upsert?: InventoryScanDetectionUpsertWithWhereUniqueWithoutProductInput | InventoryScanDetectionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryScanDetectionCreateManyProductInputEnvelope
    set?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    disconnect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    delete?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    update?: InventoryScanDetectionUpdateWithWhereUniqueWithoutProductInput | InventoryScanDetectionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryScanDetectionUpdateManyWithWhereWithoutProductInput | InventoryScanDetectionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScanDetectionScalarWhereInput | InventoryScanDetectionScalarWhereInput[]
  }

  export type InventoryCountUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCountCreateWithoutProductInput, InventoryCountUncheckedCreateWithoutProductInput> | InventoryCountCreateWithoutProductInput[] | InventoryCountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCountCreateOrConnectWithoutProductInput | InventoryCountCreateOrConnectWithoutProductInput[]
    upsert?: InventoryCountUpsertWithWhereUniqueWithoutProductInput | InventoryCountUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCountCreateManyProductInputEnvelope
    set?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    disconnect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    delete?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    connect?: InventoryCountWhereUniqueInput | InventoryCountWhereUniqueInput[]
    update?: InventoryCountUpdateWithWhereUniqueWithoutProductInput | InventoryCountUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryCountUpdateManyWithWhereWithoutProductInput | InventoryCountUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryCountScalarWhereInput | InventoryCountScalarWhereInput[]
  }

  export type InventoryScanDetectionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutProductInput, InventoryScanDetectionUncheckedCreateWithoutProductInput> | InventoryScanDetectionCreateWithoutProductInput[] | InventoryScanDetectionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutProductInput | InventoryScanDetectionCreateOrConnectWithoutProductInput[]
    upsert?: InventoryScanDetectionUpsertWithWhereUniqueWithoutProductInput | InventoryScanDetectionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryScanDetectionCreateManyProductInputEnvelope
    set?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    disconnect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    delete?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    update?: InventoryScanDetectionUpdateWithWhereUniqueWithoutProductInput | InventoryScanDetectionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryScanDetectionUpdateManyWithWhereWithoutProductInput | InventoryScanDetectionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScanDetectionScalarWhereInput | InventoryScanDetectionScalarWhereInput[]
  }

  export type BarCreateNestedOneWithoutInventoryScanSessionsInput = {
    create?: XOR<BarCreateWithoutInventoryScanSessionsInput, BarUncheckedCreateWithoutInventoryScanSessionsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryScanSessionsInput
    connect?: BarWhereUniqueInput
  }

  export type InventoryScanDetectionCreateNestedManyWithoutSessionInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutSessionInput, InventoryScanDetectionUncheckedCreateWithoutSessionInput> | InventoryScanDetectionCreateWithoutSessionInput[] | InventoryScanDetectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutSessionInput | InventoryScanDetectionCreateOrConnectWithoutSessionInput[]
    createMany?: InventoryScanDetectionCreateManySessionInputEnvelope
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
  }

  export type InventoryScanDetectionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutSessionInput, InventoryScanDetectionUncheckedCreateWithoutSessionInput> | InventoryScanDetectionCreateWithoutSessionInput[] | InventoryScanDetectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutSessionInput | InventoryScanDetectionCreateOrConnectWithoutSessionInput[]
    createMany?: InventoryScanDetectionCreateManySessionInputEnvelope
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
  }

  export type BarUpdateOneRequiredWithoutInventoryScanSessionsNestedInput = {
    create?: XOR<BarCreateWithoutInventoryScanSessionsInput, BarUncheckedCreateWithoutInventoryScanSessionsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryScanSessionsInput
    upsert?: BarUpsertWithoutInventoryScanSessionsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutInventoryScanSessionsInput, BarUpdateWithoutInventoryScanSessionsInput>, BarUncheckedUpdateWithoutInventoryScanSessionsInput>
  }

  export type InventoryScanDetectionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutSessionInput, InventoryScanDetectionUncheckedCreateWithoutSessionInput> | InventoryScanDetectionCreateWithoutSessionInput[] | InventoryScanDetectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutSessionInput | InventoryScanDetectionCreateOrConnectWithoutSessionInput[]
    upsert?: InventoryScanDetectionUpsertWithWhereUniqueWithoutSessionInput | InventoryScanDetectionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InventoryScanDetectionCreateManySessionInputEnvelope
    set?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    disconnect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    delete?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    update?: InventoryScanDetectionUpdateWithWhereUniqueWithoutSessionInput | InventoryScanDetectionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InventoryScanDetectionUpdateManyWithWhereWithoutSessionInput | InventoryScanDetectionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InventoryScanDetectionScalarWhereInput | InventoryScanDetectionScalarWhereInput[]
  }

  export type InventoryScanDetectionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InventoryScanDetectionCreateWithoutSessionInput, InventoryScanDetectionUncheckedCreateWithoutSessionInput> | InventoryScanDetectionCreateWithoutSessionInput[] | InventoryScanDetectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InventoryScanDetectionCreateOrConnectWithoutSessionInput | InventoryScanDetectionCreateOrConnectWithoutSessionInput[]
    upsert?: InventoryScanDetectionUpsertWithWhereUniqueWithoutSessionInput | InventoryScanDetectionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InventoryScanDetectionCreateManySessionInputEnvelope
    set?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    disconnect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    delete?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    connect?: InventoryScanDetectionWhereUniqueInput | InventoryScanDetectionWhereUniqueInput[]
    update?: InventoryScanDetectionUpdateWithWhereUniqueWithoutSessionInput | InventoryScanDetectionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InventoryScanDetectionUpdateManyWithWhereWithoutSessionInput | InventoryScanDetectionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InventoryScanDetectionScalarWhereInput | InventoryScanDetectionScalarWhereInput[]
  }

  export type InventoryScanSessionCreateNestedOneWithoutDetectionsInput = {
    create?: XOR<InventoryScanSessionCreateWithoutDetectionsInput, InventoryScanSessionUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: InventoryScanSessionCreateOrConnectWithoutDetectionsInput
    connect?: InventoryScanSessionWhereUniqueInput
  }

  export type BarProductCreateNestedOneWithoutDetectionsInput = {
    create?: XOR<BarProductCreateWithoutDetectionsInput, BarProductUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: BarProductCreateOrConnectWithoutDetectionsInput
    connect?: BarProductWhereUniqueInput
  }

  export type InventoryScanSessionUpdateOneRequiredWithoutDetectionsNestedInput = {
    create?: XOR<InventoryScanSessionCreateWithoutDetectionsInput, InventoryScanSessionUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: InventoryScanSessionCreateOrConnectWithoutDetectionsInput
    upsert?: InventoryScanSessionUpsertWithoutDetectionsInput
    connect?: InventoryScanSessionWhereUniqueInput
    update?: XOR<XOR<InventoryScanSessionUpdateToOneWithWhereWithoutDetectionsInput, InventoryScanSessionUpdateWithoutDetectionsInput>, InventoryScanSessionUncheckedUpdateWithoutDetectionsInput>
  }

  export type BarProductUpdateOneWithoutDetectionsNestedInput = {
    create?: XOR<BarProductCreateWithoutDetectionsInput, BarProductUncheckedCreateWithoutDetectionsInput>
    connectOrCreate?: BarProductCreateOrConnectWithoutDetectionsInput
    upsert?: BarProductUpsertWithoutDetectionsInput
    disconnect?: BarProductWhereInput | boolean
    delete?: BarProductWhereInput | boolean
    connect?: BarProductWhereUniqueInput
    update?: XOR<XOR<BarProductUpdateToOneWithWhereWithoutDetectionsInput, BarProductUpdateWithoutDetectionsInput>, BarProductUncheckedUpdateWithoutDetectionsInput>
  }

  export type BarCreateNestedOneWithoutInventoryCountsInput = {
    create?: XOR<BarCreateWithoutInventoryCountsInput, BarUncheckedCreateWithoutInventoryCountsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryCountsInput
    connect?: BarWhereUniqueInput
  }

  export type BarProductCreateNestedOneWithoutCountsInput = {
    create?: XOR<BarProductCreateWithoutCountsInput, BarProductUncheckedCreateWithoutCountsInput>
    connectOrCreate?: BarProductCreateOrConnectWithoutCountsInput
    connect?: BarProductWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BarUpdateOneRequiredWithoutInventoryCountsNestedInput = {
    create?: XOR<BarCreateWithoutInventoryCountsInput, BarUncheckedCreateWithoutInventoryCountsInput>
    connectOrCreate?: BarCreateOrConnectWithoutInventoryCountsInput
    upsert?: BarUpsertWithoutInventoryCountsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutInventoryCountsInput, BarUpdateWithoutInventoryCountsInput>, BarUncheckedUpdateWithoutInventoryCountsInput>
  }

  export type BarProductUpdateOneRequiredWithoutCountsNestedInput = {
    create?: XOR<BarProductCreateWithoutCountsInput, BarProductUncheckedCreateWithoutCountsInput>
    connectOrCreate?: BarProductCreateOrConnectWithoutCountsInput
    upsert?: BarProductUpsertWithoutCountsInput
    connect?: BarProductWhereUniqueInput
    update?: XOR<XOR<BarProductUpdateToOneWithWhereWithoutCountsInput, BarProductUpdateWithoutCountsInput>, BarProductUncheckedUpdateWithoutCountsInput>
  }

  export type BarCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<BarCreateWithoutAdminNotesInput, BarUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: BarCreateOrConnectWithoutAdminNotesInput
    connect?: BarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminNotesInput
    connect?: UserWhereUniqueInput
  }

  export type BarUpdateOneWithoutAdminNotesNestedInput = {
    create?: XOR<BarCreateWithoutAdminNotesInput, BarUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: BarCreateOrConnectWithoutAdminNotesInput
    upsert?: BarUpsertWithoutAdminNotesInput
    disconnect?: BarWhereInput | boolean
    delete?: BarWhereInput | boolean
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutAdminNotesInput, BarUpdateWithoutAdminNotesInput>, BarUncheckedUpdateWithoutAdminNotesInput>
  }

  export type UserUpdateOneWithoutAdminNotesNestedInput = {
    create?: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminNotesInput
    upsert?: UserUpsertWithoutAdminNotesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminNotesInput, UserUpdateWithoutAdminNotesInput>, UserUncheckedUpdateWithoutAdminNotesInput>
  }

  export type BarCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<BarCreateWithoutSupportTicketsInput, BarUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: BarCreateOrConnectWithoutSupportTicketsInput
    connect?: BarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type BarUpdateOneWithoutSupportTicketsNestedInput = {
    create?: XOR<BarCreateWithoutSupportTicketsInput, BarUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: BarCreateOrConnectWithoutSupportTicketsInput
    upsert?: BarUpsertWithoutSupportTicketsInput
    disconnect?: BarWhereInput | boolean
    delete?: BarWhereInput | boolean
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutSupportTicketsInput, BarUpdateWithoutSupportTicketsInput>, BarUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateOneWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type BarCreateNestedOneWithoutStaticOfferingsInput = {
    create?: XOR<BarCreateWithoutStaticOfferingsInput, BarUncheckedCreateWithoutStaticOfferingsInput>
    connectOrCreate?: BarCreateOrConnectWithoutStaticOfferingsInput
    connect?: BarWhereUniqueInput
  }

  export type BarUpdateOneRequiredWithoutStaticOfferingsNestedInput = {
    create?: XOR<BarCreateWithoutStaticOfferingsInput, BarUncheckedCreateWithoutStaticOfferingsInput>
    connectOrCreate?: BarCreateOrConnectWithoutStaticOfferingsInput
    upsert?: BarUpsertWithoutStaticOfferingsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutStaticOfferingsInput, BarUpdateWithoutStaticOfferingsInput>, BarUncheckedUpdateWithoutStaticOfferingsInput>
  }

  export type DrinkSpecialCreatedaysOfWeekInput = {
    set: number[]
  }

  export type BarCreateNestedOneWithoutDrinkSpecialsInput = {
    create?: XOR<BarCreateWithoutDrinkSpecialsInput, BarUncheckedCreateWithoutDrinkSpecialsInput>
    connectOrCreate?: BarCreateOrConnectWithoutDrinkSpecialsInput
    connect?: BarWhereUniqueInput
  }

  export type DrinkSpecialUpdatedaysOfWeekInput = {
    set?: number[]
    push?: number | number[]
  }

  export type BarUpdateOneRequiredWithoutDrinkSpecialsNestedInput = {
    create?: XOR<BarCreateWithoutDrinkSpecialsInput, BarUncheckedCreateWithoutDrinkSpecialsInput>
    connectOrCreate?: BarCreateOrConnectWithoutDrinkSpecialsInput
    upsert?: BarUpsertWithoutDrinkSpecialsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutDrinkSpecialsInput, BarUpdateWithoutDrinkSpecialsInput>, BarUncheckedUpdateWithoutDrinkSpecialsInput>
  }

  export type FoodOfferingCreatespecialDaysInput = {
    set: number[]
  }

  export type BarCreateNestedOneWithoutFoodOfferingsInput = {
    create?: XOR<BarCreateWithoutFoodOfferingsInput, BarUncheckedCreateWithoutFoodOfferingsInput>
    connectOrCreate?: BarCreateOrConnectWithoutFoodOfferingsInput
    connect?: BarWhereUniqueInput
  }

  export type FoodOfferingUpdatespecialDaysInput = {
    set?: number[]
    push?: number | number[]
  }

  export type BarUpdateOneRequiredWithoutFoodOfferingsNestedInput = {
    create?: XOR<BarCreateWithoutFoodOfferingsInput, BarUncheckedCreateWithoutFoodOfferingsInput>
    connectOrCreate?: BarCreateOrConnectWithoutFoodOfferingsInput
    upsert?: BarUpsertWithoutFoodOfferingsInput
    connect?: BarWhereUniqueInput
    update?: XOR<XOR<BarUpdateToOneWithWhereWithoutFoodOfferingsInput, BarUpdateWithoutFoodOfferingsInput>, BarUncheckedUpdateWithoutFoodOfferingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOwnerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerRole | EnumOwnerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerRoleFilter<$PrismaModel> | $Enums.OwnerRole
  }

  export type NestedEnumOwnerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerRole | EnumOwnerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerRole[] | ListEnumOwnerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerRoleWithAggregatesFilter<$PrismaModel> | $Enums.OwnerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnerRoleFilter<$PrismaModel>
    _max?: NestedEnumOwnerRoleFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumRecurrenceFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel>
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFilter<$PrismaModel> | $Enums.Recurrence
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumRecurrenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel>
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceWithAggregatesFilter<$PrismaModel> | $Enums.Recurrence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumRecurrenceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceNullableFilter<$PrismaModel> | $Enums.Recurrence | null
  }

  export type NestedEnumRecurrenceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Recurrence | EnumRecurrenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Recurrence[] | ListEnumRecurrenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceNullableWithAggregatesFilter<$PrismaModel> | $Enums.Recurrence | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryRequestStatus | EnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryRequestStatusFilter<$PrismaModel> | $Enums.CategoryRequestStatus
  }

  export type NestedEnumCategoryRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryRequestStatus | EnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryRequestStatus[] | ListEnumCategoryRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.CategoryRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumCategoryRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
  }

  export type NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanNullableFilter<$PrismaModel>
  }

  export type NestedEnumBadgeTierFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeTier | EnumBadgeTierFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTierFilter<$PrismaModel> | $Enums.BadgeTier
  }

  export type NestedEnumBadgeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeCategory | EnumBadgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeCategoryFilter<$PrismaModel> | $Enums.BadgeCategory
  }

  export type NestedEnumBadgeTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeTier | EnumBadgeTierFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeTier[] | ListEnumBadgeTierFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeTierWithAggregatesFilter<$PrismaModel> | $Enums.BadgeTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeTierFilter<$PrismaModel>
    _max?: NestedEnumBadgeTierFilter<$PrismaModel>
  }

  export type NestedEnumBadgeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeCategory | EnumBadgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeCategory[] | ListEnumBadgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BadgeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeCategoryFilter<$PrismaModel>
    _max?: NestedEnumBadgeCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBarMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.BarMemberRole | EnumBarMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumBarMemberRoleFilter<$PrismaModel> | $Enums.BarMemberRole
  }

  export type NestedEnumBarMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BarMemberRole | EnumBarMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BarMemberRole[] | ListEnumBarMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumBarMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.BarMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBarMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumBarMemberRoleFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    barId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BarVisitCreateWithoutUserInput = {
    id?: string
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutVisitsInput
  }

  export type BarVisitUncheckedCreateWithoutUserInput = {
    id?: string
    barId: string
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
  }

  export type BarVisitCreateOrConnectWithoutUserInput = {
    where: BarVisitWhereUniqueInput
    create: XOR<BarVisitCreateWithoutUserInput, BarVisitUncheckedCreateWithoutUserInput>
  }

  export type BarVisitCreateManyUserInputEnvelope = {
    data: BarVisitCreateManyUserInput | BarVisitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryImportCreateWithoutCreatedByInput = {
    id?: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryImportsInput
  }

  export type InventoryImportUncheckedCreateWithoutCreatedByInput = {
    id?: string
    barId: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type InventoryImportCreateOrConnectWithoutCreatedByInput = {
    where: InventoryImportWhereUniqueInput
    create: XOR<InventoryImportCreateWithoutCreatedByInput, InventoryImportUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryImportCreateManyCreatedByInputEnvelope = {
    data: InventoryImportCreateManyCreatedByInput | InventoryImportCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUsageCreateWithoutUserInput = {
    id?: string
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutShiftUsagesInput
    items?: ShiftUsageItemCreateNestedManyWithoutShiftUsageInput
  }

  export type ShiftUsageUncheckedCreateWithoutUserInput = {
    id?: string
    barId: string
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    items?: ShiftUsageItemUncheckedCreateNestedManyWithoutShiftUsageInput
  }

  export type ShiftUsageCreateOrConnectWithoutUserInput = {
    where: ShiftUsageWhereUniqueInput
    create: XOR<ShiftUsageCreateWithoutUserInput, ShiftUsageUncheckedCreateWithoutUserInput>
  }

  export type ShiftUsageCreateManyUserInputEnvelope = {
    data: ShiftUsageCreateManyUserInput | ShiftUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventorySnapshotCreateWithoutUserInput = {
    id?: string
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventorySnapshotsInput
    items?: InventorySnapshotItemCreateNestedManyWithoutSnapshotInput
  }

  export type InventorySnapshotUncheckedCreateWithoutUserInput = {
    id?: string
    barId: string
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    items?: InventorySnapshotItemUncheckedCreateNestedManyWithoutSnapshotInput
  }

  export type InventorySnapshotCreateOrConnectWithoutUserInput = {
    where: InventorySnapshotWhereUniqueInput
    create: XOR<InventorySnapshotCreateWithoutUserInput, InventorySnapshotUncheckedCreateWithoutUserInput>
  }

  export type InventorySnapshotCreateManyUserInputEnvelope = {
    data: InventorySnapshotCreateManyUserInput | InventorySnapshotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminNoteCreateWithoutUserInput = {
    id?: string
    adminEmail: string
    content: string
    createdAt?: Date | string
    bar?: BarCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutUserInput = {
    id?: string
    adminEmail: string
    barId?: string | null
    content: string
    createdAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutUserInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutUserInput, AdminNoteUncheckedCreateWithoutUserInput>
  }

  export type AdminNoteCreateManyUserInputEnvelope = {
    data: AdminNoteCreateManyUserInput | AdminNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    userEmail: string
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bar?: BarCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    barId?: string | null
    userEmail: string
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    barId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type BarVisitUpsertWithWhereUniqueWithoutUserInput = {
    where: BarVisitWhereUniqueInput
    update: XOR<BarVisitUpdateWithoutUserInput, BarVisitUncheckedUpdateWithoutUserInput>
    create: XOR<BarVisitCreateWithoutUserInput, BarVisitUncheckedCreateWithoutUserInput>
  }

  export type BarVisitUpdateWithWhereUniqueWithoutUserInput = {
    where: BarVisitWhereUniqueInput
    data: XOR<BarVisitUpdateWithoutUserInput, BarVisitUncheckedUpdateWithoutUserInput>
  }

  export type BarVisitUpdateManyWithWhereWithoutUserInput = {
    where: BarVisitScalarWhereInput
    data: XOR<BarVisitUpdateManyMutationInput, BarVisitUncheckedUpdateManyWithoutUserInput>
  }

  export type BarVisitScalarWhereInput = {
    AND?: BarVisitScalarWhereInput | BarVisitScalarWhereInput[]
    OR?: BarVisitScalarWhereInput[]
    NOT?: BarVisitScalarWhereInput | BarVisitScalarWhereInput[]
    id?: StringFilter<"BarVisit"> | string
    barId?: StringFilter<"BarVisit"> | string
    userId?: StringNullableFilter<"BarVisit"> | string | null
    source?: StringFilter<"BarVisit"> | string
    verificationMethod?: StringFilter<"BarVisit"> | string
    clickId?: StringNullableFilter<"BarVisit"> | string | null
    promoCodeId?: StringNullableFilter<"BarVisit"> | string | null
    metadata?: JsonNullableFilter<"BarVisit">
    visitedAt?: DateTimeFilter<"BarVisit"> | Date | string
    createdAt?: DateTimeFilter<"BarVisit"> | Date | string
  }

  export type InventoryImportUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryImportWhereUniqueInput
    update: XOR<InventoryImportUpdateWithoutCreatedByInput, InventoryImportUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InventoryImportCreateWithoutCreatedByInput, InventoryImportUncheckedCreateWithoutCreatedByInput>
  }

  export type InventoryImportUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InventoryImportWhereUniqueInput
    data: XOR<InventoryImportUpdateWithoutCreatedByInput, InventoryImportUncheckedUpdateWithoutCreatedByInput>
  }

  export type InventoryImportUpdateManyWithWhereWithoutCreatedByInput = {
    where: InventoryImportScalarWhereInput
    data: XOR<InventoryImportUpdateManyMutationInput, InventoryImportUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InventoryImportScalarWhereInput = {
    AND?: InventoryImportScalarWhereInput | InventoryImportScalarWhereInput[]
    OR?: InventoryImportScalarWhereInput[]
    NOT?: InventoryImportScalarWhereInput | InventoryImportScalarWhereInput[]
    id?: StringFilter<"InventoryImport"> | string
    barId?: StringFilter<"InventoryImport"> | string
    fileName?: StringFilter<"InventoryImport"> | string
    rowsImported?: IntFilter<"InventoryImport"> | number
    mapping?: JsonNullableFilter<"InventoryImport">
    createdById?: StringNullableFilter<"InventoryImport"> | string | null
    createdAt?: DateTimeFilter<"InventoryImport"> | Date | string
  }

  export type ShiftUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: ShiftUsageWhereUniqueInput
    update: XOR<ShiftUsageUpdateWithoutUserInput, ShiftUsageUncheckedUpdateWithoutUserInput>
    create: XOR<ShiftUsageCreateWithoutUserInput, ShiftUsageUncheckedCreateWithoutUserInput>
  }

  export type ShiftUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: ShiftUsageWhereUniqueInput
    data: XOR<ShiftUsageUpdateWithoutUserInput, ShiftUsageUncheckedUpdateWithoutUserInput>
  }

  export type ShiftUsageUpdateManyWithWhereWithoutUserInput = {
    where: ShiftUsageScalarWhereInput
    data: XOR<ShiftUsageUpdateManyMutationInput, ShiftUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type ShiftUsageScalarWhereInput = {
    AND?: ShiftUsageScalarWhereInput | ShiftUsageScalarWhereInput[]
    OR?: ShiftUsageScalarWhereInput[]
    NOT?: ShiftUsageScalarWhereInput | ShiftUsageScalarWhereInput[]
    id?: StringFilter<"ShiftUsage"> | string
    barId?: StringFilter<"ShiftUsage"> | string
    userId?: StringNullableFilter<"ShiftUsage"> | string | null
    shiftTime?: DateTimeFilter<"ShiftUsage"> | Date | string
    notes?: StringNullableFilter<"ShiftUsage"> | string | null
    createdAt?: DateTimeFilter<"ShiftUsage"> | Date | string
  }

  export type InventorySnapshotUpsertWithWhereUniqueWithoutUserInput = {
    where: InventorySnapshotWhereUniqueInput
    update: XOR<InventorySnapshotUpdateWithoutUserInput, InventorySnapshotUncheckedUpdateWithoutUserInput>
    create: XOR<InventorySnapshotCreateWithoutUserInput, InventorySnapshotUncheckedCreateWithoutUserInput>
  }

  export type InventorySnapshotUpdateWithWhereUniqueWithoutUserInput = {
    where: InventorySnapshotWhereUniqueInput
    data: XOR<InventorySnapshotUpdateWithoutUserInput, InventorySnapshotUncheckedUpdateWithoutUserInput>
  }

  export type InventorySnapshotUpdateManyWithWhereWithoutUserInput = {
    where: InventorySnapshotScalarWhereInput
    data: XOR<InventorySnapshotUpdateManyMutationInput, InventorySnapshotUncheckedUpdateManyWithoutUserInput>
  }

  export type InventorySnapshotScalarWhereInput = {
    AND?: InventorySnapshotScalarWhereInput | InventorySnapshotScalarWhereInput[]
    OR?: InventorySnapshotScalarWhereInput[]
    NOT?: InventorySnapshotScalarWhereInput | InventorySnapshotScalarWhereInput[]
    id?: StringFilter<"InventorySnapshot"> | string
    barId?: StringFilter<"InventorySnapshot"> | string
    userId?: StringNullableFilter<"InventorySnapshot"> | string | null
    snapshotDate?: DateTimeFilter<"InventorySnapshot"> | Date | string
    notes?: StringNullableFilter<"InventorySnapshot"> | string | null
    createdAt?: DateTimeFilter<"InventorySnapshot"> | Date | string
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutUserInput, AdminNoteUncheckedUpdateWithoutUserInput>
    create: XOR<AdminNoteCreateWithoutUserInput, AdminNoteUncheckedCreateWithoutUserInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutUserInput, AdminNoteUncheckedUpdateWithoutUserInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutUserInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminNoteScalarWhereInput = {
    AND?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
    OR?: AdminNoteScalarWhereInput[]
    NOT?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
    id?: StringFilter<"AdminNote"> | string
    adminEmail?: StringFilter<"AdminNote"> | string
    barId?: StringNullableFilter<"AdminNote"> | string | null
    userId?: StringNullableFilter<"AdminNote"> | string | null
    content?: StringFilter<"AdminNote"> | string
    createdAt?: DateTimeFilter<"AdminNote"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    barId?: StringNullableFilter<"SupportTicket"> | string | null
    userEmail?: StringFilter<"SupportTicket"> | string
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    subject?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutOwnerInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutOwnerInput, BarUncheckedCreateWithoutOwnerInput>
  }

  export type BarCreateManyOwnerInputEnvelope = {
    data: BarCreateManyOwnerInput | BarCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutOwnerInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    paypalCustomerId?: string | null
    paypalSubscriptionId?: string | null
    priceId?: string | null
    currentPeriodEnd?: Date | string | null
    trialEndsAt?: Date | string | null
    trialReminderSentAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutOwnerInput = {
    id?: string
    plan: $Enums.SubscriptionPlan
    status?: $Enums.SubscriptionStatus
    paypalCustomerId?: string | null
    paypalSubscriptionId?: string | null
    priceId?: string | null
    currentPeriodEnd?: Date | string | null
    trialEndsAt?: Date | string | null
    trialReminderSentAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutOwnerInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutOwnerInput, SubscriptionUncheckedCreateWithoutOwnerInput>
  }

  export type BarLicenseCreateWithoutOwnerInput = {
    id?: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutBarLicensesInput
  }

  export type BarLicenseUncheckedCreateWithoutOwnerInput = {
    id?: string
    barId: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarLicenseCreateOrConnectWithoutOwnerInput = {
    where: BarLicenseWhereUniqueInput
    create: XOR<BarLicenseCreateWithoutOwnerInput, BarLicenseUncheckedCreateWithoutOwnerInput>
  }

  export type BarLicenseCreateManyOwnerInputEnvelope = {
    data: BarLicenseCreateManyOwnerInput | BarLicenseCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PromoRedemptionCreateWithoutOwnerInput = {
    id?: string
    redeemedAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutRedemptionsInput
  }

  export type PromoRedemptionUncheckedCreateWithoutOwnerInput = {
    id?: string
    promoCodeId: string
    redeemedAt?: Date | string
  }

  export type PromoRedemptionCreateOrConnectWithoutOwnerInput = {
    where: PromoRedemptionWhereUniqueInput
    create: XOR<PromoRedemptionCreateWithoutOwnerInput, PromoRedemptionUncheckedCreateWithoutOwnerInput>
  }

  export type PromoRedemptionCreateManyOwnerInputEnvelope = {
    data: PromoRedemptionCreateManyOwnerInput | PromoRedemptionCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CategoryRequestCreateWithoutOwnerInput = {
    id?: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutCategoryRequestsInput
  }

  export type CategoryRequestUncheckedCreateWithoutOwnerInput = {
    id?: string
    barId: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
  }

  export type CategoryRequestCreateOrConnectWithoutOwnerInput = {
    where: CategoryRequestWhereUniqueInput
    create: XOR<CategoryRequestCreateWithoutOwnerInput, CategoryRequestUncheckedCreateWithoutOwnerInput>
  }

  export type CategoryRequestCreateManyOwnerInputEnvelope = {
    data: CategoryRequestCreateManyOwnerInput | CategoryRequestCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OwnerPasswordResetCreateWithoutOwnerInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OwnerPasswordResetUncheckedCreateWithoutOwnerInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OwnerPasswordResetCreateOrConnectWithoutOwnerInput = {
    where: OwnerPasswordResetWhereUniqueInput
    create: XOR<OwnerPasswordResetCreateWithoutOwnerInput, OwnerPasswordResetUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerPasswordResetCreateManyOwnerInputEnvelope = {
    data: OwnerPasswordResetCreateManyOwnerInput | OwnerPasswordResetCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BarWhereUniqueInput
    update: XOR<BarUpdateWithoutOwnerInput, BarUncheckedUpdateWithoutOwnerInput>
    create: XOR<BarCreateWithoutOwnerInput, BarUncheckedCreateWithoutOwnerInput>
  }

  export type BarUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BarWhereUniqueInput
    data: XOR<BarUpdateWithoutOwnerInput, BarUncheckedUpdateWithoutOwnerInput>
  }

  export type BarUpdateManyWithWhereWithoutOwnerInput = {
    where: BarScalarWhereInput
    data: XOR<BarUpdateManyMutationInput, BarUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BarScalarWhereInput = {
    AND?: BarScalarWhereInput | BarScalarWhereInput[]
    OR?: BarScalarWhereInput[]
    NOT?: BarScalarWhereInput | BarScalarWhereInput[]
    id?: StringFilter<"Bar"> | string
    ownerId?: StringFilter<"Bar"> | string
    name?: StringFilter<"Bar"> | string
    slug?: StringFilter<"Bar"> | string
    description?: StringNullableFilter<"Bar"> | string | null
    address?: StringFilter<"Bar"> | string
    city?: StringFilter<"Bar"> | string
    cityNormalized?: StringFilter<"Bar"> | string
    state?: StringFilter<"Bar"> | string
    zipCode?: StringFilter<"Bar"> | string
    barType?: StringNullableFilter<"Bar"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"Bar"> | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFilter<"Bar"> | boolean
    checkInReward?: StringNullableFilter<"Bar"> | string | null
    neighborhood?: StringNullableFilter<"Bar"> | string | null
    neighborhoodNormalized?: StringNullableFilter<"Bar"> | string | null
    latitude?: FloatFilter<"Bar"> | number
    longitude?: FloatFilter<"Bar"> | number
    phone?: StringNullableFilter<"Bar"> | string | null
    website?: StringNullableFilter<"Bar"> | string | null
    logo?: StringNullableFilter<"Bar"> | string | null
    photos?: StringNullableListFilter<"Bar">
    hours?: JsonNullableFilter<"Bar">
    isActive?: BoolFilter<"Bar"> | boolean
    isPublished?: BoolFilter<"Bar"> | boolean
    publishedAt?: DateTimeNullableFilter<"Bar"> | Date | string | null
    createdAt?: DateTimeFilter<"Bar"> | Date | string
    updatedAt?: DateTimeFilter<"Bar"> | Date | string
    profileViews?: IntFilter<"Bar"> | number
    searchAppearances?: IntFilter<"Bar"> | number
  }

  export type SubscriptionUpsertWithoutOwnerInput = {
    update: XOR<SubscriptionUpdateWithoutOwnerInput, SubscriptionUncheckedUpdateWithoutOwnerInput>
    create: XOR<SubscriptionCreateWithoutOwnerInput, SubscriptionUncheckedCreateWithoutOwnerInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutOwnerInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutOwnerInput, SubscriptionUncheckedUpdateWithoutOwnerInput>
  }

  export type SubscriptionUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    paypalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    paypalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialReminderSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarLicenseUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BarLicenseWhereUniqueInput
    update: XOR<BarLicenseUpdateWithoutOwnerInput, BarLicenseUncheckedUpdateWithoutOwnerInput>
    create: XOR<BarLicenseCreateWithoutOwnerInput, BarLicenseUncheckedCreateWithoutOwnerInput>
  }

  export type BarLicenseUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BarLicenseWhereUniqueInput
    data: XOR<BarLicenseUpdateWithoutOwnerInput, BarLicenseUncheckedUpdateWithoutOwnerInput>
  }

  export type BarLicenseUpdateManyWithWhereWithoutOwnerInput = {
    where: BarLicenseScalarWhereInput
    data: XOR<BarLicenseUpdateManyMutationInput, BarLicenseUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BarLicenseScalarWhereInput = {
    AND?: BarLicenseScalarWhereInput | BarLicenseScalarWhereInput[]
    OR?: BarLicenseScalarWhereInput[]
    NOT?: BarLicenseScalarWhereInput | BarLicenseScalarWhereInput[]
    id?: StringFilter<"BarLicense"> | string
    barId?: StringFilter<"BarLicense"> | string
    ownerId?: StringFilter<"BarLicense"> | string
    status?: StringFilter<"BarLicense"> | string
    priceCents?: IntFilter<"BarLicense"> | number
    currency?: StringFilter<"BarLicense"> | string
    billingCycle?: StringFilter<"BarLicense"> | string
    externalId?: StringNullableFilter<"BarLicense"> | string | null
    createdAt?: DateTimeFilter<"BarLicense"> | Date | string
    updatedAt?: DateTimeFilter<"BarLicense"> | Date | string
  }

  export type PromoRedemptionUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PromoRedemptionWhereUniqueInput
    update: XOR<PromoRedemptionUpdateWithoutOwnerInput, PromoRedemptionUncheckedUpdateWithoutOwnerInput>
    create: XOR<PromoRedemptionCreateWithoutOwnerInput, PromoRedemptionUncheckedCreateWithoutOwnerInput>
  }

  export type PromoRedemptionUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PromoRedemptionWhereUniqueInput
    data: XOR<PromoRedemptionUpdateWithoutOwnerInput, PromoRedemptionUncheckedUpdateWithoutOwnerInput>
  }

  export type PromoRedemptionUpdateManyWithWhereWithoutOwnerInput = {
    where: PromoRedemptionScalarWhereInput
    data: XOR<PromoRedemptionUpdateManyMutationInput, PromoRedemptionUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PromoRedemptionScalarWhereInput = {
    AND?: PromoRedemptionScalarWhereInput | PromoRedemptionScalarWhereInput[]
    OR?: PromoRedemptionScalarWhereInput[]
    NOT?: PromoRedemptionScalarWhereInput | PromoRedemptionScalarWhereInput[]
    id?: StringFilter<"PromoRedemption"> | string
    promoCodeId?: StringFilter<"PromoRedemption"> | string
    ownerId?: StringFilter<"PromoRedemption"> | string
    redeemedAt?: DateTimeFilter<"PromoRedemption"> | Date | string
  }

  export type CategoryRequestUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CategoryRequestWhereUniqueInput
    update: XOR<CategoryRequestUpdateWithoutOwnerInput, CategoryRequestUncheckedUpdateWithoutOwnerInput>
    create: XOR<CategoryRequestCreateWithoutOwnerInput, CategoryRequestUncheckedCreateWithoutOwnerInput>
  }

  export type CategoryRequestUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CategoryRequestWhereUniqueInput
    data: XOR<CategoryRequestUpdateWithoutOwnerInput, CategoryRequestUncheckedUpdateWithoutOwnerInput>
  }

  export type CategoryRequestUpdateManyWithWhereWithoutOwnerInput = {
    where: CategoryRequestScalarWhereInput
    data: XOR<CategoryRequestUpdateManyMutationInput, CategoryRequestUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CategoryRequestScalarWhereInput = {
    AND?: CategoryRequestScalarWhereInput | CategoryRequestScalarWhereInput[]
    OR?: CategoryRequestScalarWhereInput[]
    NOT?: CategoryRequestScalarWhereInput | CategoryRequestScalarWhereInput[]
    id?: StringFilter<"CategoryRequest"> | string
    barId?: StringFilter<"CategoryRequest"> | string
    ownerId?: StringFilter<"CategoryRequest"> | string
    requestedByEmail?: StringFilter<"CategoryRequest"> | string
    requestedByName?: StringNullableFilter<"CategoryRequest"> | string | null
    category?: StringFilter<"CategoryRequest"> | string
    status?: EnumCategoryRequestStatusFilter<"CategoryRequest"> | $Enums.CategoryRequestStatus
    reviewedAt?: DateTimeNullableFilter<"CategoryRequest"> | Date | string | null
    reviewedByEmail?: StringNullableFilter<"CategoryRequest"> | string | null
    createdAt?: DateTimeFilter<"CategoryRequest"> | Date | string
  }

  export type OwnerPasswordResetUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OwnerPasswordResetWhereUniqueInput
    update: XOR<OwnerPasswordResetUpdateWithoutOwnerInput, OwnerPasswordResetUncheckedUpdateWithoutOwnerInput>
    create: XOR<OwnerPasswordResetCreateWithoutOwnerInput, OwnerPasswordResetUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerPasswordResetUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OwnerPasswordResetWhereUniqueInput
    data: XOR<OwnerPasswordResetUpdateWithoutOwnerInput, OwnerPasswordResetUncheckedUpdateWithoutOwnerInput>
  }

  export type OwnerPasswordResetUpdateManyWithWhereWithoutOwnerInput = {
    where: OwnerPasswordResetScalarWhereInput
    data: XOR<OwnerPasswordResetUpdateManyMutationInput, OwnerPasswordResetUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OwnerPasswordResetScalarWhereInput = {
    AND?: OwnerPasswordResetScalarWhereInput | OwnerPasswordResetScalarWhereInput[]
    OR?: OwnerPasswordResetScalarWhereInput[]
    NOT?: OwnerPasswordResetScalarWhereInput | OwnerPasswordResetScalarWhereInput[]
    id?: StringFilter<"OwnerPasswordReset"> | string
    ownerId?: StringFilter<"OwnerPasswordReset"> | string
    tokenHash?: StringFilter<"OwnerPasswordReset"> | string
    expiresAt?: DateTimeFilter<"OwnerPasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"OwnerPasswordReset"> | Date | string | null
    createdAt?: DateTimeFilter<"OwnerPasswordReset"> | Date | string
  }

  export type OwnerCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarCreateNestedManyWithoutOwnerInput
    barLicenses?: BarLicenseCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarUncheckedCreateNestedManyWithoutOwnerInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutSubscriptionInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutSubscriptionInput, OwnerUncheckedCreateWithoutSubscriptionInput>
  }

  export type OwnerUpsertWithoutSubscriptionInput = {
    update: XOR<OwnerUpdateWithoutSubscriptionInput, OwnerUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<OwnerCreateWithoutSubscriptionInput, OwnerUncheckedCreateWithoutSubscriptionInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutSubscriptionInput, OwnerUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OwnerUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUpdateManyWithoutOwnerNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUncheckedUpdateManyWithoutOwnerNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateWithoutBarsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    subscription?: SubscriptionCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutBarsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutBarsInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutBarsInput, OwnerUncheckedCreateWithoutBarsInput>
  }

  export type OfferingCreateWithoutBarInput = {
    id?: string
    dayOfWeek: number
    category: string
    customTitle?: string | null
    description?: string | null
    startTime: string
    endTime?: string | null
    recurrence?: $Enums.Recurrence
    startDate?: Date | string | null
    endDate?: Date | string | null
    tags?: OfferingCreatetagsInput | string[]
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    expiresAt?: Date | string | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferingUncheckedCreateWithoutBarInput = {
    id?: string
    dayOfWeek: number
    category: string
    customTitle?: string | null
    description?: string | null
    startTime: string
    endTime?: string | null
    recurrence?: $Enums.Recurrence
    startDate?: Date | string | null
    endDate?: Date | string | null
    tags?: OfferingCreatetagsInput | string[]
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    expiresAt?: Date | string | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferingCreateOrConnectWithoutBarInput = {
    where: OfferingWhereUniqueInput
    create: XOR<OfferingCreateWithoutBarInput, OfferingUncheckedCreateWithoutBarInput>
  }

  export type OfferingCreateManyBarInputEnvelope = {
    data: OfferingCreateManyBarInput | OfferingCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutBarInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    startTime: string
    endTime?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    recurrence?: $Enums.Recurrence | null
    tags?: EventCreatetagsInput | string[]
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    autoExpire?: boolean
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutBarInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    startTime: string
    endTime?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    recurrence?: $Enums.Recurrence | null
    tags?: EventCreatetagsInput | string[]
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    autoExpire?: boolean
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutBarInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutBarInput, EventUncheckedCreateWithoutBarInput>
  }

  export type EventCreateManyBarInputEnvelope = {
    data: EventCreateManyBarInput | EventCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutBarInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutBarInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutBarInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutBarInput, FavoriteUncheckedCreateWithoutBarInput>
  }

  export type FavoriteCreateManyBarInputEnvelope = {
    data: FavoriteCreateManyBarInput | FavoriteCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarAnalyticsCreateWithoutBarInput = {
    id?: string
    date: Date | string
    dayOfWeek: number
    profileViews?: number
    profileClicks?: number
    searchAppears?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarAnalyticsUncheckedCreateWithoutBarInput = {
    id?: string
    date: Date | string
    dayOfWeek: number
    profileViews?: number
    profileClicks?: number
    searchAppears?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarAnalyticsCreateOrConnectWithoutBarInput = {
    where: BarAnalyticsWhereUniqueInput
    create: XOR<BarAnalyticsCreateWithoutBarInput, BarAnalyticsUncheckedCreateWithoutBarInput>
  }

  export type BarAnalyticsCreateManyBarInputEnvelope = {
    data: BarAnalyticsCreateManyBarInput | BarAnalyticsCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarClickCreateWithoutBarInput = {
    id?: string
    source: string
    query?: string | null
    dayOfWeek: number
    createdAt?: Date | string
  }

  export type BarClickUncheckedCreateWithoutBarInput = {
    id?: string
    source: string
    query?: string | null
    dayOfWeek: number
    createdAt?: Date | string
  }

  export type BarClickCreateOrConnectWithoutBarInput = {
    where: BarClickWhereUniqueInput
    create: XOR<BarClickCreateWithoutBarInput, BarClickUncheckedCreateWithoutBarInput>
  }

  export type BarClickCreateManyBarInputEnvelope = {
    data: BarClickCreateManyBarInput | BarClickCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarBadgeCreateWithoutBarInput = {
    id?: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    badge: BadgeCreateNestedOneWithoutBarBadgesInput
  }

  export type BarBadgeUncheckedCreateWithoutBarInput = {
    id?: string
    badgeKey: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeCreateOrConnectWithoutBarInput = {
    where: BarBadgeWhereUniqueInput
    create: XOR<BarBadgeCreateWithoutBarInput, BarBadgeUncheckedCreateWithoutBarInput>
  }

  export type BarBadgeCreateManyBarInputEnvelope = {
    data: BarBadgeCreateManyBarInput | BarBadgeCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarLicenseCreateWithoutBarInput = {
    id?: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutBarLicensesInput
  }

  export type BarLicenseUncheckedCreateWithoutBarInput = {
    id?: string
    ownerId: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarLicenseCreateOrConnectWithoutBarInput = {
    where: BarLicenseWhereUniqueInput
    create: XOR<BarLicenseCreateWithoutBarInput, BarLicenseUncheckedCreateWithoutBarInput>
  }

  export type BarLicenseCreateManyBarInputEnvelope = {
    data: BarLicenseCreateManyBarInput | BarLicenseCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUsageCreateWithoutBarInput = {
    id?: string
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutShiftUsagesInput
    items?: ShiftUsageItemCreateNestedManyWithoutShiftUsageInput
  }

  export type ShiftUsageUncheckedCreateWithoutBarInput = {
    id?: string
    userId?: string | null
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    items?: ShiftUsageItemUncheckedCreateNestedManyWithoutShiftUsageInput
  }

  export type ShiftUsageCreateOrConnectWithoutBarInput = {
    where: ShiftUsageWhereUniqueInput
    create: XOR<ShiftUsageCreateWithoutBarInput, ShiftUsageUncheckedCreateWithoutBarInput>
  }

  export type ShiftUsageCreateManyBarInputEnvelope = {
    data: ShiftUsageCreateManyBarInput | ShiftUsageCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutBarInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshotItems?: InventorySnapshotItemCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutBarInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshotItems?: InventorySnapshotItemUncheckedCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemUncheckedCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileUncheckedCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutBarInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutBarInput, InventoryItemUncheckedCreateWithoutBarInput>
  }

  export type InventoryItemCreateManyBarInputEnvelope = {
    data: InventoryItemCreateManyBarInput | InventoryItemCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type InventoryImportCreateWithoutBarInput = {
    id?: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutInventoryImportsInput
  }

  export type InventoryImportUncheckedCreateWithoutBarInput = {
    id?: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type InventoryImportCreateOrConnectWithoutBarInput = {
    where: InventoryImportWhereUniqueInput
    create: XOR<InventoryImportCreateWithoutBarInput, InventoryImportUncheckedCreateWithoutBarInput>
  }

  export type InventoryImportCreateManyBarInputEnvelope = {
    data: InventoryImportCreateManyBarInput | InventoryImportCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type InventorySnapshotCreateWithoutBarInput = {
    id?: string
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutInventorySnapshotsInput
    items?: InventorySnapshotItemCreateNestedManyWithoutSnapshotInput
  }

  export type InventorySnapshotUncheckedCreateWithoutBarInput = {
    id?: string
    userId?: string | null
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    items?: InventorySnapshotItemUncheckedCreateNestedManyWithoutSnapshotInput
  }

  export type InventorySnapshotCreateOrConnectWithoutBarInput = {
    where: InventorySnapshotWhereUniqueInput
    create: XOR<InventorySnapshotCreateWithoutBarInput, InventorySnapshotUncheckedCreateWithoutBarInput>
  }

  export type InventorySnapshotCreateManyBarInputEnvelope = {
    data: InventorySnapshotCreateManyBarInput | InventorySnapshotCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarVisitCreateWithoutBarInput = {
    id?: string
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutVisitsInput
  }

  export type BarVisitUncheckedCreateWithoutBarInput = {
    id?: string
    userId?: string | null
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
  }

  export type BarVisitCreateOrConnectWithoutBarInput = {
    where: BarVisitWhereUniqueInput
    create: XOR<BarVisitCreateWithoutBarInput, BarVisitUncheckedCreateWithoutBarInput>
  }

  export type BarVisitCreateManyBarInputEnvelope = {
    data: BarVisitCreateManyBarInput | BarVisitCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type VarianceAlertCreateWithoutBarInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
    inventoryItem: InventoryItemCreateNestedOneWithoutVarianceAlertsInput
  }

  export type VarianceAlertUncheckedCreateWithoutBarInput = {
    id?: string
    inventoryItemId: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
  }

  export type VarianceAlertCreateOrConnectWithoutBarInput = {
    where: VarianceAlertWhereUniqueInput
    create: XOR<VarianceAlertCreateWithoutBarInput, VarianceAlertUncheckedCreateWithoutBarInput>
  }

  export type VarianceAlertCreateManyBarInputEnvelope = {
    data: VarianceAlertCreateManyBarInput | VarianceAlertCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type StaticOfferingCreateWithoutBarInput = {
    id?: string
    name: string
    icon: string
    description?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaticOfferingUncheckedCreateWithoutBarInput = {
    id?: string
    name: string
    icon: string
    description?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaticOfferingCreateOrConnectWithoutBarInput = {
    where: StaticOfferingWhereUniqueInput
    create: XOR<StaticOfferingCreateWithoutBarInput, StaticOfferingUncheckedCreateWithoutBarInput>
  }

  export type StaticOfferingCreateManyBarInputEnvelope = {
    data: StaticOfferingCreateManyBarInput | StaticOfferingCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type DrinkSpecialCreateWithoutBarInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    daysOfWeek?: DrinkSpecialCreatedaysOfWeekInput | number[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrinkSpecialUncheckedCreateWithoutBarInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    daysOfWeek?: DrinkSpecialCreatedaysOfWeekInput | number[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrinkSpecialCreateOrConnectWithoutBarInput = {
    where: DrinkSpecialWhereUniqueInput
    create: XOR<DrinkSpecialCreateWithoutBarInput, DrinkSpecialUncheckedCreateWithoutBarInput>
  }

  export type DrinkSpecialCreateManyBarInputEnvelope = {
    data: DrinkSpecialCreateManyBarInput | DrinkSpecialCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type FoodOfferingCreateWithoutBarInput = {
    id?: string
    name: string
    description?: string | null
    specialDays?: FoodOfferingCreatespecialDaysInput | number[]
    isSpecial?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodOfferingUncheckedCreateWithoutBarInput = {
    id?: string
    name: string
    description?: string | null
    specialDays?: FoodOfferingCreatespecialDaysInput | number[]
    isSpecial?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodOfferingCreateOrConnectWithoutBarInput = {
    where: FoodOfferingWhereUniqueInput
    create: XOR<FoodOfferingCreateWithoutBarInput, FoodOfferingUncheckedCreateWithoutBarInput>
  }

  export type FoodOfferingCreateManyBarInputEnvelope = {
    data: FoodOfferingCreateManyBarInput | FoodOfferingCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type CategoryRequestCreateWithoutBarInput = {
    id?: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
    owner: OwnerCreateNestedOneWithoutCategoryRequestsInput
  }

  export type CategoryRequestUncheckedCreateWithoutBarInput = {
    id?: string
    ownerId: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
  }

  export type CategoryRequestCreateOrConnectWithoutBarInput = {
    where: CategoryRequestWhereUniqueInput
    create: XOR<CategoryRequestCreateWithoutBarInput, CategoryRequestUncheckedCreateWithoutBarInput>
  }

  export type CategoryRequestCreateManyBarInputEnvelope = {
    data: CategoryRequestCreateManyBarInput | CategoryRequestCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarMembershipCreateWithoutBarInput = {
    id?: string
    userId: string
    role?: $Enums.BarMemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarMembershipUncheckedCreateWithoutBarInput = {
    id?: string
    userId: string
    role?: $Enums.BarMemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarMembershipCreateOrConnectWithoutBarInput = {
    where: BarMembershipWhereUniqueInput
    create: XOR<BarMembershipCreateWithoutBarInput, BarMembershipUncheckedCreateWithoutBarInput>
  }

  export type BarMembershipCreateManyBarInputEnvelope = {
    data: BarMembershipCreateManyBarInput | BarMembershipCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarFollowerCreateWithoutBarInput = {
    id?: string
    patronEmail: string
    createdAt?: Date | string
  }

  export type BarFollowerUncheckedCreateWithoutBarInput = {
    id?: string
    patronEmail: string
    createdAt?: Date | string
  }

  export type BarFollowerCreateOrConnectWithoutBarInput = {
    where: BarFollowerWhereUniqueInput
    create: XOR<BarFollowerCreateWithoutBarInput, BarFollowerUncheckedCreateWithoutBarInput>
  }

  export type BarFollowerCreateManyBarInputEnvelope = {
    data: BarFollowerCreateManyBarInput | BarFollowerCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BoostCreateWithoutBarInput = {
    id?: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
    metrics?: BoostMetricCreateNestedManyWithoutBoostInput
  }

  export type BoostUncheckedCreateWithoutBarInput = {
    id?: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
    metrics?: BoostMetricUncheckedCreateNestedManyWithoutBoostInput
  }

  export type BoostCreateOrConnectWithoutBarInput = {
    where: BoostWhereUniqueInput
    create: XOR<BoostCreateWithoutBarInput, BoostUncheckedCreateWithoutBarInput>
  }

  export type BoostCreateManyBarInputEnvelope = {
    data: BoostCreateManyBarInput | BoostCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarProductCreateWithoutBarInput = {
    id?: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    product?: ProductCreateNestedOneWithoutBarProductsInput
    counts?: InventoryCountCreateNestedManyWithoutProductInput
    detections?: InventoryScanDetectionCreateNestedManyWithoutProductInput
  }

  export type BarProductUncheckedCreateWithoutBarInput = {
    id?: string
    productId?: string | null
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    counts?: InventoryCountUncheckedCreateNestedManyWithoutProductInput
    detections?: InventoryScanDetectionUncheckedCreateNestedManyWithoutProductInput
  }

  export type BarProductCreateOrConnectWithoutBarInput = {
    where: BarProductWhereUniqueInput
    create: XOR<BarProductCreateWithoutBarInput, BarProductUncheckedCreateWithoutBarInput>
  }

  export type BarProductCreateManyBarInputEnvelope = {
    data: BarProductCreateManyBarInput | BarProductCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type InventoryScanSessionCreateWithoutBarInput = {
    id?: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    detections?: InventoryScanDetectionCreateNestedManyWithoutSessionInput
  }

  export type InventoryScanSessionUncheckedCreateWithoutBarInput = {
    id?: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    detections?: InventoryScanDetectionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InventoryScanSessionCreateOrConnectWithoutBarInput = {
    where: InventoryScanSessionWhereUniqueInput
    create: XOR<InventoryScanSessionCreateWithoutBarInput, InventoryScanSessionUncheckedCreateWithoutBarInput>
  }

  export type InventoryScanSessionCreateManyBarInputEnvelope = {
    data: InventoryScanSessionCreateManyBarInput | InventoryScanSessionCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCountCreateWithoutBarInput = {
    id?: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
    product: BarProductCreateNestedOneWithoutCountsInput
  }

  export type InventoryCountUncheckedCreateWithoutBarInput = {
    id?: string
    productId: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
  }

  export type InventoryCountCreateOrConnectWithoutBarInput = {
    where: InventoryCountWhereUniqueInput
    create: XOR<InventoryCountCreateWithoutBarInput, InventoryCountUncheckedCreateWithoutBarInput>
  }

  export type InventoryCountCreateManyBarInputEnvelope = {
    data: InventoryCountCreateManyBarInput | InventoryCountCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type PatronSearchEventCreateWithoutBarInput = {
    id?: string
    query?: string | null
    category?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type PatronSearchEventUncheckedCreateWithoutBarInput = {
    id?: string
    query?: string | null
    category?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type PatronSearchEventCreateOrConnectWithoutBarInput = {
    where: PatronSearchEventWhereUniqueInput
    create: XOR<PatronSearchEventCreateWithoutBarInput, PatronSearchEventUncheckedCreateWithoutBarInput>
  }

  export type PatronSearchEventCreateManyBarInputEnvelope = {
    data: PatronSearchEventCreateManyBarInput | PatronSearchEventCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type BarActionCreateWithoutBarInput = {
    id?: string
    action: string
    createdAt?: Date | string
  }

  export type BarActionUncheckedCreateWithoutBarInput = {
    id?: string
    action: string
    createdAt?: Date | string
  }

  export type BarActionCreateOrConnectWithoutBarInput = {
    where: BarActionWhereUniqueInput
    create: XOR<BarActionCreateWithoutBarInput, BarActionUncheckedCreateWithoutBarInput>
  }

  export type BarActionCreateManyBarInputEnvelope = {
    data: BarActionCreateManyBarInput | BarActionCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type AdminNoteCreateWithoutBarInput = {
    id?: string
    adminEmail: string
    content: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutBarInput = {
    id?: string
    adminEmail: string
    userId?: string | null
    content: string
    createdAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutBarInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutBarInput, AdminNoteUncheckedCreateWithoutBarInput>
  }

  export type AdminNoteCreateManyBarInputEnvelope = {
    data: AdminNoteCreateManyBarInput | AdminNoteCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutBarInput = {
    id?: string
    userEmail: string
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutBarInput = {
    id?: string
    userEmail: string
    userId?: string | null
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutBarInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutBarInput, SupportTicketUncheckedCreateWithoutBarInput>
  }

  export type SupportTicketCreateManyBarInputEnvelope = {
    data: SupportTicketCreateManyBarInput | SupportTicketCreateManyBarInput[]
    skipDuplicates?: boolean
  }

  export type OwnerUpsertWithoutBarsInput = {
    update: XOR<OwnerUpdateWithoutBarsInput, OwnerUncheckedUpdateWithoutBarsInput>
    create: XOR<OwnerCreateWithoutBarsInput, OwnerUncheckedCreateWithoutBarsInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutBarsInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutBarsInput, OwnerUncheckedUpdateWithoutBarsInput>
  }

  export type OwnerUpdateWithoutBarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    subscription?: SubscriptionUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutBarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    subscription?: SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OfferingUpsertWithWhereUniqueWithoutBarInput = {
    where: OfferingWhereUniqueInput
    update: XOR<OfferingUpdateWithoutBarInput, OfferingUncheckedUpdateWithoutBarInput>
    create: XOR<OfferingCreateWithoutBarInput, OfferingUncheckedCreateWithoutBarInput>
  }

  export type OfferingUpdateWithWhereUniqueWithoutBarInput = {
    where: OfferingWhereUniqueInput
    data: XOR<OfferingUpdateWithoutBarInput, OfferingUncheckedUpdateWithoutBarInput>
  }

  export type OfferingUpdateManyWithWhereWithoutBarInput = {
    where: OfferingScalarWhereInput
    data: XOR<OfferingUpdateManyMutationInput, OfferingUncheckedUpdateManyWithoutBarInput>
  }

  export type OfferingScalarWhereInput = {
    AND?: OfferingScalarWhereInput | OfferingScalarWhereInput[]
    OR?: OfferingScalarWhereInput[]
    NOT?: OfferingScalarWhereInput | OfferingScalarWhereInput[]
    id?: StringFilter<"Offering"> | string
    barId?: StringFilter<"Offering"> | string
    dayOfWeek?: IntFilter<"Offering"> | number
    category?: StringFilter<"Offering"> | string
    customTitle?: StringNullableFilter<"Offering"> | string | null
    description?: StringNullableFilter<"Offering"> | string | null
    startTime?: StringFilter<"Offering"> | string
    endTime?: StringNullableFilter<"Offering"> | string | null
    recurrence?: EnumRecurrenceFilter<"Offering"> | $Enums.Recurrence
    startDate?: DateTimeNullableFilter<"Offering"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Offering"> | Date | string | null
    tags?: StringNullableListFilter<"Offering">
    coverCharge?: DecimalNullableFilter<"Offering"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableFilter<"Offering"> | string | null
    ageRestriction?: IntNullableFilter<"Offering"> | number | null
    isActive?: BoolFilter<"Offering"> | boolean
    isSpecial?: BoolFilter<"Offering"> | boolean
    isNew?: BoolFilter<"Offering"> | boolean
    specialExpiresAt?: DateTimeNullableFilter<"Offering"> | Date | string | null
    newUntil?: DateTimeNullableFilter<"Offering"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Offering"> | Date | string | null
    clickCount?: IntFilter<"Offering"> | number
    createdAt?: DateTimeFilter<"Offering"> | Date | string
    updatedAt?: DateTimeFilter<"Offering"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutBarInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutBarInput, EventUncheckedUpdateWithoutBarInput>
    create: XOR<EventCreateWithoutBarInput, EventUncheckedCreateWithoutBarInput>
  }

  export type EventUpdateWithWhereUniqueWithoutBarInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutBarInput, EventUncheckedUpdateWithoutBarInput>
  }

  export type EventUpdateManyWithWhereWithoutBarInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutBarInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    barId?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    category?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeNullableFilter<"Event"> | Date | string | null
    startTime?: StringFilter<"Event"> | string
    endTime?: StringNullableFilter<"Event"> | string | null
    isRecurring?: BoolFilter<"Event"> | boolean
    recurrenceRule?: StringNullableFilter<"Event"> | string | null
    recurrence?: EnumRecurrenceNullableFilter<"Event"> | $Enums.Recurrence | null
    tags?: StringNullableListFilter<"Event">
    isActive?: BoolFilter<"Event"> | boolean
    isSpecial?: BoolFilter<"Event"> | boolean
    isNew?: BoolFilter<"Event"> | boolean
    specialExpiresAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    newUntil?: DateTimeNullableFilter<"Event"> | Date | string | null
    autoExpire?: BoolFilter<"Event"> | boolean
    coverCharge?: DecimalNullableFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    prize?: StringNullableFilter<"Event"> | string | null
    ageRestriction?: IntNullableFilter<"Event"> | number | null
    clickCount?: IntFilter<"Event"> | number
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutBarInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutBarInput, FavoriteUncheckedUpdateWithoutBarInput>
    create: XOR<FavoriteCreateWithoutBarInput, FavoriteUncheckedCreateWithoutBarInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutBarInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutBarInput, FavoriteUncheckedUpdateWithoutBarInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutBarInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutBarInput>
  }

  export type BarAnalyticsUpsertWithWhereUniqueWithoutBarInput = {
    where: BarAnalyticsWhereUniqueInput
    update: XOR<BarAnalyticsUpdateWithoutBarInput, BarAnalyticsUncheckedUpdateWithoutBarInput>
    create: XOR<BarAnalyticsCreateWithoutBarInput, BarAnalyticsUncheckedCreateWithoutBarInput>
  }

  export type BarAnalyticsUpdateWithWhereUniqueWithoutBarInput = {
    where: BarAnalyticsWhereUniqueInput
    data: XOR<BarAnalyticsUpdateWithoutBarInput, BarAnalyticsUncheckedUpdateWithoutBarInput>
  }

  export type BarAnalyticsUpdateManyWithWhereWithoutBarInput = {
    where: BarAnalyticsScalarWhereInput
    data: XOR<BarAnalyticsUpdateManyMutationInput, BarAnalyticsUncheckedUpdateManyWithoutBarInput>
  }

  export type BarAnalyticsScalarWhereInput = {
    AND?: BarAnalyticsScalarWhereInput | BarAnalyticsScalarWhereInput[]
    OR?: BarAnalyticsScalarWhereInput[]
    NOT?: BarAnalyticsScalarWhereInput | BarAnalyticsScalarWhereInput[]
    id?: StringFilter<"BarAnalytics"> | string
    barId?: StringFilter<"BarAnalytics"> | string
    date?: DateTimeFilter<"BarAnalytics"> | Date | string
    dayOfWeek?: IntFilter<"BarAnalytics"> | number
    profileViews?: IntFilter<"BarAnalytics"> | number
    profileClicks?: IntFilter<"BarAnalytics"> | number
    searchAppears?: IntFilter<"BarAnalytics"> | number
    createdAt?: DateTimeFilter<"BarAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"BarAnalytics"> | Date | string
  }

  export type BarClickUpsertWithWhereUniqueWithoutBarInput = {
    where: BarClickWhereUniqueInput
    update: XOR<BarClickUpdateWithoutBarInput, BarClickUncheckedUpdateWithoutBarInput>
    create: XOR<BarClickCreateWithoutBarInput, BarClickUncheckedCreateWithoutBarInput>
  }

  export type BarClickUpdateWithWhereUniqueWithoutBarInput = {
    where: BarClickWhereUniqueInput
    data: XOR<BarClickUpdateWithoutBarInput, BarClickUncheckedUpdateWithoutBarInput>
  }

  export type BarClickUpdateManyWithWhereWithoutBarInput = {
    where: BarClickScalarWhereInput
    data: XOR<BarClickUpdateManyMutationInput, BarClickUncheckedUpdateManyWithoutBarInput>
  }

  export type BarClickScalarWhereInput = {
    AND?: BarClickScalarWhereInput | BarClickScalarWhereInput[]
    OR?: BarClickScalarWhereInput[]
    NOT?: BarClickScalarWhereInput | BarClickScalarWhereInput[]
    id?: StringFilter<"BarClick"> | string
    barId?: StringFilter<"BarClick"> | string
    source?: StringFilter<"BarClick"> | string
    query?: StringNullableFilter<"BarClick"> | string | null
    dayOfWeek?: IntFilter<"BarClick"> | number
    createdAt?: DateTimeFilter<"BarClick"> | Date | string
  }

  export type BarBadgeUpsertWithWhereUniqueWithoutBarInput = {
    where: BarBadgeWhereUniqueInput
    update: XOR<BarBadgeUpdateWithoutBarInput, BarBadgeUncheckedUpdateWithoutBarInput>
    create: XOR<BarBadgeCreateWithoutBarInput, BarBadgeUncheckedCreateWithoutBarInput>
  }

  export type BarBadgeUpdateWithWhereUniqueWithoutBarInput = {
    where: BarBadgeWhereUniqueInput
    data: XOR<BarBadgeUpdateWithoutBarInput, BarBadgeUncheckedUpdateWithoutBarInput>
  }

  export type BarBadgeUpdateManyWithWhereWithoutBarInput = {
    where: BarBadgeScalarWhereInput
    data: XOR<BarBadgeUpdateManyMutationInput, BarBadgeUncheckedUpdateManyWithoutBarInput>
  }

  export type BarBadgeScalarWhereInput = {
    AND?: BarBadgeScalarWhereInput | BarBadgeScalarWhereInput[]
    OR?: BarBadgeScalarWhereInput[]
    NOT?: BarBadgeScalarWhereInput | BarBadgeScalarWhereInput[]
    id?: StringFilter<"BarBadge"> | string
    barId?: StringFilter<"BarBadge"> | string
    badgeKey?: StringFilter<"BarBadge"> | string
    awardedAt?: DateTimeFilter<"BarBadge"> | Date | string
    progress?: JsonNullableFilter<"BarBadge">
    metadata?: JsonNullableFilter<"BarBadge">
  }

  export type BarLicenseUpsertWithWhereUniqueWithoutBarInput = {
    where: BarLicenseWhereUniqueInput
    update: XOR<BarLicenseUpdateWithoutBarInput, BarLicenseUncheckedUpdateWithoutBarInput>
    create: XOR<BarLicenseCreateWithoutBarInput, BarLicenseUncheckedCreateWithoutBarInput>
  }

  export type BarLicenseUpdateWithWhereUniqueWithoutBarInput = {
    where: BarLicenseWhereUniqueInput
    data: XOR<BarLicenseUpdateWithoutBarInput, BarLicenseUncheckedUpdateWithoutBarInput>
  }

  export type BarLicenseUpdateManyWithWhereWithoutBarInput = {
    where: BarLicenseScalarWhereInput
    data: XOR<BarLicenseUpdateManyMutationInput, BarLicenseUncheckedUpdateManyWithoutBarInput>
  }

  export type ShiftUsageUpsertWithWhereUniqueWithoutBarInput = {
    where: ShiftUsageWhereUniqueInput
    update: XOR<ShiftUsageUpdateWithoutBarInput, ShiftUsageUncheckedUpdateWithoutBarInput>
    create: XOR<ShiftUsageCreateWithoutBarInput, ShiftUsageUncheckedCreateWithoutBarInput>
  }

  export type ShiftUsageUpdateWithWhereUniqueWithoutBarInput = {
    where: ShiftUsageWhereUniqueInput
    data: XOR<ShiftUsageUpdateWithoutBarInput, ShiftUsageUncheckedUpdateWithoutBarInput>
  }

  export type ShiftUsageUpdateManyWithWhereWithoutBarInput = {
    where: ShiftUsageScalarWhereInput
    data: XOR<ShiftUsageUpdateManyMutationInput, ShiftUsageUncheckedUpdateManyWithoutBarInput>
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutBarInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutBarInput, InventoryItemUncheckedUpdateWithoutBarInput>
    create: XOR<InventoryItemCreateWithoutBarInput, InventoryItemUncheckedCreateWithoutBarInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutBarInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutBarInput, InventoryItemUncheckedUpdateWithoutBarInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutBarInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutBarInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    barId?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: StringNullableFilter<"InventoryItem"> | string | null
    bottleSizeMl?: IntFilter<"InventoryItem"> | number
    startingQtyBottles?: IntFilter<"InventoryItem"> | number
    costPerBottle?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type InventoryImportUpsertWithWhereUniqueWithoutBarInput = {
    where: InventoryImportWhereUniqueInput
    update: XOR<InventoryImportUpdateWithoutBarInput, InventoryImportUncheckedUpdateWithoutBarInput>
    create: XOR<InventoryImportCreateWithoutBarInput, InventoryImportUncheckedCreateWithoutBarInput>
  }

  export type InventoryImportUpdateWithWhereUniqueWithoutBarInput = {
    where: InventoryImportWhereUniqueInput
    data: XOR<InventoryImportUpdateWithoutBarInput, InventoryImportUncheckedUpdateWithoutBarInput>
  }

  export type InventoryImportUpdateManyWithWhereWithoutBarInput = {
    where: InventoryImportScalarWhereInput
    data: XOR<InventoryImportUpdateManyMutationInput, InventoryImportUncheckedUpdateManyWithoutBarInput>
  }

  export type InventorySnapshotUpsertWithWhereUniqueWithoutBarInput = {
    where: InventorySnapshotWhereUniqueInput
    update: XOR<InventorySnapshotUpdateWithoutBarInput, InventorySnapshotUncheckedUpdateWithoutBarInput>
    create: XOR<InventorySnapshotCreateWithoutBarInput, InventorySnapshotUncheckedCreateWithoutBarInput>
  }

  export type InventorySnapshotUpdateWithWhereUniqueWithoutBarInput = {
    where: InventorySnapshotWhereUniqueInput
    data: XOR<InventorySnapshotUpdateWithoutBarInput, InventorySnapshotUncheckedUpdateWithoutBarInput>
  }

  export type InventorySnapshotUpdateManyWithWhereWithoutBarInput = {
    where: InventorySnapshotScalarWhereInput
    data: XOR<InventorySnapshotUpdateManyMutationInput, InventorySnapshotUncheckedUpdateManyWithoutBarInput>
  }

  export type BarVisitUpsertWithWhereUniqueWithoutBarInput = {
    where: BarVisitWhereUniqueInput
    update: XOR<BarVisitUpdateWithoutBarInput, BarVisitUncheckedUpdateWithoutBarInput>
    create: XOR<BarVisitCreateWithoutBarInput, BarVisitUncheckedCreateWithoutBarInput>
  }

  export type BarVisitUpdateWithWhereUniqueWithoutBarInput = {
    where: BarVisitWhereUniqueInput
    data: XOR<BarVisitUpdateWithoutBarInput, BarVisitUncheckedUpdateWithoutBarInput>
  }

  export type BarVisitUpdateManyWithWhereWithoutBarInput = {
    where: BarVisitScalarWhereInput
    data: XOR<BarVisitUpdateManyMutationInput, BarVisitUncheckedUpdateManyWithoutBarInput>
  }

  export type VarianceAlertUpsertWithWhereUniqueWithoutBarInput = {
    where: VarianceAlertWhereUniqueInput
    update: XOR<VarianceAlertUpdateWithoutBarInput, VarianceAlertUncheckedUpdateWithoutBarInput>
    create: XOR<VarianceAlertCreateWithoutBarInput, VarianceAlertUncheckedCreateWithoutBarInput>
  }

  export type VarianceAlertUpdateWithWhereUniqueWithoutBarInput = {
    where: VarianceAlertWhereUniqueInput
    data: XOR<VarianceAlertUpdateWithoutBarInput, VarianceAlertUncheckedUpdateWithoutBarInput>
  }

  export type VarianceAlertUpdateManyWithWhereWithoutBarInput = {
    where: VarianceAlertScalarWhereInput
    data: XOR<VarianceAlertUpdateManyMutationInput, VarianceAlertUncheckedUpdateManyWithoutBarInput>
  }

  export type VarianceAlertScalarWhereInput = {
    AND?: VarianceAlertScalarWhereInput | VarianceAlertScalarWhereInput[]
    OR?: VarianceAlertScalarWhereInput[]
    NOT?: VarianceAlertScalarWhereInput | VarianceAlertScalarWhereInput[]
    id?: StringFilter<"VarianceAlert"> | string
    barId?: StringFilter<"VarianceAlert"> | string
    inventoryItemId?: StringFilter<"VarianceAlert"> | string
    periodStart?: DateTimeFilter<"VarianceAlert"> | Date | string
    periodEnd?: DateTimeFilter<"VarianceAlert"> | Date | string
    expectedMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFilter<"VarianceAlert"> | Decimal | DecimalJsLike | number | string
    severity?: StringFilter<"VarianceAlert"> | string
    reasonHint?: StringNullableFilter<"VarianceAlert"> | string | null
    createdAt?: DateTimeFilter<"VarianceAlert"> | Date | string
  }

  export type StaticOfferingUpsertWithWhereUniqueWithoutBarInput = {
    where: StaticOfferingWhereUniqueInput
    update: XOR<StaticOfferingUpdateWithoutBarInput, StaticOfferingUncheckedUpdateWithoutBarInput>
    create: XOR<StaticOfferingCreateWithoutBarInput, StaticOfferingUncheckedCreateWithoutBarInput>
  }

  export type StaticOfferingUpdateWithWhereUniqueWithoutBarInput = {
    where: StaticOfferingWhereUniqueInput
    data: XOR<StaticOfferingUpdateWithoutBarInput, StaticOfferingUncheckedUpdateWithoutBarInput>
  }

  export type StaticOfferingUpdateManyWithWhereWithoutBarInput = {
    where: StaticOfferingScalarWhereInput
    data: XOR<StaticOfferingUpdateManyMutationInput, StaticOfferingUncheckedUpdateManyWithoutBarInput>
  }

  export type StaticOfferingScalarWhereInput = {
    AND?: StaticOfferingScalarWhereInput | StaticOfferingScalarWhereInput[]
    OR?: StaticOfferingScalarWhereInput[]
    NOT?: StaticOfferingScalarWhereInput | StaticOfferingScalarWhereInput[]
    id?: StringFilter<"StaticOffering"> | string
    barId?: StringFilter<"StaticOffering"> | string
    name?: StringFilter<"StaticOffering"> | string
    icon?: StringFilter<"StaticOffering"> | string
    description?: StringNullableFilter<"StaticOffering"> | string | null
    position?: IntFilter<"StaticOffering"> | number
    createdAt?: DateTimeFilter<"StaticOffering"> | Date | string
    updatedAt?: DateTimeFilter<"StaticOffering"> | Date | string
  }

  export type DrinkSpecialUpsertWithWhereUniqueWithoutBarInput = {
    where: DrinkSpecialWhereUniqueInput
    update: XOR<DrinkSpecialUpdateWithoutBarInput, DrinkSpecialUncheckedUpdateWithoutBarInput>
    create: XOR<DrinkSpecialCreateWithoutBarInput, DrinkSpecialUncheckedCreateWithoutBarInput>
  }

  export type DrinkSpecialUpdateWithWhereUniqueWithoutBarInput = {
    where: DrinkSpecialWhereUniqueInput
    data: XOR<DrinkSpecialUpdateWithoutBarInput, DrinkSpecialUncheckedUpdateWithoutBarInput>
  }

  export type DrinkSpecialUpdateManyWithWhereWithoutBarInput = {
    where: DrinkSpecialScalarWhereInput
    data: XOR<DrinkSpecialUpdateManyMutationInput, DrinkSpecialUncheckedUpdateManyWithoutBarInput>
  }

  export type DrinkSpecialScalarWhereInput = {
    AND?: DrinkSpecialScalarWhereInput | DrinkSpecialScalarWhereInput[]
    OR?: DrinkSpecialScalarWhereInput[]
    NOT?: DrinkSpecialScalarWhereInput | DrinkSpecialScalarWhereInput[]
    id?: StringFilter<"DrinkSpecial"> | string
    barId?: StringFilter<"DrinkSpecial"> | string
    name?: StringFilter<"DrinkSpecial"> | string
    description?: StringNullableFilter<"DrinkSpecial"> | string | null
    startTime?: StringFilter<"DrinkSpecial"> | string
    endTime?: StringFilter<"DrinkSpecial"> | string
    daysOfWeek?: IntNullableListFilter<"DrinkSpecial">
    active?: BoolFilter<"DrinkSpecial"> | boolean
    createdAt?: DateTimeFilter<"DrinkSpecial"> | Date | string
    updatedAt?: DateTimeFilter<"DrinkSpecial"> | Date | string
  }

  export type FoodOfferingUpsertWithWhereUniqueWithoutBarInput = {
    where: FoodOfferingWhereUniqueInput
    update: XOR<FoodOfferingUpdateWithoutBarInput, FoodOfferingUncheckedUpdateWithoutBarInput>
    create: XOR<FoodOfferingCreateWithoutBarInput, FoodOfferingUncheckedCreateWithoutBarInput>
  }

  export type FoodOfferingUpdateWithWhereUniqueWithoutBarInput = {
    where: FoodOfferingWhereUniqueInput
    data: XOR<FoodOfferingUpdateWithoutBarInput, FoodOfferingUncheckedUpdateWithoutBarInput>
  }

  export type FoodOfferingUpdateManyWithWhereWithoutBarInput = {
    where: FoodOfferingScalarWhereInput
    data: XOR<FoodOfferingUpdateManyMutationInput, FoodOfferingUncheckedUpdateManyWithoutBarInput>
  }

  export type FoodOfferingScalarWhereInput = {
    AND?: FoodOfferingScalarWhereInput | FoodOfferingScalarWhereInput[]
    OR?: FoodOfferingScalarWhereInput[]
    NOT?: FoodOfferingScalarWhereInput | FoodOfferingScalarWhereInput[]
    id?: StringFilter<"FoodOffering"> | string
    barId?: StringFilter<"FoodOffering"> | string
    name?: StringFilter<"FoodOffering"> | string
    description?: StringNullableFilter<"FoodOffering"> | string | null
    specialDays?: IntNullableListFilter<"FoodOffering">
    isSpecial?: BoolFilter<"FoodOffering"> | boolean
    active?: BoolFilter<"FoodOffering"> | boolean
    createdAt?: DateTimeFilter<"FoodOffering"> | Date | string
    updatedAt?: DateTimeFilter<"FoodOffering"> | Date | string
  }

  export type CategoryRequestUpsertWithWhereUniqueWithoutBarInput = {
    where: CategoryRequestWhereUniqueInput
    update: XOR<CategoryRequestUpdateWithoutBarInput, CategoryRequestUncheckedUpdateWithoutBarInput>
    create: XOR<CategoryRequestCreateWithoutBarInput, CategoryRequestUncheckedCreateWithoutBarInput>
  }

  export type CategoryRequestUpdateWithWhereUniqueWithoutBarInput = {
    where: CategoryRequestWhereUniqueInput
    data: XOR<CategoryRequestUpdateWithoutBarInput, CategoryRequestUncheckedUpdateWithoutBarInput>
  }

  export type CategoryRequestUpdateManyWithWhereWithoutBarInput = {
    where: CategoryRequestScalarWhereInput
    data: XOR<CategoryRequestUpdateManyMutationInput, CategoryRequestUncheckedUpdateManyWithoutBarInput>
  }

  export type BarMembershipUpsertWithWhereUniqueWithoutBarInput = {
    where: BarMembershipWhereUniqueInput
    update: XOR<BarMembershipUpdateWithoutBarInput, BarMembershipUncheckedUpdateWithoutBarInput>
    create: XOR<BarMembershipCreateWithoutBarInput, BarMembershipUncheckedCreateWithoutBarInput>
  }

  export type BarMembershipUpdateWithWhereUniqueWithoutBarInput = {
    where: BarMembershipWhereUniqueInput
    data: XOR<BarMembershipUpdateWithoutBarInput, BarMembershipUncheckedUpdateWithoutBarInput>
  }

  export type BarMembershipUpdateManyWithWhereWithoutBarInput = {
    where: BarMembershipScalarWhereInput
    data: XOR<BarMembershipUpdateManyMutationInput, BarMembershipUncheckedUpdateManyWithoutBarInput>
  }

  export type BarMembershipScalarWhereInput = {
    AND?: BarMembershipScalarWhereInput | BarMembershipScalarWhereInput[]
    OR?: BarMembershipScalarWhereInput[]
    NOT?: BarMembershipScalarWhereInput | BarMembershipScalarWhereInput[]
    id?: StringFilter<"BarMembership"> | string
    barId?: StringFilter<"BarMembership"> | string
    userId?: StringFilter<"BarMembership"> | string
    role?: EnumBarMemberRoleFilter<"BarMembership"> | $Enums.BarMemberRole
    createdAt?: DateTimeFilter<"BarMembership"> | Date | string
    updatedAt?: DateTimeFilter<"BarMembership"> | Date | string
  }

  export type BarFollowerUpsertWithWhereUniqueWithoutBarInput = {
    where: BarFollowerWhereUniqueInput
    update: XOR<BarFollowerUpdateWithoutBarInput, BarFollowerUncheckedUpdateWithoutBarInput>
    create: XOR<BarFollowerCreateWithoutBarInput, BarFollowerUncheckedCreateWithoutBarInput>
  }

  export type BarFollowerUpdateWithWhereUniqueWithoutBarInput = {
    where: BarFollowerWhereUniqueInput
    data: XOR<BarFollowerUpdateWithoutBarInput, BarFollowerUncheckedUpdateWithoutBarInput>
  }

  export type BarFollowerUpdateManyWithWhereWithoutBarInput = {
    where: BarFollowerScalarWhereInput
    data: XOR<BarFollowerUpdateManyMutationInput, BarFollowerUncheckedUpdateManyWithoutBarInput>
  }

  export type BarFollowerScalarWhereInput = {
    AND?: BarFollowerScalarWhereInput | BarFollowerScalarWhereInput[]
    OR?: BarFollowerScalarWhereInput[]
    NOT?: BarFollowerScalarWhereInput | BarFollowerScalarWhereInput[]
    id?: StringFilter<"BarFollower"> | string
    barId?: StringFilter<"BarFollower"> | string
    patronEmail?: StringFilter<"BarFollower"> | string
    createdAt?: DateTimeFilter<"BarFollower"> | Date | string
  }

  export type BoostUpsertWithWhereUniqueWithoutBarInput = {
    where: BoostWhereUniqueInput
    update: XOR<BoostUpdateWithoutBarInput, BoostUncheckedUpdateWithoutBarInput>
    create: XOR<BoostCreateWithoutBarInput, BoostUncheckedCreateWithoutBarInput>
  }

  export type BoostUpdateWithWhereUniqueWithoutBarInput = {
    where: BoostWhereUniqueInput
    data: XOR<BoostUpdateWithoutBarInput, BoostUncheckedUpdateWithoutBarInput>
  }

  export type BoostUpdateManyWithWhereWithoutBarInput = {
    where: BoostScalarWhereInput
    data: XOR<BoostUpdateManyMutationInput, BoostUncheckedUpdateManyWithoutBarInput>
  }

  export type BoostScalarWhereInput = {
    AND?: BoostScalarWhereInput | BoostScalarWhereInput[]
    OR?: BoostScalarWhereInput[]
    NOT?: BoostScalarWhereInput | BoostScalarWhereInput[]
    id?: StringFilter<"Boost"> | string
    barId?: StringFilter<"Boost"> | string
    eventId?: StringNullableFilter<"Boost"> | string | null
    startAt?: DateTimeFilter<"Boost"> | Date | string
    endAt?: DateTimeFilter<"Boost"> | Date | string
    budgetCents?: IntFilter<"Boost"> | number
    status?: StringFilter<"Boost"> | string
    createdAt?: DateTimeFilter<"Boost"> | Date | string
  }

  export type BarProductUpsertWithWhereUniqueWithoutBarInput = {
    where: BarProductWhereUniqueInput
    update: XOR<BarProductUpdateWithoutBarInput, BarProductUncheckedUpdateWithoutBarInput>
    create: XOR<BarProductCreateWithoutBarInput, BarProductUncheckedCreateWithoutBarInput>
  }

  export type BarProductUpdateWithWhereUniqueWithoutBarInput = {
    where: BarProductWhereUniqueInput
    data: XOR<BarProductUpdateWithoutBarInput, BarProductUncheckedUpdateWithoutBarInput>
  }

  export type BarProductUpdateManyWithWhereWithoutBarInput = {
    where: BarProductScalarWhereInput
    data: XOR<BarProductUpdateManyMutationInput, BarProductUncheckedUpdateManyWithoutBarInput>
  }

  export type BarProductScalarWhereInput = {
    AND?: BarProductScalarWhereInput | BarProductScalarWhereInput[]
    OR?: BarProductScalarWhereInput[]
    NOT?: BarProductScalarWhereInput | BarProductScalarWhereInput[]
    id?: StringFilter<"BarProduct"> | string
    barId?: StringFilter<"BarProduct"> | string
    productId?: StringNullableFilter<"BarProduct"> | string | null
    customName?: StringNullableFilter<"BarProduct"> | string | null
    parLevel?: IntNullableFilter<"BarProduct"> | number | null
    reorderThreshold?: IntNullableFilter<"BarProduct"> | number | null
    preferredVendor?: StringNullableFilter<"BarProduct"> | string | null
    isActive?: BoolFilter<"BarProduct"> | boolean
  }

  export type InventoryScanSessionUpsertWithWhereUniqueWithoutBarInput = {
    where: InventoryScanSessionWhereUniqueInput
    update: XOR<InventoryScanSessionUpdateWithoutBarInput, InventoryScanSessionUncheckedUpdateWithoutBarInput>
    create: XOR<InventoryScanSessionCreateWithoutBarInput, InventoryScanSessionUncheckedCreateWithoutBarInput>
  }

  export type InventoryScanSessionUpdateWithWhereUniqueWithoutBarInput = {
    where: InventoryScanSessionWhereUniqueInput
    data: XOR<InventoryScanSessionUpdateWithoutBarInput, InventoryScanSessionUncheckedUpdateWithoutBarInput>
  }

  export type InventoryScanSessionUpdateManyWithWhereWithoutBarInput = {
    where: InventoryScanSessionScalarWhereInput
    data: XOR<InventoryScanSessionUpdateManyMutationInput, InventoryScanSessionUncheckedUpdateManyWithoutBarInput>
  }

  export type InventoryScanSessionScalarWhereInput = {
    AND?: InventoryScanSessionScalarWhereInput | InventoryScanSessionScalarWhereInput[]
    OR?: InventoryScanSessionScalarWhereInput[]
    NOT?: InventoryScanSessionScalarWhereInput | InventoryScanSessionScalarWhereInput[]
    id?: StringFilter<"InventoryScanSession"> | string
    barId?: StringFilter<"InventoryScanSession"> | string
    createdByUserId?: StringNullableFilter<"InventoryScanSession"> | string | null
    imageUrl?: StringNullableFilter<"InventoryScanSession"> | string | null
    createdAt?: DateTimeFilter<"InventoryScanSession"> | Date | string
  }

  export type InventoryCountUpsertWithWhereUniqueWithoutBarInput = {
    where: InventoryCountWhereUniqueInput
    update: XOR<InventoryCountUpdateWithoutBarInput, InventoryCountUncheckedUpdateWithoutBarInput>
    create: XOR<InventoryCountCreateWithoutBarInput, InventoryCountUncheckedCreateWithoutBarInput>
  }

  export type InventoryCountUpdateWithWhereUniqueWithoutBarInput = {
    where: InventoryCountWhereUniqueInput
    data: XOR<InventoryCountUpdateWithoutBarInput, InventoryCountUncheckedUpdateWithoutBarInput>
  }

  export type InventoryCountUpdateManyWithWhereWithoutBarInput = {
    where: InventoryCountScalarWhereInput
    data: XOR<InventoryCountUpdateManyMutationInput, InventoryCountUncheckedUpdateManyWithoutBarInput>
  }

  export type InventoryCountScalarWhereInput = {
    AND?: InventoryCountScalarWhereInput | InventoryCountScalarWhereInput[]
    OR?: InventoryCountScalarWhereInput[]
    NOT?: InventoryCountScalarWhereInput | InventoryCountScalarWhereInput[]
    id?: StringFilter<"InventoryCount"> | string
    barId?: StringFilter<"InventoryCount"> | string
    productId?: StringFilter<"InventoryCount"> | string
    countedAt?: DateTimeFilter<"InventoryCount"> | Date | string
    quantity?: DecimalFilter<"InventoryCount"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"InventoryCount"> | string
    remainingPercent?: IntNullableFilter<"InventoryCount"> | number | null
    remainingBucket?: StringNullableFilter<"InventoryCount"> | string | null
    method?: StringFilter<"InventoryCount"> | string
    confidence?: FloatNullableFilter<"InventoryCount"> | number | null
    notes?: StringNullableFilter<"InventoryCount"> | string | null
  }

  export type PatronSearchEventUpsertWithWhereUniqueWithoutBarInput = {
    where: PatronSearchEventWhereUniqueInput
    update: XOR<PatronSearchEventUpdateWithoutBarInput, PatronSearchEventUncheckedUpdateWithoutBarInput>
    create: XOR<PatronSearchEventCreateWithoutBarInput, PatronSearchEventUncheckedCreateWithoutBarInput>
  }

  export type PatronSearchEventUpdateWithWhereUniqueWithoutBarInput = {
    where: PatronSearchEventWhereUniqueInput
    data: XOR<PatronSearchEventUpdateWithoutBarInput, PatronSearchEventUncheckedUpdateWithoutBarInput>
  }

  export type PatronSearchEventUpdateManyWithWhereWithoutBarInput = {
    where: PatronSearchEventScalarWhereInput
    data: XOR<PatronSearchEventUpdateManyMutationInput, PatronSearchEventUncheckedUpdateManyWithoutBarInput>
  }

  export type PatronSearchEventScalarWhereInput = {
    AND?: PatronSearchEventScalarWhereInput | PatronSearchEventScalarWhereInput[]
    OR?: PatronSearchEventScalarWhereInput[]
    NOT?: PatronSearchEventScalarWhereInput | PatronSearchEventScalarWhereInput[]
    id?: StringFilter<"PatronSearchEvent"> | string
    barId?: StringNullableFilter<"PatronSearchEvent"> | string | null
    query?: StringNullableFilter<"PatronSearchEvent"> | string | null
    category?: StringNullableFilter<"PatronSearchEvent"> | string | null
    city?: StringNullableFilter<"PatronSearchEvent"> | string | null
    createdAt?: DateTimeFilter<"PatronSearchEvent"> | Date | string
  }

  export type BarActionUpsertWithWhereUniqueWithoutBarInput = {
    where: BarActionWhereUniqueInput
    update: XOR<BarActionUpdateWithoutBarInput, BarActionUncheckedUpdateWithoutBarInput>
    create: XOR<BarActionCreateWithoutBarInput, BarActionUncheckedCreateWithoutBarInput>
  }

  export type BarActionUpdateWithWhereUniqueWithoutBarInput = {
    where: BarActionWhereUniqueInput
    data: XOR<BarActionUpdateWithoutBarInput, BarActionUncheckedUpdateWithoutBarInput>
  }

  export type BarActionUpdateManyWithWhereWithoutBarInput = {
    where: BarActionScalarWhereInput
    data: XOR<BarActionUpdateManyMutationInput, BarActionUncheckedUpdateManyWithoutBarInput>
  }

  export type BarActionScalarWhereInput = {
    AND?: BarActionScalarWhereInput | BarActionScalarWhereInput[]
    OR?: BarActionScalarWhereInput[]
    NOT?: BarActionScalarWhereInput | BarActionScalarWhereInput[]
    id?: StringFilter<"BarAction"> | string
    barId?: StringFilter<"BarAction"> | string
    action?: StringFilter<"BarAction"> | string
    createdAt?: DateTimeFilter<"BarAction"> | Date | string
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutBarInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutBarInput, AdminNoteUncheckedUpdateWithoutBarInput>
    create: XOR<AdminNoteCreateWithoutBarInput, AdminNoteUncheckedCreateWithoutBarInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutBarInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutBarInput, AdminNoteUncheckedUpdateWithoutBarInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutBarInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutBarInput>
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutBarInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutBarInput, SupportTicketUncheckedUpdateWithoutBarInput>
    create: XOR<SupportTicketCreateWithoutBarInput, SupportTicketUncheckedCreateWithoutBarInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutBarInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutBarInput, SupportTicketUncheckedUpdateWithoutBarInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutBarInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutBarInput>
  }

  export type BarCreateWithoutOfferingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutOfferingsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutOfferingsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutOfferingsInput, BarUncheckedCreateWithoutOfferingsInput>
  }

  export type BarUpsertWithoutOfferingsInput = {
    update: XOR<BarUpdateWithoutOfferingsInput, BarUncheckedUpdateWithoutOfferingsInput>
    create: XOR<BarCreateWithoutOfferingsInput, BarUncheckedCreateWithoutOfferingsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutOfferingsInput, BarUncheckedUpdateWithoutOfferingsInput>
  }

  export type BarUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutEventsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutEventsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutEventsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutEventsInput, BarUncheckedCreateWithoutEventsInput>
  }

  export type BarUpsertWithoutEventsInput = {
    update: XOR<BarUpdateWithoutEventsInput, BarUncheckedUpdateWithoutEventsInput>
    create: XOR<BarCreateWithoutEventsInput, BarUncheckedCreateWithoutEventsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutEventsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutEventsInput, BarUncheckedUpdateWithoutEventsInput>
  }

  export type BarUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type BarCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutFavoritesInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutFavoritesInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutFavoritesInput, BarUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarUpsertWithoutFavoritesInput = {
    update: XOR<BarUpdateWithoutFavoritesInput, BarUncheckedUpdateWithoutFavoritesInput>
    create: XOR<BarCreateWithoutFavoritesInput, BarUncheckedCreateWithoutFavoritesInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutFavoritesInput, BarUncheckedUpdateWithoutFavoritesInput>
  }

  export type BarUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutCategoryRequestsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutCategoryRequestsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutCategoryRequestsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutCategoryRequestsInput, BarUncheckedCreateWithoutCategoryRequestsInput>
  }

  export type OwnerCreateWithoutCategoryRequestsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutCategoryRequestsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarUncheckedCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutCategoryRequestsInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutCategoryRequestsInput, OwnerUncheckedCreateWithoutCategoryRequestsInput>
  }

  export type BarUpsertWithoutCategoryRequestsInput = {
    update: XOR<BarUpdateWithoutCategoryRequestsInput, BarUncheckedUpdateWithoutCategoryRequestsInput>
    create: XOR<BarCreateWithoutCategoryRequestsInput, BarUncheckedCreateWithoutCategoryRequestsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutCategoryRequestsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutCategoryRequestsInput, BarUncheckedUpdateWithoutCategoryRequestsInput>
  }

  export type BarUpdateWithoutCategoryRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutCategoryRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type OwnerUpsertWithoutCategoryRequestsInput = {
    update: XOR<OwnerUpdateWithoutCategoryRequestsInput, OwnerUncheckedUpdateWithoutCategoryRequestsInput>
    create: XOR<OwnerCreateWithoutCategoryRequestsInput, OwnerUncheckedCreateWithoutCategoryRequestsInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutCategoryRequestsInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutCategoryRequestsInput, OwnerUncheckedUpdateWithoutCategoryRequestsInput>
  }

  export type OwnerUpdateWithoutCategoryRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutCategoryRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUncheckedUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarUncheckedCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutOwnerInput
    promoRedemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutPasswordResetsInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutPasswordResetsInput, OwnerUncheckedCreateWithoutPasswordResetsInput>
  }

  export type OwnerUpsertWithoutPasswordResetsInput = {
    update: XOR<OwnerUpdateWithoutPasswordResetsInput, OwnerUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<OwnerCreateWithoutPasswordResetsInput, OwnerUncheckedCreateWithoutPasswordResetsInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutPasswordResetsInput, OwnerUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type OwnerUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUncheckedUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PromoRedemptionCreateWithoutPromoCodeInput = {
    id?: string
    redeemedAt?: Date | string
    owner: OwnerCreateNestedOneWithoutPromoRedemptionsInput
  }

  export type PromoRedemptionUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    ownerId: string
    redeemedAt?: Date | string
  }

  export type PromoRedemptionCreateOrConnectWithoutPromoCodeInput = {
    where: PromoRedemptionWhereUniqueInput
    create: XOR<PromoRedemptionCreateWithoutPromoCodeInput, PromoRedemptionUncheckedCreateWithoutPromoCodeInput>
  }

  export type PromoRedemptionCreateManyPromoCodeInputEnvelope = {
    data: PromoRedemptionCreateManyPromoCodeInput | PromoRedemptionCreateManyPromoCodeInput[]
    skipDuplicates?: boolean
  }

  export type PromoRedemptionUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: PromoRedemptionWhereUniqueInput
    update: XOR<PromoRedemptionUpdateWithoutPromoCodeInput, PromoRedemptionUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<PromoRedemptionCreateWithoutPromoCodeInput, PromoRedemptionUncheckedCreateWithoutPromoCodeInput>
  }

  export type PromoRedemptionUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: PromoRedemptionWhereUniqueInput
    data: XOR<PromoRedemptionUpdateWithoutPromoCodeInput, PromoRedemptionUncheckedUpdateWithoutPromoCodeInput>
  }

  export type PromoRedemptionUpdateManyWithWhereWithoutPromoCodeInput = {
    where: PromoRedemptionScalarWhereInput
    data: XOR<PromoRedemptionUpdateManyMutationInput, PromoRedemptionUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type PromoCodeCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    description?: string | null
    isActive?: boolean
    maxRedemptions?: number | null
    usedCount?: number
    expiresAt?: Date | string | null
    grantPlan?: $Enums.SubscriptionPlan | null
    grantMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    description?: string | null
    isActive?: boolean
    maxRedemptions?: number | null
    usedCount?: number
    expiresAt?: Date | string | null
    grantPlan?: $Enums.SubscriptionPlan | null
    grantMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutRedemptionsInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutRedemptionsInput, PromoCodeUncheckedCreateWithoutRedemptionsInput>
  }

  export type OwnerCreateWithoutPromoRedemptionsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutPromoRedemptionsInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarUncheckedCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOwnerInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutPromoRedemptionsInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutPromoRedemptionsInput, OwnerUncheckedCreateWithoutPromoRedemptionsInput>
  }

  export type PromoCodeUpsertWithoutRedemptionsInput = {
    update: XOR<PromoCodeUpdateWithoutRedemptionsInput, PromoCodeUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<PromoCodeCreateWithoutRedemptionsInput, PromoCodeUncheckedCreateWithoutRedemptionsInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutRedemptionsInput, PromoCodeUncheckedUpdateWithoutRedemptionsInput>
  }

  export type PromoCodeUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grantPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    grantMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grantPlan?: NullableEnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan | null
    grantMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerUpsertWithoutPromoRedemptionsInput = {
    update: XOR<OwnerUpdateWithoutPromoRedemptionsInput, OwnerUncheckedUpdateWithoutPromoRedemptionsInput>
    create: XOR<OwnerCreateWithoutPromoRedemptionsInput, OwnerUncheckedCreateWithoutPromoRedemptionsInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutPromoRedemptionsInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutPromoRedemptionsInput, OwnerUncheckedUpdateWithoutPromoRedemptionsInput>
  }

  export type OwnerUpdateWithoutPromoRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutPromoRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUncheckedUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type BarCreateWithoutAnalyticsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutAnalyticsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutAnalyticsInput, BarUncheckedCreateWithoutAnalyticsInput>
  }

  export type BarUpsertWithoutAnalyticsInput = {
    update: XOR<BarUpdateWithoutAnalyticsInput, BarUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<BarCreateWithoutAnalyticsInput, BarUncheckedCreateWithoutAnalyticsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutAnalyticsInput, BarUncheckedUpdateWithoutAnalyticsInput>
  }

  export type BarUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutClicksInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutClicksInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutClicksInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutClicksInput, BarUncheckedCreateWithoutClicksInput>
  }

  export type BarUpsertWithoutClicksInput = {
    update: XOR<BarUpdateWithoutClicksInput, BarUncheckedUpdateWithoutClicksInput>
    create: XOR<BarCreateWithoutClicksInput, BarUncheckedCreateWithoutClicksInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutClicksInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutClicksInput, BarUncheckedUpdateWithoutClicksInput>
  }

  export type BarUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarBadgeCreateWithoutBadgeInput = {
    id?: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bar: BarCreateNestedOneWithoutBadgesInput
  }

  export type BarBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    barId: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeCreateOrConnectWithoutBadgeInput = {
    where: BarBadgeWhereUniqueInput
    create: XOR<BarBadgeCreateWithoutBadgeInput, BarBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type BarBadgeCreateManyBadgeInputEnvelope = {
    data: BarBadgeCreateManyBadgeInput | BarBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type BarBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: BarBadgeWhereUniqueInput
    update: XOR<BarBadgeUpdateWithoutBadgeInput, BarBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<BarBadgeCreateWithoutBadgeInput, BarBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type BarBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: BarBadgeWhereUniqueInput
    data: XOR<BarBadgeUpdateWithoutBadgeInput, BarBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type BarBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: BarBadgeScalarWhereInput
    data: XOR<BarBadgeUpdateManyMutationInput, BarBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type BarCreateWithoutBadgesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutBadgesInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutBadgesInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutBadgesInput, BarUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeCreateWithoutBarBadgesInput = {
    id?: string
    key: string
    name: string
    description: string
    icon: string
    tier?: $Enums.BadgeTier
    category: $Enums.BadgeCategory
    requirement: string
    color: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutBarBadgesInput = {
    id?: string
    key: string
    name: string
    description: string
    icon: string
    tier?: $Enums.BadgeTier
    category: $Enums.BadgeCategory
    requirement: string
    color: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutBarBadgesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutBarBadgesInput, BadgeUncheckedCreateWithoutBarBadgesInput>
  }

  export type BarUpsertWithoutBadgesInput = {
    update: XOR<BarUpdateWithoutBadgesInput, BarUncheckedUpdateWithoutBadgesInput>
    create: XOR<BarCreateWithoutBadgesInput, BarUncheckedCreateWithoutBadgesInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutBadgesInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutBadgesInput, BarUncheckedUpdateWithoutBadgesInput>
  }

  export type BarUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BadgeUpsertWithoutBarBadgesInput = {
    update: XOR<BadgeUpdateWithoutBarBadgesInput, BadgeUncheckedUpdateWithoutBarBadgesInput>
    create: XOR<BadgeCreateWithoutBarBadgesInput, BadgeUncheckedCreateWithoutBarBadgesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutBarBadgesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutBarBadgesInput, BadgeUncheckedUpdateWithoutBarBadgesInput>
  }

  export type BadgeUpdateWithoutBarBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    tier?: EnumBadgeTierFieldUpdateOperationsInput | $Enums.BadgeTier
    category?: EnumBadgeCategoryFieldUpdateOperationsInput | $Enums.BadgeCategory
    requirement?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutBarBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    tier?: EnumBadgeTierFieldUpdateOperationsInput | $Enums.BadgeTier
    category?: EnumBadgeCategoryFieldUpdateOperationsInput | $Enums.BadgeCategory
    requirement?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutInventoryItemsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutInventoryItemsInput, BarUncheckedCreateWithoutInventoryItemsInput>
  }

  export type InventorySnapshotItemCreateWithoutInventoryItemInput = {
    id?: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    snapshot: InventorySnapshotCreateNestedOneWithoutItemsInput
    bottlePhoto?: BottlePhotoCreateNestedOneWithoutSnapshotItemInput
  }

  export type InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    snapshotId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    bottlePhoto?: BottlePhotoUncheckedCreateNestedOneWithoutSnapshotItemInput
  }

  export type InventorySnapshotItemCreateOrConnectWithoutInventoryItemInput = {
    where: InventorySnapshotItemWhereUniqueInput
    create: XOR<InventorySnapshotItemCreateWithoutInventoryItemInput, InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type InventorySnapshotItemCreateManyInventoryItemInputEnvelope = {
    data: InventorySnapshotItemCreateManyInventoryItemInput | InventorySnapshotItemCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type ShiftUsageItemCreateWithoutInventoryItemInput = {
    id?: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
    shiftUsage: ShiftUsageCreateNestedOneWithoutItemsInput
  }

  export type ShiftUsageItemUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    shiftUsageId: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type ShiftUsageItemCreateOrConnectWithoutInventoryItemInput = {
    where: ShiftUsageItemWhereUniqueInput
    create: XOR<ShiftUsageItemCreateWithoutInventoryItemInput, ShiftUsageItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type ShiftUsageItemCreateManyInventoryItemInputEnvelope = {
    data: ShiftUsageItemCreateManyInventoryItemInput | ShiftUsageItemCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type CostingProfileCreateWithoutInventoryItemInput = {
    id?: string
    pourSizeOz: Decimal | DecimalJsLike | number | string
    menuPrice: Decimal | DecimalJsLike | number | string
    costPerPour: Decimal | DecimalJsLike | number | string
    marginPct: Decimal | DecimalJsLike | number | string
    profitPerBottle: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostingProfileUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    pourSizeOz: Decimal | DecimalJsLike | number | string
    menuPrice: Decimal | DecimalJsLike | number | string
    costPerPour: Decimal | DecimalJsLike | number | string
    marginPct: Decimal | DecimalJsLike | number | string
    profitPerBottle: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CostingProfileCreateOrConnectWithoutInventoryItemInput = {
    where: CostingProfileWhereUniqueInput
    create: XOR<CostingProfileCreateWithoutInventoryItemInput, CostingProfileUncheckedCreateWithoutInventoryItemInput>
  }

  export type CostingProfileCreateManyInventoryItemInputEnvelope = {
    data: CostingProfileCreateManyInventoryItemInput | CostingProfileCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type VarianceAlertCreateWithoutInventoryItemInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutVarianceAlertsInput
  }

  export type VarianceAlertUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    barId: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
  }

  export type VarianceAlertCreateOrConnectWithoutInventoryItemInput = {
    where: VarianceAlertWhereUniqueInput
    create: XOR<VarianceAlertCreateWithoutInventoryItemInput, VarianceAlertUncheckedCreateWithoutInventoryItemInput>
  }

  export type VarianceAlertCreateManyInventoryItemInputEnvelope = {
    data: VarianceAlertCreateManyInventoryItemInput | VarianceAlertCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithoutInventoryItemsInput = {
    update: XOR<BarUpdateWithoutInventoryItemsInput, BarUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<BarCreateWithoutInventoryItemsInput, BarUncheckedCreateWithoutInventoryItemsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutInventoryItemsInput, BarUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type BarUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type InventorySnapshotItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: InventorySnapshotItemWhereUniqueInput
    update: XOR<InventorySnapshotItemUpdateWithoutInventoryItemInput, InventorySnapshotItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<InventorySnapshotItemCreateWithoutInventoryItemInput, InventorySnapshotItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type InventorySnapshotItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: InventorySnapshotItemWhereUniqueInput
    data: XOR<InventorySnapshotItemUpdateWithoutInventoryItemInput, InventorySnapshotItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type InventorySnapshotItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: InventorySnapshotItemScalarWhereInput
    data: XOR<InventorySnapshotItemUpdateManyMutationInput, InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type InventorySnapshotItemScalarWhereInput = {
    AND?: InventorySnapshotItemScalarWhereInput | InventorySnapshotItemScalarWhereInput[]
    OR?: InventorySnapshotItemScalarWhereInput[]
    NOT?: InventorySnapshotItemScalarWhereInput | InventorySnapshotItemScalarWhereInput[]
    id?: StringFilter<"InventorySnapshotItem"> | string
    snapshotId?: StringFilter<"InventorySnapshotItem"> | string
    inventoryItemId?: StringFilter<"InventorySnapshotItem"> | string
    quantityOnHand?: DecimalFilter<"InventorySnapshotItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"InventorySnapshotItem"> | string | null
  }

  export type ShiftUsageItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: ShiftUsageItemWhereUniqueInput
    update: XOR<ShiftUsageItemUpdateWithoutInventoryItemInput, ShiftUsageItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<ShiftUsageItemCreateWithoutInventoryItemInput, ShiftUsageItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type ShiftUsageItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: ShiftUsageItemWhereUniqueInput
    data: XOR<ShiftUsageItemUpdateWithoutInventoryItemInput, ShiftUsageItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type ShiftUsageItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: ShiftUsageItemScalarWhereInput
    data: XOR<ShiftUsageItemUpdateManyMutationInput, ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type ShiftUsageItemScalarWhereInput = {
    AND?: ShiftUsageItemScalarWhereInput | ShiftUsageItemScalarWhereInput[]
    OR?: ShiftUsageItemScalarWhereInput[]
    NOT?: ShiftUsageItemScalarWhereInput | ShiftUsageItemScalarWhereInput[]
    id?: StringFilter<"ShiftUsageItem"> | string
    shiftUsageId?: StringFilter<"ShiftUsageItem"> | string
    inventoryItemId?: StringFilter<"ShiftUsageItem"> | string
    quantityUsed?: DecimalFilter<"ShiftUsageItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ShiftUsageItem"> | string | null
  }

  export type CostingProfileUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: CostingProfileWhereUniqueInput
    update: XOR<CostingProfileUpdateWithoutInventoryItemInput, CostingProfileUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<CostingProfileCreateWithoutInventoryItemInput, CostingProfileUncheckedCreateWithoutInventoryItemInput>
  }

  export type CostingProfileUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: CostingProfileWhereUniqueInput
    data: XOR<CostingProfileUpdateWithoutInventoryItemInput, CostingProfileUncheckedUpdateWithoutInventoryItemInput>
  }

  export type CostingProfileUpdateManyWithWhereWithoutInventoryItemInput = {
    where: CostingProfileScalarWhereInput
    data: XOR<CostingProfileUpdateManyMutationInput, CostingProfileUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type CostingProfileScalarWhereInput = {
    AND?: CostingProfileScalarWhereInput | CostingProfileScalarWhereInput[]
    OR?: CostingProfileScalarWhereInput[]
    NOT?: CostingProfileScalarWhereInput | CostingProfileScalarWhereInput[]
    id?: StringFilter<"CostingProfile"> | string
    inventoryItemId?: StringFilter<"CostingProfile"> | string
    pourSizeOz?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFilter<"CostingProfile"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CostingProfile"> | Date | string
  }

  export type VarianceAlertUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: VarianceAlertWhereUniqueInput
    update: XOR<VarianceAlertUpdateWithoutInventoryItemInput, VarianceAlertUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<VarianceAlertCreateWithoutInventoryItemInput, VarianceAlertUncheckedCreateWithoutInventoryItemInput>
  }

  export type VarianceAlertUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: VarianceAlertWhereUniqueInput
    data: XOR<VarianceAlertUpdateWithoutInventoryItemInput, VarianceAlertUncheckedUpdateWithoutInventoryItemInput>
  }

  export type VarianceAlertUpdateManyWithWhereWithoutInventoryItemInput = {
    where: VarianceAlertScalarWhereInput
    data: XOR<VarianceAlertUpdateManyMutationInput, VarianceAlertUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type BarCreateWithoutInventoryImportsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutInventoryImportsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutInventoryImportsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutInventoryImportsInput, BarUncheckedCreateWithoutInventoryImportsInput>
  }

  export type UserCreateWithoutInventoryImportsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryImportsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryImportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryImportsInput, UserUncheckedCreateWithoutInventoryImportsInput>
  }

  export type BarUpsertWithoutInventoryImportsInput = {
    update: XOR<BarUpdateWithoutInventoryImportsInput, BarUncheckedUpdateWithoutInventoryImportsInput>
    create: XOR<BarCreateWithoutInventoryImportsInput, BarUncheckedCreateWithoutInventoryImportsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutInventoryImportsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutInventoryImportsInput, BarUncheckedUpdateWithoutInventoryImportsInput>
  }

  export type BarUpdateWithoutInventoryImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutInventoryImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserUpsertWithoutInventoryImportsInput = {
    update: XOR<UserUpdateWithoutInventoryImportsInput, UserUncheckedUpdateWithoutInventoryImportsInput>
    create: XOR<UserCreateWithoutInventoryImportsInput, UserUncheckedCreateWithoutInventoryImportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryImportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryImportsInput, UserUncheckedUpdateWithoutInventoryImportsInput>
  }

  export type UserUpdateWithoutInventoryImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarCreateWithoutShiftUsagesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutShiftUsagesInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutShiftUsagesInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutShiftUsagesInput, BarUncheckedCreateWithoutShiftUsagesInput>
  }

  export type UserCreateWithoutShiftUsagesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShiftUsagesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShiftUsagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftUsagesInput, UserUncheckedCreateWithoutShiftUsagesInput>
  }

  export type ShiftUsageItemCreateWithoutShiftUsageInput = {
    id?: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
    inventoryItem: InventoryItemCreateNestedOneWithoutShiftUsageItemsInput
  }

  export type ShiftUsageItemUncheckedCreateWithoutShiftUsageInput = {
    id?: string
    inventoryItemId: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type ShiftUsageItemCreateOrConnectWithoutShiftUsageInput = {
    where: ShiftUsageItemWhereUniqueInput
    create: XOR<ShiftUsageItemCreateWithoutShiftUsageInput, ShiftUsageItemUncheckedCreateWithoutShiftUsageInput>
  }

  export type ShiftUsageItemCreateManyShiftUsageInputEnvelope = {
    data: ShiftUsageItemCreateManyShiftUsageInput | ShiftUsageItemCreateManyShiftUsageInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithoutShiftUsagesInput = {
    update: XOR<BarUpdateWithoutShiftUsagesInput, BarUncheckedUpdateWithoutShiftUsagesInput>
    create: XOR<BarCreateWithoutShiftUsagesInput, BarUncheckedCreateWithoutShiftUsagesInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutShiftUsagesInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutShiftUsagesInput, BarUncheckedUpdateWithoutShiftUsagesInput>
  }

  export type BarUpdateWithoutShiftUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutShiftUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserUpsertWithoutShiftUsagesInput = {
    update: XOR<UserUpdateWithoutShiftUsagesInput, UserUncheckedUpdateWithoutShiftUsagesInput>
    create: XOR<UserCreateWithoutShiftUsagesInput, UserUncheckedCreateWithoutShiftUsagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftUsagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftUsagesInput, UserUncheckedUpdateWithoutShiftUsagesInput>
  }

  export type UserUpdateWithoutShiftUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShiftUsageItemUpsertWithWhereUniqueWithoutShiftUsageInput = {
    where: ShiftUsageItemWhereUniqueInput
    update: XOR<ShiftUsageItemUpdateWithoutShiftUsageInput, ShiftUsageItemUncheckedUpdateWithoutShiftUsageInput>
    create: XOR<ShiftUsageItemCreateWithoutShiftUsageInput, ShiftUsageItemUncheckedCreateWithoutShiftUsageInput>
  }

  export type ShiftUsageItemUpdateWithWhereUniqueWithoutShiftUsageInput = {
    where: ShiftUsageItemWhereUniqueInput
    data: XOR<ShiftUsageItemUpdateWithoutShiftUsageInput, ShiftUsageItemUncheckedUpdateWithoutShiftUsageInput>
  }

  export type ShiftUsageItemUpdateManyWithWhereWithoutShiftUsageInput = {
    where: ShiftUsageItemScalarWhereInput
    data: XOR<ShiftUsageItemUpdateManyMutationInput, ShiftUsageItemUncheckedUpdateManyWithoutShiftUsageInput>
  }

  export type ShiftUsageCreateWithoutItemsInput = {
    id?: string
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutShiftUsagesInput
    user?: UserCreateNestedOneWithoutShiftUsagesInput
  }

  export type ShiftUsageUncheckedCreateWithoutItemsInput = {
    id?: string
    barId: string
    userId?: string | null
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ShiftUsageCreateOrConnectWithoutItemsInput = {
    where: ShiftUsageWhereUniqueInput
    create: XOR<ShiftUsageCreateWithoutItemsInput, ShiftUsageUncheckedCreateWithoutItemsInput>
  }

  export type InventoryItemCreateWithoutShiftUsageItemsInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryItemsInput
    snapshotItems?: InventorySnapshotItemCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutShiftUsageItemsInput = {
    id?: string
    barId: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshotItems?: InventorySnapshotItemUncheckedCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileUncheckedCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutShiftUsageItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutShiftUsageItemsInput, InventoryItemUncheckedCreateWithoutShiftUsageItemsInput>
  }

  export type ShiftUsageUpsertWithoutItemsInput = {
    update: XOR<ShiftUsageUpdateWithoutItemsInput, ShiftUsageUncheckedUpdateWithoutItemsInput>
    create: XOR<ShiftUsageCreateWithoutItemsInput, ShiftUsageUncheckedCreateWithoutItemsInput>
    where?: ShiftUsageWhereInput
  }

  export type ShiftUsageUpdateToOneWithWhereWithoutItemsInput = {
    where?: ShiftUsageWhereInput
    data: XOR<ShiftUsageUpdateWithoutItemsInput, ShiftUsageUncheckedUpdateWithoutItemsInput>
  }

  export type ShiftUsageUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutShiftUsagesNestedInput
    user?: UserUpdateOneWithoutShiftUsagesNestedInput
  }

  export type ShiftUsageUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithoutShiftUsageItemsInput = {
    update: XOR<InventoryItemUpdateWithoutShiftUsageItemsInput, InventoryItemUncheckedUpdateWithoutShiftUsageItemsInput>
    create: XOR<InventoryItemCreateWithoutShiftUsageItemsInput, InventoryItemUncheckedCreateWithoutShiftUsageItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutShiftUsageItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutShiftUsageItemsInput, InventoryItemUncheckedUpdateWithoutShiftUsageItemsInput>
  }

  export type InventoryItemUpdateWithoutShiftUsageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryItemsNestedInput
    snapshotItems?: InventorySnapshotItemUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutShiftUsageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItems?: InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUncheckedUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type BarCreateWithoutInventorySnapshotsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutInventorySnapshotsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutInventorySnapshotsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutInventorySnapshotsInput, BarUncheckedCreateWithoutInventorySnapshotsInput>
  }

  export type UserCreateWithoutInventorySnapshotsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventorySnapshotsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventorySnapshotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventorySnapshotsInput, UserUncheckedCreateWithoutInventorySnapshotsInput>
  }

  export type InventorySnapshotItemCreateWithoutSnapshotInput = {
    id?: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    inventoryItem: InventoryItemCreateNestedOneWithoutSnapshotItemsInput
    bottlePhoto?: BottlePhotoCreateNestedOneWithoutSnapshotItemInput
  }

  export type InventorySnapshotItemUncheckedCreateWithoutSnapshotInput = {
    id?: string
    inventoryItemId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    bottlePhoto?: BottlePhotoUncheckedCreateNestedOneWithoutSnapshotItemInput
  }

  export type InventorySnapshotItemCreateOrConnectWithoutSnapshotInput = {
    where: InventorySnapshotItemWhereUniqueInput
    create: XOR<InventorySnapshotItemCreateWithoutSnapshotInput, InventorySnapshotItemUncheckedCreateWithoutSnapshotInput>
  }

  export type InventorySnapshotItemCreateManySnapshotInputEnvelope = {
    data: InventorySnapshotItemCreateManySnapshotInput | InventorySnapshotItemCreateManySnapshotInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithoutInventorySnapshotsInput = {
    update: XOR<BarUpdateWithoutInventorySnapshotsInput, BarUncheckedUpdateWithoutInventorySnapshotsInput>
    create: XOR<BarCreateWithoutInventorySnapshotsInput, BarUncheckedCreateWithoutInventorySnapshotsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutInventorySnapshotsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutInventorySnapshotsInput, BarUncheckedUpdateWithoutInventorySnapshotsInput>
  }

  export type BarUpdateWithoutInventorySnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutInventorySnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserUpsertWithoutInventorySnapshotsInput = {
    update: XOR<UserUpdateWithoutInventorySnapshotsInput, UserUncheckedUpdateWithoutInventorySnapshotsInput>
    create: XOR<UserCreateWithoutInventorySnapshotsInput, UserUncheckedCreateWithoutInventorySnapshotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventorySnapshotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventorySnapshotsInput, UserUncheckedUpdateWithoutInventorySnapshotsInput>
  }

  export type UserUpdateWithoutInventorySnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventorySnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InventorySnapshotItemUpsertWithWhereUniqueWithoutSnapshotInput = {
    where: InventorySnapshotItemWhereUniqueInput
    update: XOR<InventorySnapshotItemUpdateWithoutSnapshotInput, InventorySnapshotItemUncheckedUpdateWithoutSnapshotInput>
    create: XOR<InventorySnapshotItemCreateWithoutSnapshotInput, InventorySnapshotItemUncheckedCreateWithoutSnapshotInput>
  }

  export type InventorySnapshotItemUpdateWithWhereUniqueWithoutSnapshotInput = {
    where: InventorySnapshotItemWhereUniqueInput
    data: XOR<InventorySnapshotItemUpdateWithoutSnapshotInput, InventorySnapshotItemUncheckedUpdateWithoutSnapshotInput>
  }

  export type InventorySnapshotItemUpdateManyWithWhereWithoutSnapshotInput = {
    where: InventorySnapshotItemScalarWhereInput
    data: XOR<InventorySnapshotItemUpdateManyMutationInput, InventorySnapshotItemUncheckedUpdateManyWithoutSnapshotInput>
  }

  export type InventorySnapshotCreateWithoutItemsInput = {
    id?: string
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventorySnapshotsInput
    user?: UserCreateNestedOneWithoutInventorySnapshotsInput
  }

  export type InventorySnapshotUncheckedCreateWithoutItemsInput = {
    id?: string
    barId: string
    userId?: string | null
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventorySnapshotCreateOrConnectWithoutItemsInput = {
    where: InventorySnapshotWhereUniqueInput
    create: XOR<InventorySnapshotCreateWithoutItemsInput, InventorySnapshotUncheckedCreateWithoutItemsInput>
  }

  export type InventoryItemCreateWithoutSnapshotItemsInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryItemsInput
    shiftUsageItems?: ShiftUsageItemCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutSnapshotItemsInput = {
    id?: string
    barId: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shiftUsageItems?: ShiftUsageItemUncheckedCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileUncheckedCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutSnapshotItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutSnapshotItemsInput, InventoryItemUncheckedCreateWithoutSnapshotItemsInput>
  }

  export type BottlePhotoCreateWithoutSnapshotItemInput = {
    id?: string
    imageUrl: string
    estimatedPct?: Decimal | DecimalJsLike | number | string | null
    estimatedMl?: Decimal | DecimalJsLike | number | string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type BottlePhotoUncheckedCreateWithoutSnapshotItemInput = {
    id?: string
    imageUrl: string
    estimatedPct?: Decimal | DecimalJsLike | number | string | null
    estimatedMl?: Decimal | DecimalJsLike | number | string | null
    modelVersion?: string | null
    createdAt?: Date | string
  }

  export type BottlePhotoCreateOrConnectWithoutSnapshotItemInput = {
    where: BottlePhotoWhereUniqueInput
    create: XOR<BottlePhotoCreateWithoutSnapshotItemInput, BottlePhotoUncheckedCreateWithoutSnapshotItemInput>
  }

  export type InventorySnapshotUpsertWithoutItemsInput = {
    update: XOR<InventorySnapshotUpdateWithoutItemsInput, InventorySnapshotUncheckedUpdateWithoutItemsInput>
    create: XOR<InventorySnapshotCreateWithoutItemsInput, InventorySnapshotUncheckedCreateWithoutItemsInput>
    where?: InventorySnapshotWhereInput
  }

  export type InventorySnapshotUpdateToOneWithWhereWithoutItemsInput = {
    where?: InventorySnapshotWhereInput
    data: XOR<InventorySnapshotUpdateWithoutItemsInput, InventorySnapshotUncheckedUpdateWithoutItemsInput>
  }

  export type InventorySnapshotUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventorySnapshotsNestedInput
    user?: UserUpdateOneWithoutInventorySnapshotsNestedInput
  }

  export type InventorySnapshotUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithoutSnapshotItemsInput = {
    update: XOR<InventoryItemUpdateWithoutSnapshotItemsInput, InventoryItemUncheckedUpdateWithoutSnapshotItemsInput>
    create: XOR<InventoryItemCreateWithoutSnapshotItemsInput, InventoryItemUncheckedCreateWithoutSnapshotItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutSnapshotItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutSnapshotItemsInput, InventoryItemUncheckedUpdateWithoutSnapshotItemsInput>
  }

  export type InventoryItemUpdateWithoutSnapshotItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryItemsNestedInput
    shiftUsageItems?: ShiftUsageItemUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutSnapshotItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftUsageItems?: ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUncheckedUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type BottlePhotoUpsertWithoutSnapshotItemInput = {
    update: XOR<BottlePhotoUpdateWithoutSnapshotItemInput, BottlePhotoUncheckedUpdateWithoutSnapshotItemInput>
    create: XOR<BottlePhotoCreateWithoutSnapshotItemInput, BottlePhotoUncheckedCreateWithoutSnapshotItemInput>
    where?: BottlePhotoWhereInput
  }

  export type BottlePhotoUpdateToOneWithWhereWithoutSnapshotItemInput = {
    where?: BottlePhotoWhereInput
    data: XOR<BottlePhotoUpdateWithoutSnapshotItemInput, BottlePhotoUncheckedUpdateWithoutSnapshotItemInput>
  }

  export type BottlePhotoUpdateWithoutSnapshotItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    estimatedPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BottlePhotoUncheckedUpdateWithoutSnapshotItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    estimatedPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estimatedMl?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventorySnapshotItemCreateWithoutBottlePhotoInput = {
    id?: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
    snapshot: InventorySnapshotCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutSnapshotItemsInput
  }

  export type InventorySnapshotItemUncheckedCreateWithoutBottlePhotoInput = {
    id?: string
    snapshotId: string
    inventoryItemId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type InventorySnapshotItemCreateOrConnectWithoutBottlePhotoInput = {
    where: InventorySnapshotItemWhereUniqueInput
    create: XOR<InventorySnapshotItemCreateWithoutBottlePhotoInput, InventorySnapshotItemUncheckedCreateWithoutBottlePhotoInput>
  }

  export type InventorySnapshotItemUpsertWithoutBottlePhotoInput = {
    update: XOR<InventorySnapshotItemUpdateWithoutBottlePhotoInput, InventorySnapshotItemUncheckedUpdateWithoutBottlePhotoInput>
    create: XOR<InventorySnapshotItemCreateWithoutBottlePhotoInput, InventorySnapshotItemUncheckedCreateWithoutBottlePhotoInput>
    where?: InventorySnapshotItemWhereInput
  }

  export type InventorySnapshotItemUpdateToOneWithWhereWithoutBottlePhotoInput = {
    where?: InventorySnapshotItemWhereInput
    data: XOR<InventorySnapshotItemUpdateWithoutBottlePhotoInput, InventorySnapshotItemUncheckedUpdateWithoutBottlePhotoInput>
  }

  export type InventorySnapshotItemUpdateWithoutBottlePhotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: InventorySnapshotUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSnapshotItemsNestedInput
  }

  export type InventorySnapshotItemUncheckedUpdateWithoutBottlePhotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryItemCreateWithoutCostingProfilesInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryItemsInput
    snapshotItems?: InventorySnapshotItemCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutCostingProfilesInput = {
    id?: string
    barId: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshotItems?: InventorySnapshotItemUncheckedCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemUncheckedCreateNestedManyWithoutInventoryItemInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutCostingProfilesInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutCostingProfilesInput, InventoryItemUncheckedCreateWithoutCostingProfilesInput>
  }

  export type InventoryItemUpsertWithoutCostingProfilesInput = {
    update: XOR<InventoryItemUpdateWithoutCostingProfilesInput, InventoryItemUncheckedUpdateWithoutCostingProfilesInput>
    create: XOR<InventoryItemCreateWithoutCostingProfilesInput, InventoryItemUncheckedCreateWithoutCostingProfilesInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutCostingProfilesInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutCostingProfilesInput, InventoryItemUncheckedUpdateWithoutCostingProfilesInput>
  }

  export type InventoryItemUpdateWithoutCostingProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryItemsNestedInput
    snapshotItems?: InventorySnapshotItemUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutCostingProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItems?: InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type BarCreateWithoutVarianceAlertsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutVarianceAlertsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutVarianceAlertsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutVarianceAlertsInput, BarUncheckedCreateWithoutVarianceAlertsInput>
  }

  export type InventoryItemCreateWithoutVarianceAlertsInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryItemsInput
    snapshotItems?: InventorySnapshotItemCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutVarianceAlertsInput = {
    id?: string
    barId: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshotItems?: InventorySnapshotItemUncheckedCreateNestedManyWithoutInventoryItemInput
    shiftUsageItems?: ShiftUsageItemUncheckedCreateNestedManyWithoutInventoryItemInput
    costingProfiles?: CostingProfileUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutVarianceAlertsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutVarianceAlertsInput, InventoryItemUncheckedCreateWithoutVarianceAlertsInput>
  }

  export type BarUpsertWithoutVarianceAlertsInput = {
    update: XOR<BarUpdateWithoutVarianceAlertsInput, BarUncheckedUpdateWithoutVarianceAlertsInput>
    create: XOR<BarCreateWithoutVarianceAlertsInput, BarUncheckedCreateWithoutVarianceAlertsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutVarianceAlertsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutVarianceAlertsInput, BarUncheckedUpdateWithoutVarianceAlertsInput>
  }

  export type BarUpdateWithoutVarianceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutVarianceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type InventoryItemUpsertWithoutVarianceAlertsInput = {
    update: XOR<InventoryItemUpdateWithoutVarianceAlertsInput, InventoryItemUncheckedUpdateWithoutVarianceAlertsInput>
    create: XOR<InventoryItemCreateWithoutVarianceAlertsInput, InventoryItemUncheckedCreateWithoutVarianceAlertsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutVarianceAlertsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutVarianceAlertsInput, InventoryItemUncheckedUpdateWithoutVarianceAlertsInput>
  }

  export type InventoryItemUpdateWithoutVarianceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryItemsNestedInput
    snapshotItems?: InventorySnapshotItemUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutVarianceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItems?: InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type BarCreateWithoutBarLicensesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutBarLicensesInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutBarLicensesInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutBarLicensesInput, BarUncheckedCreateWithoutBarLicensesInput>
  }

  export type OwnerCreateWithoutBarLicensesInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionCreateNestedOneWithoutOwnerInput
    promoRedemptions?: PromoRedemptionCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutBarLicensesInput = {
    id?: string
    email: string
    name: string
    password: string
    phone?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    allowFreeListings?: boolean
    role?: $Enums.OwnerRole
    bars?: BarUncheckedCreateNestedManyWithoutOwnerInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutOwnerInput
    promoRedemptions?: PromoRedemptionUncheckedCreateNestedManyWithoutOwnerInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutOwnerInput
    passwordResets?: OwnerPasswordResetUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutBarLicensesInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutBarLicensesInput, OwnerUncheckedCreateWithoutBarLicensesInput>
  }

  export type BarUpsertWithoutBarLicensesInput = {
    update: XOR<BarUpdateWithoutBarLicensesInput, BarUncheckedUpdateWithoutBarLicensesInput>
    create: XOR<BarCreateWithoutBarLicensesInput, BarUncheckedCreateWithoutBarLicensesInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutBarLicensesInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutBarLicensesInput, BarUncheckedUpdateWithoutBarLicensesInput>
  }

  export type BarUpdateWithoutBarLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutBarLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type OwnerUpsertWithoutBarLicensesInput = {
    update: XOR<OwnerUpdateWithoutBarLicensesInput, OwnerUncheckedUpdateWithoutBarLicensesInput>
    create: XOR<OwnerCreateWithoutBarLicensesInput, OwnerUncheckedCreateWithoutBarLicensesInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutBarLicensesInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutBarLicensesInput, OwnerUncheckedUpdateWithoutBarLicensesInput>
  }

  export type OwnerUpdateWithoutBarLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUpdateOneWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutBarLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allowFreeListings?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumOwnerRoleFieldUpdateOperationsInput | $Enums.OwnerRole
    bars?: BarUncheckedUpdateManyWithoutOwnerNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutOwnerNestedInput
    promoRedemptions?: PromoRedemptionUncheckedUpdateManyWithoutOwnerNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutOwnerNestedInput
    passwordResets?: OwnerPasswordResetUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type BarCreateWithoutVisitsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutVisitsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutVisitsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutVisitsInput, BarUncheckedCreateWithoutVisitsInput>
  }

  export type UserCreateWithoutVisitsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVisitsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
  }

  export type BarUpsertWithoutVisitsInput = {
    update: XOR<BarUpdateWithoutVisitsInput, BarUncheckedUpdateWithoutVisitsInput>
    create: XOR<BarCreateWithoutVisitsInput, BarUncheckedCreateWithoutVisitsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutVisitsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutVisitsInput, BarUncheckedUpdateWithoutVisitsInput>
  }

  export type BarUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserUpsertWithoutVisitsInput = {
    update: XOR<UserUpdateWithoutVisitsInput, UserUncheckedUpdateWithoutVisitsInput>
    create: XOR<UserCreateWithoutVisitsInput, UserUncheckedCreateWithoutVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVisitsInput, UserUncheckedUpdateWithoutVisitsInput>
  }

  export type UserUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarCreateWithoutMembershipsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutMembershipsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutMembershipsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutMembershipsInput, BarUncheckedCreateWithoutMembershipsInput>
  }

  export type BarUpsertWithoutMembershipsInput = {
    update: XOR<BarUpdateWithoutMembershipsInput, BarUncheckedUpdateWithoutMembershipsInput>
    create: XOR<BarCreateWithoutMembershipsInput, BarUncheckedCreateWithoutMembershipsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutMembershipsInput, BarUncheckedUpdateWithoutMembershipsInput>
  }

  export type BarUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutPatronSearchEventsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutPatronSearchEventsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutPatronSearchEventsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutPatronSearchEventsInput, BarUncheckedCreateWithoutPatronSearchEventsInput>
  }

  export type BarUpsertWithoutPatronSearchEventsInput = {
    update: XOR<BarUpdateWithoutPatronSearchEventsInput, BarUncheckedUpdateWithoutPatronSearchEventsInput>
    create: XOR<BarCreateWithoutPatronSearchEventsInput, BarUncheckedCreateWithoutPatronSearchEventsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutPatronSearchEventsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutPatronSearchEventsInput, BarUncheckedUpdateWithoutPatronSearchEventsInput>
  }

  export type BarUpdateWithoutPatronSearchEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutPatronSearchEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutBarActionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutBarActionsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutBarActionsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutBarActionsInput, BarUncheckedCreateWithoutBarActionsInput>
  }

  export type BarUpsertWithoutBarActionsInput = {
    update: XOR<BarUpdateWithoutBarActionsInput, BarUncheckedUpdateWithoutBarActionsInput>
    create: XOR<BarCreateWithoutBarActionsInput, BarUncheckedCreateWithoutBarActionsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutBarActionsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutBarActionsInput, BarUncheckedUpdateWithoutBarActionsInput>
  }

  export type BarUpdateWithoutBarActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutBarActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutFollowersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutFollowersInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutFollowersInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutFollowersInput, BarUncheckedCreateWithoutFollowersInput>
  }

  export type BarUpsertWithoutFollowersInput = {
    update: XOR<BarUpdateWithoutFollowersInput, BarUncheckedUpdateWithoutFollowersInput>
    create: XOR<BarCreateWithoutFollowersInput, BarUncheckedCreateWithoutFollowersInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutFollowersInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutFollowersInput, BarUncheckedUpdateWithoutFollowersInput>
  }

  export type BarUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutBoostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutBoostsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutBoostsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutBoostsInput, BarUncheckedCreateWithoutBoostsInput>
  }

  export type BoostMetricCreateWithoutBoostInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
  }

  export type BoostMetricUncheckedCreateWithoutBoostInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
  }

  export type BoostMetricCreateOrConnectWithoutBoostInput = {
    where: BoostMetricWhereUniqueInput
    create: XOR<BoostMetricCreateWithoutBoostInput, BoostMetricUncheckedCreateWithoutBoostInput>
  }

  export type BoostMetricCreateManyBoostInputEnvelope = {
    data: BoostMetricCreateManyBoostInput | BoostMetricCreateManyBoostInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithoutBoostsInput = {
    update: XOR<BarUpdateWithoutBoostsInput, BarUncheckedUpdateWithoutBoostsInput>
    create: XOR<BarCreateWithoutBoostsInput, BarUncheckedCreateWithoutBoostsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutBoostsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutBoostsInput, BarUncheckedUpdateWithoutBoostsInput>
  }

  export type BarUpdateWithoutBoostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutBoostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BoostMetricUpsertWithWhereUniqueWithoutBoostInput = {
    where: BoostMetricWhereUniqueInput
    update: XOR<BoostMetricUpdateWithoutBoostInput, BoostMetricUncheckedUpdateWithoutBoostInput>
    create: XOR<BoostMetricCreateWithoutBoostInput, BoostMetricUncheckedCreateWithoutBoostInput>
  }

  export type BoostMetricUpdateWithWhereUniqueWithoutBoostInput = {
    where: BoostMetricWhereUniqueInput
    data: XOR<BoostMetricUpdateWithoutBoostInput, BoostMetricUncheckedUpdateWithoutBoostInput>
  }

  export type BoostMetricUpdateManyWithWhereWithoutBoostInput = {
    where: BoostMetricScalarWhereInput
    data: XOR<BoostMetricUpdateManyMutationInput, BoostMetricUncheckedUpdateManyWithoutBoostInput>
  }

  export type BoostMetricScalarWhereInput = {
    AND?: BoostMetricScalarWhereInput | BoostMetricScalarWhereInput[]
    OR?: BoostMetricScalarWhereInput[]
    NOT?: BoostMetricScalarWhereInput | BoostMetricScalarWhereInput[]
    id?: StringFilter<"BoostMetric"> | string
    boostId?: StringFilter<"BoostMetric"> | string
    date?: DateTimeFilter<"BoostMetric"> | Date | string
    impressions?: IntFilter<"BoostMetric"> | number
    clicks?: IntFilter<"BoostMetric"> | number
  }

  export type BoostCreateWithoutMetricsInput = {
    id?: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutBoostsInput
  }

  export type BoostUncheckedCreateWithoutMetricsInput = {
    id?: string
    barId: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
  }

  export type BoostCreateOrConnectWithoutMetricsInput = {
    where: BoostWhereUniqueInput
    create: XOR<BoostCreateWithoutMetricsInput, BoostUncheckedCreateWithoutMetricsInput>
  }

  export type BoostUpsertWithoutMetricsInput = {
    update: XOR<BoostUpdateWithoutMetricsInput, BoostUncheckedUpdateWithoutMetricsInput>
    create: XOR<BoostCreateWithoutMetricsInput, BoostUncheckedCreateWithoutMetricsInput>
    where?: BoostWhereInput
  }

  export type BoostUpdateToOneWithWhereWithoutMetricsInput = {
    where?: BoostWhereInput
    data: XOR<BoostUpdateWithoutMetricsInput, BoostUncheckedUpdateWithoutMetricsInput>
  }

  export type BoostUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutBoostsNestedInput
  }

  export type BoostUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarProductCreateWithoutProductInput = {
    id?: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    bar: BarCreateNestedOneWithoutBarProductsInput
    counts?: InventoryCountCreateNestedManyWithoutProductInput
    detections?: InventoryScanDetectionCreateNestedManyWithoutProductInput
  }

  export type BarProductUncheckedCreateWithoutProductInput = {
    id?: string
    barId: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    counts?: InventoryCountUncheckedCreateNestedManyWithoutProductInput
    detections?: InventoryScanDetectionUncheckedCreateNestedManyWithoutProductInput
  }

  export type BarProductCreateOrConnectWithoutProductInput = {
    where: BarProductWhereUniqueInput
    create: XOR<BarProductCreateWithoutProductInput, BarProductUncheckedCreateWithoutProductInput>
  }

  export type BarProductCreateManyProductInputEnvelope = {
    data: BarProductCreateManyProductInput | BarProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BarProductUpsertWithWhereUniqueWithoutProductInput = {
    where: BarProductWhereUniqueInput
    update: XOR<BarProductUpdateWithoutProductInput, BarProductUncheckedUpdateWithoutProductInput>
    create: XOR<BarProductCreateWithoutProductInput, BarProductUncheckedCreateWithoutProductInput>
  }

  export type BarProductUpdateWithWhereUniqueWithoutProductInput = {
    where: BarProductWhereUniqueInput
    data: XOR<BarProductUpdateWithoutProductInput, BarProductUncheckedUpdateWithoutProductInput>
  }

  export type BarProductUpdateManyWithWhereWithoutProductInput = {
    where: BarProductScalarWhereInput
    data: XOR<BarProductUpdateManyMutationInput, BarProductUncheckedUpdateManyWithoutProductInput>
  }

  export type BarCreateWithoutBarProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutBarProductsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutBarProductsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutBarProductsInput, BarUncheckedCreateWithoutBarProductsInput>
  }

  export type ProductCreateWithoutBarProductsInput = {
    id?: string
    name: string
    category: string
    unitType: string
    sizeMl?: number | null
    upc?: string | null
    isActive?: boolean
  }

  export type ProductUncheckedCreateWithoutBarProductsInput = {
    id?: string
    name: string
    category: string
    unitType: string
    sizeMl?: number | null
    upc?: string | null
    isActive?: boolean
  }

  export type ProductCreateOrConnectWithoutBarProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBarProductsInput, ProductUncheckedCreateWithoutBarProductsInput>
  }

  export type InventoryCountCreateWithoutProductInput = {
    id?: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
    bar: BarCreateNestedOneWithoutInventoryCountsInput
  }

  export type InventoryCountUncheckedCreateWithoutProductInput = {
    id?: string
    barId: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
  }

  export type InventoryCountCreateOrConnectWithoutProductInput = {
    where: InventoryCountWhereUniqueInput
    create: XOR<InventoryCountCreateWithoutProductInput, InventoryCountUncheckedCreateWithoutProductInput>
  }

  export type InventoryCountCreateManyProductInputEnvelope = {
    data: InventoryCountCreateManyProductInput | InventoryCountCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryScanDetectionCreateWithoutProductInput = {
    id?: string
    productGuessText: string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
    session: InventoryScanSessionCreateNestedOneWithoutDetectionsInput
  }

  export type InventoryScanDetectionUncheckedCreateWithoutProductInput = {
    id?: string
    sessionId: string
    productGuessText: string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
  }

  export type InventoryScanDetectionCreateOrConnectWithoutProductInput = {
    where: InventoryScanDetectionWhereUniqueInput
    create: XOR<InventoryScanDetectionCreateWithoutProductInput, InventoryScanDetectionUncheckedCreateWithoutProductInput>
  }

  export type InventoryScanDetectionCreateManyProductInputEnvelope = {
    data: InventoryScanDetectionCreateManyProductInput | InventoryScanDetectionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithoutBarProductsInput = {
    update: XOR<BarUpdateWithoutBarProductsInput, BarUncheckedUpdateWithoutBarProductsInput>
    create: XOR<BarCreateWithoutBarProductsInput, BarUncheckedCreateWithoutBarProductsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutBarProductsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutBarProductsInput, BarUncheckedUpdateWithoutBarProductsInput>
  }

  export type BarUpdateWithoutBarProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutBarProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type ProductUpsertWithoutBarProductsInput = {
    update: XOR<ProductUpdateWithoutBarProductsInput, ProductUncheckedUpdateWithoutBarProductsInput>
    create: XOR<ProductCreateWithoutBarProductsInput, ProductUncheckedCreateWithoutBarProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBarProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBarProductsInput, ProductUncheckedUpdateWithoutBarProductsInput>
  }

  export type ProductUpdateWithoutBarProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    sizeMl?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateWithoutBarProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    sizeMl?: NullableIntFieldUpdateOperationsInput | number | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryCountUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryCountWhereUniqueInput
    update: XOR<InventoryCountUpdateWithoutProductInput, InventoryCountUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCountCreateWithoutProductInput, InventoryCountUncheckedCreateWithoutProductInput>
  }

  export type InventoryCountUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryCountWhereUniqueInput
    data: XOR<InventoryCountUpdateWithoutProductInput, InventoryCountUncheckedUpdateWithoutProductInput>
  }

  export type InventoryCountUpdateManyWithWhereWithoutProductInput = {
    where: InventoryCountScalarWhereInput
    data: XOR<InventoryCountUpdateManyMutationInput, InventoryCountUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryScanDetectionUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryScanDetectionWhereUniqueInput
    update: XOR<InventoryScanDetectionUpdateWithoutProductInput, InventoryScanDetectionUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryScanDetectionCreateWithoutProductInput, InventoryScanDetectionUncheckedCreateWithoutProductInput>
  }

  export type InventoryScanDetectionUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryScanDetectionWhereUniqueInput
    data: XOR<InventoryScanDetectionUpdateWithoutProductInput, InventoryScanDetectionUncheckedUpdateWithoutProductInput>
  }

  export type InventoryScanDetectionUpdateManyWithWhereWithoutProductInput = {
    where: InventoryScanDetectionScalarWhereInput
    data: XOR<InventoryScanDetectionUpdateManyMutationInput, InventoryScanDetectionUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryScanDetectionScalarWhereInput = {
    AND?: InventoryScanDetectionScalarWhereInput | InventoryScanDetectionScalarWhereInput[]
    OR?: InventoryScanDetectionScalarWhereInput[]
    NOT?: InventoryScanDetectionScalarWhereInput | InventoryScanDetectionScalarWhereInput[]
    id?: StringFilter<"InventoryScanDetection"> | string
    sessionId?: StringFilter<"InventoryScanDetection"> | string
    productGuessText?: StringFilter<"InventoryScanDetection"> | string
    productId?: StringNullableFilter<"InventoryScanDetection"> | string | null
    bbox?: JsonNullableFilter<"InventoryScanDetection">
    confidence?: FloatFilter<"InventoryScanDetection"> | number
    remainingBucket?: StringNullableFilter<"InventoryScanDetection"> | string | null
    sizeMlGuess?: IntNullableFilter<"InventoryScanDetection"> | number | null
  }

  export type BarCreateWithoutInventoryScanSessionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutInventoryScanSessionsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutInventoryScanSessionsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutInventoryScanSessionsInput, BarUncheckedCreateWithoutInventoryScanSessionsInput>
  }

  export type InventoryScanDetectionCreateWithoutSessionInput = {
    id?: string
    productGuessText: string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
    product?: BarProductCreateNestedOneWithoutDetectionsInput
  }

  export type InventoryScanDetectionUncheckedCreateWithoutSessionInput = {
    id?: string
    productGuessText: string
    productId?: string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
  }

  export type InventoryScanDetectionCreateOrConnectWithoutSessionInput = {
    where: InventoryScanDetectionWhereUniqueInput
    create: XOR<InventoryScanDetectionCreateWithoutSessionInput, InventoryScanDetectionUncheckedCreateWithoutSessionInput>
  }

  export type InventoryScanDetectionCreateManySessionInputEnvelope = {
    data: InventoryScanDetectionCreateManySessionInput | InventoryScanDetectionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type BarUpsertWithoutInventoryScanSessionsInput = {
    update: XOR<BarUpdateWithoutInventoryScanSessionsInput, BarUncheckedUpdateWithoutInventoryScanSessionsInput>
    create: XOR<BarCreateWithoutInventoryScanSessionsInput, BarUncheckedCreateWithoutInventoryScanSessionsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutInventoryScanSessionsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutInventoryScanSessionsInput, BarUncheckedUpdateWithoutInventoryScanSessionsInput>
  }

  export type BarUpdateWithoutInventoryScanSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutInventoryScanSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type InventoryScanDetectionUpsertWithWhereUniqueWithoutSessionInput = {
    where: InventoryScanDetectionWhereUniqueInput
    update: XOR<InventoryScanDetectionUpdateWithoutSessionInput, InventoryScanDetectionUncheckedUpdateWithoutSessionInput>
    create: XOR<InventoryScanDetectionCreateWithoutSessionInput, InventoryScanDetectionUncheckedCreateWithoutSessionInput>
  }

  export type InventoryScanDetectionUpdateWithWhereUniqueWithoutSessionInput = {
    where: InventoryScanDetectionWhereUniqueInput
    data: XOR<InventoryScanDetectionUpdateWithoutSessionInput, InventoryScanDetectionUncheckedUpdateWithoutSessionInput>
  }

  export type InventoryScanDetectionUpdateManyWithWhereWithoutSessionInput = {
    where: InventoryScanDetectionScalarWhereInput
    data: XOR<InventoryScanDetectionUpdateManyMutationInput, InventoryScanDetectionUncheckedUpdateManyWithoutSessionInput>
  }

  export type InventoryScanSessionCreateWithoutDetectionsInput = {
    id?: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    bar: BarCreateNestedOneWithoutInventoryScanSessionsInput
  }

  export type InventoryScanSessionUncheckedCreateWithoutDetectionsInput = {
    id?: string
    barId: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type InventoryScanSessionCreateOrConnectWithoutDetectionsInput = {
    where: InventoryScanSessionWhereUniqueInput
    create: XOR<InventoryScanSessionCreateWithoutDetectionsInput, InventoryScanSessionUncheckedCreateWithoutDetectionsInput>
  }

  export type BarProductCreateWithoutDetectionsInput = {
    id?: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    bar: BarCreateNestedOneWithoutBarProductsInput
    product?: ProductCreateNestedOneWithoutBarProductsInput
    counts?: InventoryCountCreateNestedManyWithoutProductInput
  }

  export type BarProductUncheckedCreateWithoutDetectionsInput = {
    id?: string
    barId: string
    productId?: string | null
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    counts?: InventoryCountUncheckedCreateNestedManyWithoutProductInput
  }

  export type BarProductCreateOrConnectWithoutDetectionsInput = {
    where: BarProductWhereUniqueInput
    create: XOR<BarProductCreateWithoutDetectionsInput, BarProductUncheckedCreateWithoutDetectionsInput>
  }

  export type InventoryScanSessionUpsertWithoutDetectionsInput = {
    update: XOR<InventoryScanSessionUpdateWithoutDetectionsInput, InventoryScanSessionUncheckedUpdateWithoutDetectionsInput>
    create: XOR<InventoryScanSessionCreateWithoutDetectionsInput, InventoryScanSessionUncheckedCreateWithoutDetectionsInput>
    where?: InventoryScanSessionWhereInput
  }

  export type InventoryScanSessionUpdateToOneWithWhereWithoutDetectionsInput = {
    where?: InventoryScanSessionWhereInput
    data: XOR<InventoryScanSessionUpdateWithoutDetectionsInput, InventoryScanSessionUncheckedUpdateWithoutDetectionsInput>
  }

  export type InventoryScanSessionUpdateWithoutDetectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryScanSessionsNestedInput
  }

  export type InventoryScanSessionUncheckedUpdateWithoutDetectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarProductUpsertWithoutDetectionsInput = {
    update: XOR<BarProductUpdateWithoutDetectionsInput, BarProductUncheckedUpdateWithoutDetectionsInput>
    create: XOR<BarProductCreateWithoutDetectionsInput, BarProductUncheckedCreateWithoutDetectionsInput>
    where?: BarProductWhereInput
  }

  export type BarProductUpdateToOneWithWhereWithoutDetectionsInput = {
    where?: BarProductWhereInput
    data: XOR<BarProductUpdateWithoutDetectionsInput, BarProductUncheckedUpdateWithoutDetectionsInput>
  }

  export type BarProductUpdateWithoutDetectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bar?: BarUpdateOneRequiredWithoutBarProductsNestedInput
    product?: ProductUpdateOneWithoutBarProductsNestedInput
    counts?: InventoryCountUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateWithoutDetectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    counts?: InventoryCountUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BarCreateWithoutInventoryCountsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutInventoryCountsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutInventoryCountsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutInventoryCountsInput, BarUncheckedCreateWithoutInventoryCountsInput>
  }

  export type BarProductCreateWithoutCountsInput = {
    id?: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    bar: BarCreateNestedOneWithoutBarProductsInput
    product?: ProductCreateNestedOneWithoutBarProductsInput
    detections?: InventoryScanDetectionCreateNestedManyWithoutProductInput
  }

  export type BarProductUncheckedCreateWithoutCountsInput = {
    id?: string
    barId: string
    productId?: string | null
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
    detections?: InventoryScanDetectionUncheckedCreateNestedManyWithoutProductInput
  }

  export type BarProductCreateOrConnectWithoutCountsInput = {
    where: BarProductWhereUniqueInput
    create: XOR<BarProductCreateWithoutCountsInput, BarProductUncheckedCreateWithoutCountsInput>
  }

  export type BarUpsertWithoutInventoryCountsInput = {
    update: XOR<BarUpdateWithoutInventoryCountsInput, BarUncheckedUpdateWithoutInventoryCountsInput>
    create: XOR<BarCreateWithoutInventoryCountsInput, BarUncheckedCreateWithoutInventoryCountsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutInventoryCountsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutInventoryCountsInput, BarUncheckedUpdateWithoutInventoryCountsInput>
  }

  export type BarUpdateWithoutInventoryCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutInventoryCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarProductUpsertWithoutCountsInput = {
    update: XOR<BarProductUpdateWithoutCountsInput, BarProductUncheckedUpdateWithoutCountsInput>
    create: XOR<BarProductCreateWithoutCountsInput, BarProductUncheckedCreateWithoutCountsInput>
    where?: BarProductWhereInput
  }

  export type BarProductUpdateToOneWithWhereWithoutCountsInput = {
    where?: BarProductWhereInput
    data: XOR<BarProductUpdateWithoutCountsInput, BarProductUncheckedUpdateWithoutCountsInput>
  }

  export type BarProductUpdateWithoutCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bar?: BarUpdateOneRequiredWithoutBarProductsNestedInput
    product?: ProductUpdateOneWithoutBarProductsNestedInput
    detections?: InventoryScanDetectionUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateWithoutCountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    detections?: InventoryScanDetectionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BarCreateWithoutAdminNotesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutAdminNotesInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutAdminNotesInput, BarUncheckedCreateWithoutAdminNotesInput>
  }

  export type UserCreateWithoutAdminNotesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
  }

  export type BarUpsertWithoutAdminNotesInput = {
    update: XOR<BarUpdateWithoutAdminNotesInput, BarUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<BarCreateWithoutAdminNotesInput, BarUncheckedCreateWithoutAdminNotesInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutAdminNotesInput, BarUncheckedUpdateWithoutAdminNotesInput>
  }

  export type BarUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserUpsertWithoutAdminNotesInput = {
    update: XOR<UserUpdateWithoutAdminNotesInput, UserUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminNotesInput, UserUncheckedUpdateWithoutAdminNotesInput>
  }

  export type UserUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarCreateWithoutSupportTicketsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutSupportTicketsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutSupportTicketsInput, BarUncheckedCreateWithoutSupportTicketsInput>
  }

  export type UserCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    visits?: BarVisitCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disabled?: boolean
    role?: $Enums.UserRole
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutUserInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutCreatedByInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutUserInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type BarUpsertWithoutSupportTicketsInput = {
    update: XOR<BarUpdateWithoutSupportTicketsInput, BarUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<BarCreateWithoutSupportTicketsInput, BarUncheckedCreateWithoutSupportTicketsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutSupportTicketsInput, BarUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type BarUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    visits?: BarVisitUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutUserNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutCreatedByNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutUserNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarCreateWithoutStaticOfferingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutStaticOfferingsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutStaticOfferingsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutStaticOfferingsInput, BarUncheckedCreateWithoutStaticOfferingsInput>
  }

  export type BarUpsertWithoutStaticOfferingsInput = {
    update: XOR<BarUpdateWithoutStaticOfferingsInput, BarUncheckedUpdateWithoutStaticOfferingsInput>
    create: XOR<BarCreateWithoutStaticOfferingsInput, BarUncheckedCreateWithoutStaticOfferingsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutStaticOfferingsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutStaticOfferingsInput, BarUncheckedUpdateWithoutStaticOfferingsInput>
  }

  export type BarUpdateWithoutStaticOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutStaticOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutDrinkSpecialsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutDrinkSpecialsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    foodOfferings?: FoodOfferingUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutDrinkSpecialsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutDrinkSpecialsInput, BarUncheckedCreateWithoutDrinkSpecialsInput>
  }

  export type BarUpsertWithoutDrinkSpecialsInput = {
    update: XOR<BarUpdateWithoutDrinkSpecialsInput, BarUncheckedUpdateWithoutDrinkSpecialsInput>
    create: XOR<BarCreateWithoutDrinkSpecialsInput, BarUncheckedCreateWithoutDrinkSpecialsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutDrinkSpecialsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutDrinkSpecialsInput, BarUncheckedUpdateWithoutDrinkSpecialsInput>
  }

  export type BarUpdateWithoutDrinkSpecialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutDrinkSpecialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarCreateWithoutFoodOfferingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    owner: OwnerCreateNestedOneWithoutBarsInput
    offerings?: OfferingCreateNestedManyWithoutBarInput
    events?: EventCreateNestedManyWithoutBarInput
    favorites?: FavoriteCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsCreateNestedManyWithoutBarInput
    clicks?: BarClickCreateNestedManyWithoutBarInput
    badges?: BarBadgeCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotCreateNestedManyWithoutBarInput
    visits?: BarVisitCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestCreateNestedManyWithoutBarInput
    memberships?: BarMembershipCreateNestedManyWithoutBarInput
    followers?: BarFollowerCreateNestedManyWithoutBarInput
    boosts?: BoostCreateNestedManyWithoutBarInput
    barProducts?: BarProductCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventCreateNestedManyWithoutBarInput
    barActions?: BarActionCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketCreateNestedManyWithoutBarInput
  }

  export type BarUncheckedCreateWithoutFoodOfferingsInput = {
    id?: string
    ownerId: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
    offerings?: OfferingUncheckedCreateNestedManyWithoutBarInput
    events?: EventUncheckedCreateNestedManyWithoutBarInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutBarInput
    analytics?: BarAnalyticsUncheckedCreateNestedManyWithoutBarInput
    clicks?: BarClickUncheckedCreateNestedManyWithoutBarInput
    badges?: BarBadgeUncheckedCreateNestedManyWithoutBarInput
    barLicenses?: BarLicenseUncheckedCreateNestedManyWithoutBarInput
    shiftUsages?: ShiftUsageUncheckedCreateNestedManyWithoutBarInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBarInput
    inventoryImports?: InventoryImportUncheckedCreateNestedManyWithoutBarInput
    inventorySnapshots?: InventorySnapshotUncheckedCreateNestedManyWithoutBarInput
    visits?: BarVisitUncheckedCreateNestedManyWithoutBarInput
    varianceAlerts?: VarianceAlertUncheckedCreateNestedManyWithoutBarInput
    staticOfferings?: StaticOfferingUncheckedCreateNestedManyWithoutBarInput
    drinkSpecials?: DrinkSpecialUncheckedCreateNestedManyWithoutBarInput
    categoryRequests?: CategoryRequestUncheckedCreateNestedManyWithoutBarInput
    memberships?: BarMembershipUncheckedCreateNestedManyWithoutBarInput
    followers?: BarFollowerUncheckedCreateNestedManyWithoutBarInput
    boosts?: BoostUncheckedCreateNestedManyWithoutBarInput
    barProducts?: BarProductUncheckedCreateNestedManyWithoutBarInput
    inventoryScanSessions?: InventoryScanSessionUncheckedCreateNestedManyWithoutBarInput
    inventoryCounts?: InventoryCountUncheckedCreateNestedManyWithoutBarInput
    patronSearchEvents?: PatronSearchEventUncheckedCreateNestedManyWithoutBarInput
    barActions?: BarActionUncheckedCreateNestedManyWithoutBarInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBarInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutBarInput
  }

  export type BarCreateOrConnectWithoutFoodOfferingsInput = {
    where: BarWhereUniqueInput
    create: XOR<BarCreateWithoutFoodOfferingsInput, BarUncheckedCreateWithoutFoodOfferingsInput>
  }

  export type BarUpsertWithoutFoodOfferingsInput = {
    update: XOR<BarUpdateWithoutFoodOfferingsInput, BarUncheckedUpdateWithoutFoodOfferingsInput>
    create: XOR<BarCreateWithoutFoodOfferingsInput, BarUncheckedCreateWithoutFoodOfferingsInput>
    where?: BarWhereInput
  }

  export type BarUpdateToOneWithWhereWithoutFoodOfferingsInput = {
    where?: BarWhereInput
    data: XOR<BarUpdateWithoutFoodOfferingsInput, BarUncheckedUpdateWithoutFoodOfferingsInput>
  }

  export type BarUpdateWithoutFoodOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    owner?: OwnerUpdateOneRequiredWithoutBarsNestedInput
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutFoodOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    barId: string
    createdAt?: Date | string
  }

  export type BarVisitCreateManyUserInput = {
    id?: string
    barId: string
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
  }

  export type InventoryImportCreateManyCreatedByInput = {
    id?: string
    barId: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ShiftUsageCreateManyUserInput = {
    id?: string
    barId: string
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventorySnapshotCreateManyUserInput = {
    id?: string
    barId: string
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type AdminNoteCreateManyUserInput = {
    id?: string
    adminEmail: string
    barId?: string | null
    content: string
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    barId?: string | null
    userEmail: string
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutVisitsNestedInput
  }

  export type BarVisitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventoryImportsNestedInput
  }

  export type InventoryImportUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutShiftUsagesNestedInput
    items?: ShiftUsageItemUpdateManyWithoutShiftUsageNestedInput
  }

  export type ShiftUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShiftUsageItemUncheckedUpdateManyWithoutShiftUsageNestedInput
  }

  export type ShiftUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventorySnapshotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutInventorySnapshotsNestedInput
    items?: InventorySnapshotItemUpdateManyWithoutSnapshotNestedInput
  }

  export type InventorySnapshotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventorySnapshotItemUncheckedUpdateManyWithoutSnapshotNestedInput
  }

  export type InventorySnapshotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarCreateManyOwnerInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    address: string
    city: string
    cityNormalized: string
    state: string
    zipCode: string
    barType?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    inventoryAddOnEnabled?: boolean
    checkInReward?: string | null
    neighborhood?: string | null
    neighborhoodNormalized?: string | null
    latitude: number
    longitude: number
    phone?: string | null
    website?: string | null
    logo?: string | null
    photos?: BarCreatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileViews?: number
    searchAppearances?: number
  }

  export type BarLicenseCreateManyOwnerInput = {
    id?: string
    barId: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoRedemptionCreateManyOwnerInput = {
    id?: string
    promoCodeId: string
    redeemedAt?: Date | string
  }

  export type CategoryRequestCreateManyOwnerInput = {
    id?: string
    barId: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
  }

  export type OwnerPasswordResetCreateManyOwnerInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BarUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUpdateManyWithoutBarNestedInput
    events?: EventUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUpdateManyWithoutBarNestedInput
    clicks?: BarClickUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUpdateManyWithoutBarNestedInput
    visits?: BarVisitUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUpdateManyWithoutBarNestedInput
    boosts?: BoostUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUpdateManyWithoutBarNestedInput
    barActions?: BarActionUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
    offerings?: OfferingUncheckedUpdateManyWithoutBarNestedInput
    events?: EventUncheckedUpdateManyWithoutBarNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutBarNestedInput
    analytics?: BarAnalyticsUncheckedUpdateManyWithoutBarNestedInput
    clicks?: BarClickUncheckedUpdateManyWithoutBarNestedInput
    badges?: BarBadgeUncheckedUpdateManyWithoutBarNestedInput
    barLicenses?: BarLicenseUncheckedUpdateManyWithoutBarNestedInput
    shiftUsages?: ShiftUsageUncheckedUpdateManyWithoutBarNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBarNestedInput
    inventoryImports?: InventoryImportUncheckedUpdateManyWithoutBarNestedInput
    inventorySnapshots?: InventorySnapshotUncheckedUpdateManyWithoutBarNestedInput
    visits?: BarVisitUncheckedUpdateManyWithoutBarNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutBarNestedInput
    staticOfferings?: StaticOfferingUncheckedUpdateManyWithoutBarNestedInput
    drinkSpecials?: DrinkSpecialUncheckedUpdateManyWithoutBarNestedInput
    foodOfferings?: FoodOfferingUncheckedUpdateManyWithoutBarNestedInput
    categoryRequests?: CategoryRequestUncheckedUpdateManyWithoutBarNestedInput
    memberships?: BarMembershipUncheckedUpdateManyWithoutBarNestedInput
    followers?: BarFollowerUncheckedUpdateManyWithoutBarNestedInput
    boosts?: BoostUncheckedUpdateManyWithoutBarNestedInput
    barProducts?: BarProductUncheckedUpdateManyWithoutBarNestedInput
    inventoryScanSessions?: InventoryScanSessionUncheckedUpdateManyWithoutBarNestedInput
    inventoryCounts?: InventoryCountUncheckedUpdateManyWithoutBarNestedInput
    patronSearchEvents?: PatronSearchEventUncheckedUpdateManyWithoutBarNestedInput
    barActions?: BarActionUncheckedUpdateManyWithoutBarNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBarNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutBarNestedInput
  }

  export type BarUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cityNormalized?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    barType?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    inventoryAddOnEnabled?: BoolFieldUpdateOperationsInput | boolean
    checkInReward?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhoodNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: BarUpdatephotosInput | string[]
    hours?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileViews?: IntFieldUpdateOperationsInput | number
    searchAppearances?: IntFieldUpdateOperationsInput | number
  }

  export type BarLicenseUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutBarLicensesNestedInput
  }

  export type BarLicenseUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarLicenseUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type PromoRedemptionUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutCategoryRequestsNestedInput
  }

  export type CategoryRequestUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerPasswordResetUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerPasswordResetUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerPasswordResetUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferingCreateManyBarInput = {
    id?: string
    dayOfWeek: number
    category: string
    customTitle?: string | null
    description?: string | null
    startTime: string
    endTime?: string | null
    recurrence?: $Enums.Recurrence
    startDate?: Date | string | null
    endDate?: Date | string | null
    tags?: OfferingCreatetagsInput | string[]
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    expiresAt?: Date | string | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyBarInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    startTime: string
    endTime?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    recurrence?: $Enums.Recurrence | null
    tags?: EventCreatetagsInput | string[]
    isActive?: boolean
    isSpecial?: boolean
    isNew?: boolean
    specialExpiresAt?: Date | string | null
    newUntil?: Date | string | null
    autoExpire?: boolean
    coverCharge?: Decimal | DecimalJsLike | number | string | null
    prize?: string | null
    ageRestriction?: number | null
    clickCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteCreateManyBarInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BarAnalyticsCreateManyBarInput = {
    id?: string
    date: Date | string
    dayOfWeek: number
    profileViews?: number
    profileClicks?: number
    searchAppears?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarClickCreateManyBarInput = {
    id?: string
    source: string
    query?: string | null
    dayOfWeek: number
    createdAt?: Date | string
  }

  export type BarBadgeCreateManyBarInput = {
    id?: string
    badgeKey: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarLicenseCreateManyBarInput = {
    id?: string
    ownerId: string
    status?: string
    priceCents?: number
    currency?: string
    billingCycle?: string
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUsageCreateManyBarInput = {
    id?: string
    userId?: string | null
    shiftTime?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryItemCreateManyBarInput = {
    id?: string
    name: string
    category?: string | null
    bottleSizeMl: number
    startingQtyBottles?: number
    costPerBottle?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryImportCreateManyBarInput = {
    id?: string
    fileName: string
    rowsImported?: number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: string | null
    createdAt?: Date | string
  }

  export type InventorySnapshotCreateManyBarInput = {
    id?: string
    userId?: string | null
    snapshotDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type BarVisitCreateManyBarInput = {
    id?: string
    userId?: string | null
    source: string
    verificationMethod: string
    clickId?: string | null
    promoCodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: Date | string
    createdAt?: Date | string
  }

  export type VarianceAlertCreateManyBarInput = {
    id?: string
    inventoryItemId: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
  }

  export type StaticOfferingCreateManyBarInput = {
    id?: string
    name: string
    icon: string
    description?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrinkSpecialCreateManyBarInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    daysOfWeek?: DrinkSpecialCreatedaysOfWeekInput | number[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodOfferingCreateManyBarInput = {
    id?: string
    name: string
    description?: string | null
    specialDays?: FoodOfferingCreatespecialDaysInput | number[]
    isSpecial?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryRequestCreateManyBarInput = {
    id?: string
    ownerId: string
    requestedByEmail: string
    requestedByName?: string | null
    category: string
    status?: $Enums.CategoryRequestStatus
    reviewedAt?: Date | string | null
    reviewedByEmail?: string | null
    createdAt?: Date | string
  }

  export type BarMembershipCreateManyBarInput = {
    id?: string
    userId: string
    role?: $Enums.BarMemberRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BarFollowerCreateManyBarInput = {
    id?: string
    patronEmail: string
    createdAt?: Date | string
  }

  export type BoostCreateManyBarInput = {
    id?: string
    eventId?: string | null
    startAt: Date | string
    endAt: Date | string
    budgetCents: number
    status?: string
    createdAt?: Date | string
  }

  export type BarProductCreateManyBarInput = {
    id?: string
    productId?: string | null
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
  }

  export type InventoryScanSessionCreateManyBarInput = {
    id?: string
    createdByUserId?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type InventoryCountCreateManyBarInput = {
    id?: string
    productId: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
  }

  export type PatronSearchEventCreateManyBarInput = {
    id?: string
    query?: string | null
    category?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type BarActionCreateManyBarInput = {
    id?: string
    action: string
    createdAt?: Date | string
  }

  export type AdminNoteCreateManyBarInput = {
    id?: string
    adminEmail: string
    userId?: string | null
    content: string
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyBarInput = {
    id?: string
    userEmail: string
    userId?: string | null
    subject: string
    status?: string
    priority?: string
    message: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferingUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferingUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferingUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    customTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: EnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: OfferingUpdatetagsInput | string[]
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrenceFieldUpdateOperationsInput | $Enums.Recurrence | null
    tags?: EventUpdatetagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    specialExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoExpire?: BoolFieldUpdateOperationsInput | boolean
    coverCharge?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prize?: NullableStringFieldUpdateOperationsInput | string | null
    ageRestriction?: NullableIntFieldUpdateOperationsInput | number | null
    clickCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarAnalyticsUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarAnalyticsUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarAnalyticsUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    profileClicks?: IntFieldUpdateOperationsInput | number
    searchAppears?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarClickUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarClickUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarClickUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarBadgeUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    badge?: BadgeUpdateOneRequiredWithoutBarBadgesNestedInput
  }

  export type BarBadgeUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeKey?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeKey?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarLicenseUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutBarLicensesNestedInput
  }

  export type BarLicenseUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarLicenseUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUsageUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutShiftUsagesNestedInput
    items?: ShiftUsageItemUpdateManyWithoutShiftUsageNestedInput
  }

  export type ShiftUsageUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShiftUsageItemUncheckedUpdateManyWithoutShiftUsageNestedInput
  }

  export type ShiftUsageUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTime?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItems?: InventorySnapshotItemUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotItems?: InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    shiftUsageItems?: ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    costingProfiles?: CostingProfileUncheckedUpdateManyWithoutInventoryItemNestedInput
    varianceAlerts?: VarianceAlertUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSizeMl?: IntFieldUpdateOperationsInput | number
    startingQtyBottles?: IntFieldUpdateOperationsInput | number
    costPerBottle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutInventoryImportsNestedInput
  }

  export type InventoryImportUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryImportUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowsImported?: IntFieldUpdateOperationsInput | number
    mapping?: NullableJsonNullValueInput | InputJsonValue
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventorySnapshotUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInventorySnapshotsNestedInput
    items?: InventorySnapshotItemUpdateManyWithoutSnapshotNestedInput
  }

  export type InventorySnapshotUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventorySnapshotItemUncheckedUpdateManyWithoutSnapshotNestedInput
  }

  export type InventorySnapshotUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutVisitsNestedInput
  }

  export type BarVisitUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarVisitUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    verificationMethod?: StringFieldUpdateOperationsInput | string
    clickId?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    visitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutVarianceAlertsNestedInput
  }

  export type VarianceAlertUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticOfferingUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticOfferingUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticOfferingUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrinkSpecialUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrinkSpecialUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrinkSpecialUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: DrinkSpecialUpdatedaysOfWeekInput | number[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodOfferingUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodOfferingUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodOfferingUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specialDays?: FoodOfferingUpdatespecialDaysInput | number[]
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutCategoryRequestsNestedInput
  }

  export type CategoryRequestUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryRequestUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    requestedByEmail?: StringFieldUpdateOperationsInput | string
    requestedByName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumCategoryRequestStatusFieldUpdateOperationsInput | $Enums.CategoryRequestStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarMembershipUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarMembershipUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarMembershipUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumBarMemberRoleFieldUpdateOperationsInput | $Enums.BarMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarFollowerUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarFollowerUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarFollowerUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    patronEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoostUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: BoostMetricUpdateManyWithoutBoostNestedInput
  }

  export type BoostUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: BoostMetricUncheckedUpdateManyWithoutBoostNestedInput
  }

  export type BoostUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarProductUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneWithoutBarProductsNestedInput
    counts?: InventoryCountUpdateManyWithoutProductNestedInput
    detections?: InventoryScanDetectionUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    counts?: InventoryCountUncheckedUpdateManyWithoutProductNestedInput
    detections?: InventoryScanDetectionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryScanSessionUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detections?: InventoryScanDetectionUpdateManyWithoutSessionNestedInput
  }

  export type InventoryScanSessionUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detections?: InventoryScanDetectionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InventoryScanSessionUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCountUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    product?: BarProductUpdateOneRequiredWithoutCountsNestedInput
  }

  export type InventoryCountUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCountUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatronSearchEventUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatronSearchEventUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatronSearchEventUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarActionUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarActionUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarActionUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminEmail?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutBarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionCreateManyPromoCodeInput = {
    id?: string
    ownerId: string
    redeemedAt?: Date | string
  }

  export type PromoRedemptionUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutPromoRedemptionsNestedInput
  }

  export type PromoRedemptionUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoRedemptionUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarBadgeCreateManyBadgeInput = {
    id?: string
    barId: string
    awardedAt?: Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bar?: BarUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BarBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BarBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventorySnapshotItemCreateManyInventoryItemInput = {
    id?: string
    snapshotId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type ShiftUsageItemCreateManyInventoryItemInput = {
    id?: string
    shiftUsageId: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type CostingProfileCreateManyInventoryItemInput = {
    id?: string
    pourSizeOz: Decimal | DecimalJsLike | number | string
    menuPrice: Decimal | DecimalJsLike | number | string
    costPerPour: Decimal | DecimalJsLike | number | string
    marginPct: Decimal | DecimalJsLike | number | string
    profitPerBottle: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type VarianceAlertCreateManyInventoryItemInput = {
    id?: string
    barId: string
    periodStart: Date | string
    periodEnd: Date | string
    expectedMl: Decimal | DecimalJsLike | number | string
    observedMl: Decimal | DecimalJsLike | number | string
    varianceMl: Decimal | DecimalJsLike | number | string
    variancePct: Decimal | DecimalJsLike | number | string
    severity: string
    reasonHint?: string | null
    createdAt?: Date | string
  }

  export type InventorySnapshotItemUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: InventorySnapshotUpdateOneRequiredWithoutItemsNestedInput
    bottlePhoto?: BottlePhotoUpdateOneWithoutSnapshotItemNestedInput
  }

  export type InventorySnapshotItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bottlePhoto?: BottlePhotoUncheckedUpdateOneWithoutSnapshotItemNestedInput
  }

  export type InventorySnapshotItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUsageItemUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    shiftUsage?: ShiftUsageUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ShiftUsageItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftUsageId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUsageItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftUsageId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostingProfileUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostingProfileUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostingProfileUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    pourSizeOz?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    menuPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerPour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profitPerBottle?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: BarUpdateOneRequiredWithoutVarianceAlertsNestedInput
  }

  export type VarianceAlertUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VarianceAlertUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    observedMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    varianceMl?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    severity?: StringFieldUpdateOperationsInput | string
    reasonHint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUsageItemCreateManyShiftUsageInput = {
    id?: string
    inventoryItemId: string
    quantityUsed: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type ShiftUsageItemUpdateWithoutShiftUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutShiftUsageItemsNestedInput
  }

  export type ShiftUsageItemUncheckedUpdateWithoutShiftUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUsageItemUncheckedUpdateManyWithoutShiftUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySnapshotItemCreateManySnapshotInput = {
    id?: string
    inventoryItemId: string
    quantityOnHand: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type InventorySnapshotItemUpdateWithoutSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSnapshotItemsNestedInput
    bottlePhoto?: BottlePhotoUpdateOneWithoutSnapshotItemNestedInput
  }

  export type InventorySnapshotItemUncheckedUpdateWithoutSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bottlePhoto?: BottlePhotoUncheckedUpdateOneWithoutSnapshotItemNestedInput
  }

  export type InventorySnapshotItemUncheckedUpdateManyWithoutSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoostMetricCreateManyBoostInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
  }

  export type BoostMetricUpdateWithoutBoostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type BoostMetricUncheckedUpdateWithoutBoostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type BoostMetricUncheckedUpdateManyWithoutBoostInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type BarProductCreateManyProductInput = {
    id?: string
    barId: string
    customName?: string | null
    parLevel?: number | null
    reorderThreshold?: number | null
    preferredVendor?: string | null
    isActive?: boolean
  }

  export type BarProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bar?: BarUpdateOneRequiredWithoutBarProductsNestedInput
    counts?: InventoryCountUpdateManyWithoutProductNestedInput
    detections?: InventoryScanDetectionUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    counts?: InventoryCountUncheckedUpdateManyWithoutProductNestedInput
    detections?: InventoryScanDetectionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BarProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    parLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderThreshold?: NullableIntFieldUpdateOperationsInput | number | null
    preferredVendor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InventoryCountCreateManyProductInput = {
    id?: string
    barId: string
    countedAt?: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    unit: string
    remainingPercent?: number | null
    remainingBucket?: string | null
    method: string
    confidence?: number | null
    notes?: string | null
  }

  export type InventoryScanDetectionCreateManyProductInput = {
    id?: string
    sessionId: string
    productGuessText: string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
  }

  export type InventoryCountUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bar?: BarUpdateOneRequiredWithoutInventoryCountsNestedInput
  }

  export type InventoryCountUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCountUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    barId?: StringFieldUpdateOperationsInput | string
    countedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    remainingPercent?: NullableIntFieldUpdateOperationsInput | number | null
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    method?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryScanDetectionUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
    session?: InventoryScanSessionUpdateOneRequiredWithoutDetectionsNestedInput
  }

  export type InventoryScanDetectionUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryScanDetectionUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryScanDetectionCreateManySessionInput = {
    id?: string
    productGuessText: string
    productId?: string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: number
    remainingBucket?: string | null
    sizeMlGuess?: number | null
  }

  export type InventoryScanDetectionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
    product?: BarProductUpdateOneWithoutDetectionsNestedInput
  }

  export type InventoryScanDetectionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryScanDetectionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productGuessText?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    remainingBucket?: NullableStringFieldUpdateOperationsInput | string | null
    sizeMlGuess?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}